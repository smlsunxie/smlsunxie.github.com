<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-18T19:21:14+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java OCP 題目解析：關於 java 指標的運作觀念]]></title>
    <link href="http://smlsun.com/blog/2013/01/17/java-pointer/"/>
    <updated>2013-01-17T11:44:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/01/17/java-pointer</id>
    <content type="html"><![CDATA[<p>最近在看 OCP java 證照的題目，有個觀念與大家分享，在實際開發上才不會因為觀念不清楚產生 bug 時死的不明不白，題目如下：</p>

<p>資料來源：<a href="http://yaya741228.pixnet.net/blog">來喝杯JAVA咖啡</a></p>

<p>Given:</p>

<p>``` java</p>

<pre><code>class Foo {
    private int x;

    public Foo(int x) {
        this.x = x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getX() {
        return x;
    }
}

public class Gamma {
    static Foo fooBar(Foo foo) {
        foo = new Foo(100);
        return foo;
    }

    public static void main(String[] args) {
        Foo foo = new Foo(300);
        System.out.print(foo.getX() + "-");

        Foo fooFoo = fooBar(foo);
        System.out.print(foo.getX() + "-");
        System.out.print(fooFoo.getX() + "-");

        foo = fooBar(fooFoo);
        System.out.print(foo.getX() + "-");
        System.out.print(fooFoo.getX());
    }
}
</code></pre>

<p>```
What is the output?</p>

<pre><code>A. 300-100-100-100-100
B. 300-300-100-100-100
C. 300-300-300-100-100
D. 300-300-300-300-100
</code></pre>

<p>答案：</p>

<pre><code>B
</code></pre>

<p>解析：</p>

<pre><code>做這題頭腦不夠清楚可能會被搞混喔
這題是考JAVA 隱藏的指標觀念，其實規則很容易：
1. 方法的呼叫永遠都是傳值，方法在接到值之後，會另外產生一個空間來存這個值，也就是有兩份值，兩個位址
2. 等號的運算有分為基本資料型態(int, float等等) 和物件兩種
    2.1. 等號處理基本資料型態時是傳值
    2.2. 等號處理物件時是傳位址
</code></pre>

<p>依照題目的情況來模擬一下：</p>

<p>``` java</p>

<pre><code>Foo foo = new Foo(300);
Foo fooFoo = fooBar(foo);
</code></pre>

<p>```</p>

<p>生成一個物件，並且呼叫下面方法，在呼叫之前，記憶體的情況如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>

    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>

    </tr>

  </tbody>
</table>


<p>``` java</p>

<pre><code>    static Foo fooBar(Foo foo) {
        foo = new Foo(100);
        return foo;
    }
</code></pre>

<p>```</p>

<p>方法第一行接收了物件之後就另外產生空間複製一份，記憶體如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
    </tr>

  </tbody>
</table>


<p>方法第二行new 了一個物件，也就是生成了新的位址，把這個物件位指指派給foo，記憶體如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>
      <td></td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=100</td>
    </tr>

  </tbody>
</table>


<p>你會發現，有一個空間沒有指標指到它了，沒錯，這樣一來這個空間隨時會被空間回收程序收走</p>

<p>方法第三行回傳了fooBar: foo指標</p>

<p>後來在主方法執行了這一行</p>

<pre><code>foo = fooBar(fooFoo);
</code></pre>

<p>之後記憶體狀況會變成</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td></td>
      <td></td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=100</td>
    </tr>

  </tbody>
</table>


<p>只要記住前述兩大規則，就可以掌握所有JAVA 中所有的指標規則</p>

<p>我只有將排版美化，其他都是原作者的內容，另外還有一題特殊情形：</p>

<p>Given:</p>

<p>``` java</p>

<pre><code>public class KungFu {
    public static void main(String[] args) {
        Integer x = 400;
        Integer y = x;
        x++;
        StringBuilder sb1 = new StringBuilder("123");
        StringBuilder sb2 = sb1;
        sb1.append("5");
        System.out.println((x == y) + " " + (sb1 == sb2));
    }
}
</code></pre>

<p>```</p>

<p>What is the result?</p>

<pre><code>A. true true
B. false true
C. true false
D. false false
E. Compilation fails.
F. An exception is thrown at runtime.
</code></pre>

<p>答案：</p>

<pre><code>B
</code></pre>

<p>解析：</p>

<p>Integer是int的WapperClass，雖然以物件的形式來表現，不過在做等於運算的時候要視為基本資料型態，以傳值的作法來做</p>

<p>一般物件的話當然做等於運算就是傳指標了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Grails: 特性以及各種不同約定放置程式的用途介紹]]></title>
    <link href="http://smlsun.com/blog/2013/01/15/intrduction-grails/"/>
    <updated>2013-01-15T20:17:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/01/15/intrduction-grails</id>
    <content type="html"><![CDATA[<p>之前在某次 nodejs 聚會應邀說明 <a href="http://smlsun.com/slides/java-with-node.html">nodejs 在 java 上如何結合運用</a>，其中有介紹到 Grails，一個完整的 java frameworks，涵蓋前端到後端所有的程式開發，除此之外，他還效法了 ruby on rails 的精神，大量簡化了 java 在開發流程上繁瑣的編譯、打包、佈署等相關的作業，以及複雜的環境設定，而之前對我而言只知道其特性，並沒有很深入去使用，剛好最近有幸使用他來開發一些應用，故想透過這個機會，慢慢把所學整理起來，介紹給大家，作為這系列的第一篇，將說明 grails 的特性，以及其各種不同用途的 Class(groovy) 介紹。</p>

<p>Grails 的特性，只要熟悉 ruby on rails 的朋友應該可以大致了解，在加上 java 的血統，其比較重要的特性如下：</p>

<ul>
<li>Groovy：與Java 平台集成性最好的動態語言作為Grails的基礎</li>
<li>建構於 Spring、Hibernate、Quartz、SiteMesh、JUnit、Ant 成熟開源框架之上</li>
<li>URLMappings：Don’t Repeat Yourself</li>
<li>約定優於配置：Convention over Configuration</li>
<li>自動產生 CRUD 維護畫面：scaffold</li>
</ul>


<p>使用 Groovy，做為 grails 開發的基礎，其特性就是大量簡化 java 語言繁瑣的程式指令步驟。</p>

<p>可以看到 Grails 算是集目前 java 世界許多成熟的套件，這些原本單獨使用很繁瑣的套件，在 Grails 上都有某種程度的簡化，簡單到一開始很難直覺想像，往後會會在詳細介紹，這邊不多談。</p>

<p>接著就是設定的部份，在傳統的 java 開發我們常常需要設定像是 jdbc config 、 spring aop 設定的位置等，在 Grails 中，是基於「約定優於配置」的精神，也就是只要放對位置，設定就會生效。</p>

<p>以及 Don’t Repeat Yourself 的精神，在網路應用程式的開發，假設有用到 restful 的技術，在傳統的 JAVA 開發，總要為每個 class 設定 url 規則，如果一多是很繁瑣的。</p>

<p>最後就是自動產生 CRUD 維護畫面，在開發初期，常常需要快速的建立測試資料，以往要是前端與後端程式開發是分開的，總是需要等到後端工程師將 API 開出來後才能開始進行資料庫操作，在 grails 效法 ruby rails 也提供了快速產生維護畫面的功能。</p>

<p>以上是 grails 的特性簡介，不過！絕對不只如此其他還有很多特性，往後會在一一介紹，完全改變對於 Java 開發的習慣。</p>

<p>再來就要在簡單介紹，在 grails 各種不同用途的 Class(groovy) 介紹：</p>

<p><img src="https://lh6.googleusercontent.com/-qgBQ7bBJaDg/UPVP_UtqoxI/AAAAAAAALfQ/rPBPRd5iLXk/s223/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-01-15+%E4%B8%8B%E5%8D%888.46.39.jpg" alt="img" /></p>

<p>在「約定優於配置」的精神下，grails 本身就針對不同責任的程式進行分類，可以看到如上圖幾種，這邊將簡單介紹各個項目所有處理的事情：</p>

<ul>
<li>domain: 簡單來講就是原本 hibernate 的 DAO 物件，如果沒有用過類似 O/R MAPPING 的技術可以以把它想像成每個不同的 table 的定義，屬於 MVC 架構中的 Model</li>
<li>controllers: 也就是 MVC 架構中的 control，用來操作 Model，以及將運算結果呈現給 view</li>
<li>view: MVC 架構中的 view，在 grails 的世界，是用 gsp ，可以想像成 jsp</li>
<li>taglib: 可以在 view 中使用一些已經定義好的 tag ，原本在傳統的 j2ee 是非常繁瑣的技術，在 grails 可以很方便使用。</li>
<li>services: 商業邏輯放置的位置，這部份的程式可任意在 domain、controllers、taglib中直接宣告，將利用 spring 進行注入，有 scope 以及 transaction 交易安全的屬性可以進行操作</li>
<li>utils: 檢查數值或資料是否符合特定的規格運算程式放置的地方，比如說 email</li>
<li>scripts: 可以撰寫在 terminal 或是 command line 下可以執行的程式，搭配 <code>grails create-script execute-report</code> 使用。</li>
<li>i18n: 也就是多語系啦，可以搭配 taglib 在 view 層進行語系的轉換</li>
<li>src/java: 在 grails 如果你要寫傳統 java 也是 ok 的只要放在這個資料夾，就會編譯成 class</li>
<li>src/groovy: 上述分類中無法歸屬，或著原本有寫過純 groovy 的程式碼就放在這</li>
<li>test/utils: 單元測試，只要放在這資料夾的測試程式，都會被執行</li>
<li>test/integration: 整合測試，也就是會將上述所有的不同功能都載入進行測試。</li>
</ul>


<p>大致上上面所說的就是 grails 中一開始需要習慣的地方，與以往的 free style 的開發雖然多了些限制，但有了約定，基本上程式也不會亂放導致東一塊西一塊，並且透過了解上面的結構，對於程式初學也可以較清楚知道一個完整的程式，必須包含哪些不同責任的元件。</p>

<p>也許有些專案成員沒有辦法立即現有的工作換到新的開發框架，不過！找時間玩玩看，相信可以更了解程式的責任釐清，像我就是！陸續會在根據不同責任的程式使用的方式個別進行詳細說明，文章就到這啦！</p>

<p>這篇花了我一小時的時間，寫文章還是不夠快速，要在加油…</p>

<p>最後如果想要更進一步<strong>及早</strong>了解可以參考 <a href="http://grails.org/doc/latest/">Grails Quick Start</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ireport use qrcode]]></title>
    <link href="http://smlsun.com/blog/2012/12/07/ireport-use-qrcode/"/>
    <updated>2012-12-07T10:41:00+08:00</updated>
    <id>http://smlsun.com/blog/2012/12/07/ireport-use-qrcode</id>
    <content type="html"><![CDATA[<p>其實這篇才是最後的目的，讓我們回顧一下系列文章：</p>

<ul>
<li><p><a href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/">Agile Java With Gradle: 使用 Gradle 快速開發 Java</a></p>

<p>  利用gradle 快速開發java，並且包成jar，所要做的就是下一篇文章scriptlet 會用到的jar</p></li>
<li><p><a href="http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet/">Ireport Use Scriptlet</a></p>

<p>  說明如何引入自己寫的class在ireport可以使用</p></li>
</ul>


<p>最後所有做的就是</p>

<h2>ireport 產生 QRCode</h2>

<p>So，之前兩篇文章把一些細節都說明過了，就直接進入重點吧！</p>

<p>參考這篇文章</p>

<p><a href="http://stackoverflow.com/questions/7626013/google-zxing-barcode-generator-in-ireport">google-zxing-barcode-generator-in-ireport</a></p>

<p>把第二篇的javacode改寫後，程式碼如下：</p>

<p>``` java
package com.smlsun.ireport;
import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import net.sf.jasperreports.engine.JRDefaultScriptlet;
import net.sf.jasperreports.engine.JRScriptletException;</p>

<p>public class QRCodeScriptlet extends JRDefaultScriptlet {</p>

<pre><code>public void afterDetailEval() throws JRScriptletException {
    QRCodeWriter writer = new QRCodeWriter();
    BitMatrix matrix = null;

    try {
        matrix = writer.encode(getFieldValue("ORDERID").toString(), BarcodeFormat.QR_CODE, 256, 256);
        this.setVariableValue("BarCodeImage", MatrixToImageWriter.toBufferedImage(matrix) );
    } catch (WriterException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>不多說了，重點如下：</p>

<ul>
<li>需要用的套件與版本，請參考 <a href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/">Agile Java With Gradle: 使用 Gradle 快速開發 Java</a> 的gradle.build，其中 <code>com.google.zxing</code> 主要是要用來產生QRcode</li>
<li>將你要轉換成QRcode 的文字傳入，此範例用的是 Field ORDERID</li>
<li>同樣將處理結果塞到 ireport的 Variable，此範例命名為 BarCodeImage</li>
<li>在此 Variable 的型別為 BufferedImage</li>
</ul>


<p>回到ireport，我們同樣要進行 <a href="http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet/">Ireport Use Scriptlet</a> 中，ireport的設定，其中不一樣的是：</p>

<ul>
<li>Variable 的 type 要改成 java.awt.image.BufferedImage</li>
<li>然後原本用的是text field 改成用 Image</li>
<li>Image的type 改成 java.awt.Image</li>
</ul>


<p>上面都處理好，就可以來看結果了</p>

<p><img src="https://lh5.googleusercontent.com/-XWqDIn7kLFs/UMFcwQZq9MI/AAAAAAAALXg/PTyLE0dmsLk/s640/ireport%2520qrcode.jpg" alt="qrcode" /></p>

<p>DONE!!如果有此需求，趕快動手做做看囉～</p>

<h3>請搭配我的github project 服用～</h3>

<blockquote><p><a href="https://github.com/smlsunxie/ireport-qrcode">ireport-qrcode github</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ireport use scriptlet]]></title>
    <link href="http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet/"/>
    <updated>2012-12-06T20:00:00+08:00</updated>
    <id>http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet</id>
    <content type="html"><![CDATA[<p>在開始之前請容許我發洩一下：</p>

<p>ireport 的文件真他媽的少阿!</p>

<p>希望透過這篇文章，能幫助大家節省一些時間，其實scriptlet很強大</p>

<p>知道原理後之後就很簡單了，你可以輕易的讓ireprt中的資料交由自己寫的class進行處理，與ireport的互動將更加容易</p>

<p>只是沒有文件說明他怎麼用，以致沒有人了解他</p>

<p>開始我們的正題</p>

<h2>如何使用 ireport scriptlet</h2>

<p>先來看看java code</p>

<p>``` java
package com.smlsun.ireport;
import net.sf.jasperreports.engine.JRDefaultScriptlet;
import net.sf.jasperreports.engine.JRScriptletException;</p>

<p>public class TestScriptlet extends JRDefaultScriptlet {</p>

<pre><code>public void afterDetailEval() throws JRScriptletException {
   this.setVariableValue("titleAddOrderid", "test Scriptlet ORDERID:"+getFieldValue("ORDERID").toString() );
}
</code></pre>

<p>}
```</p>

<h3>java部分</h3>

<p>重點如下：</p>

<ul>
<li>需要注意的是需要 <code>extends JRDefaultScriptlet</code></li>
<li>接著你需要實作 JRDefaultScriptlet 裡的介面，此範例實作afterDetailEval，也就是當detal band畫完之後進行處理</li>
<li>透過 getFieldValue 來取得報表中有的欄位值進行處理，此範例只是加上一些字串而已</li>
<li>處理好的值塞到ireport 事先定義好的Variable，透過 setVariableValue</li>
<li>將寫完的java 打包成jar，可以看我上一篇文章 <a href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/">gradle</a> 快速完成！</li>
</ul>


<p>java部分大概就是這樣了~</p>

<hr />

<h3>接著回到ireport</h3>

<p>需要處理的重點如下：</p>

<ul>
<li>將打包好的jar加入到ireport的classpath</li>
<li>在你要使用的報表將寫好的class name加到scriptlets，記得要連package</li>
<li>將Variable建好，需要與class裡定義的一樣，此例需命名為 titleAddOrderid</li>
<li>新增一個text field 將Expression 填入建好的 $v{titleAddOrderid}</li>
</ul>


<p>OK啦～如此一來就算完成讓ireport 使用 scriptlet，沒圖沒真相，結果如下：</p>

<p><img src="https://lh6.googleusercontent.com/-aK45tf5w6U8/UMFWA9BRnhI/AAAAAAAALXU/WYeH7MHoSh8/s640/testIreportScriptlet.jpg" alt="testIreportScriptlet" /></p>

<p>其實真的不難，做過一次就知道了，就是因為文件少，不知從何開始，希望能幫幫ireport苦惱的人～</p>

<p>最後再補上，別人錄的 step by step 影片，他是用 image當例子，跟本範例用string原理是一樣的</p>

<p><a href="http://ireport-tutorial.blogspot.tw/2008/11/show-blob-image-in-ireport.html">show-blob-image-in-ireport</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[agile java with gradle: 使用 gradle 快速開發 java]]></title>
    <link href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/"/>
    <updated>2012-12-06T18:04:00+08:00</updated>
    <id>http://smlsun.com/blog/2012/12/06/agile-java-with-gradle</id>
    <content type="html"><![CDATA[<p>以我過往開發java的經驗，總是離不開eclipse，每次要開發新專案，總是要設置一次eclipse的classpath</p>

<p>不然就是共同開發時，可能因為夥伴沒有上傳相依套件，造成編譯失敗</p>

<p>又或者自己去找缺的套件，好死不死版本不對造成程式異常</p>

<p>種種開發java遇到的問題總是困擾著我，又因為這樣浪費的很多時間～</p>

<hr />

<p>怎麼辦！？介紹大家一帖好藥</p>

<h2>Gradle</h2>

<p>之前就有介紹過他，請看我的<a href="http://smlsun.com/slides/java-with-node.html">slide</a></p>

<p>今天在開發一個小程式，索性就不用eclipse，也不去網路上下載套件，將程式寫好後放到gradle的編譯路徑</p>

<p>然後編輯build.gradle，內容如下</p>

<p>``` groovy
apply plugin: 'java'
apply plugin: 'eclipse'</p>

<p>repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile group: 'com.google.zxing', name: 'javase', version: '2.1'
compile group: 'net.sf.jasperreports', name: 'jasperreports', version: '5.0.0'
compile group: 'com.lowagie', name:'itext', version:'2.1.7'
</code></pre>

<p>}</p>

<p>```</p>

<p>可以看到我用到三個套件，分別是javase，jasperreports以及itext，如果你要查套件對應的group以及version可上下列網址查詢：</p>

<p><a href="http://search.maven.org/">maven Central Repository</a></p>

<p>輸入你要找的套件名稱，就會列出相關的資訊。</p>

<p>接著我們只要在Terminal鍵入下列指令：</p>

<p><code>gradle build jar</code></p>

<p>gradle 就會進行 java compile，並且把熱熱的class馬上幫你包成jar讓你吃，ㄜ，不是！是讓你用～</p>

<p>就是這麼簡單，如果你還很嫩，離不開eclipse，別擔心，一句指令讓你使用IDE!</p>

<p><code>gradle eclipse</code></p>

<p>這時候gradle會根據你設定的 dependencies 幫你把classpath建好，方便吧！</p>

<p>剛剛提到多人開發，缺套件，或者抓錯版本的問題將一去不復返，任何人拿到程式碼，編譯出來的東西都會是一樣，將不再有缺套件沒辦法編譯的問題，可以輕省快速的開發java，以及處理繁瑣的編譯包jar步驟，更快的驗證寫出來的程式，正是敏捷開發的精神!</p>

<p>如何？還不趕快試試看阿！</p>
]]></content>
  </entry>
  
</feed>
