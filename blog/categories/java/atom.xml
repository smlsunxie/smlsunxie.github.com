<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-05-07T17:06:12+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[grails taggable plugin 搭配 jquery tagit 的完美組合]]></title>
    <link href="http://smlsun.com/blog/2013/03/01/grails-taggable/"/>
    <updated>2013-03-01T18:34:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/03/01/grails-taggable</id>
    <content type="html"><![CDATA[<p>引言：<a href="http://blog.lyhdev.com/2013/01/grails-22.html">快速瀏覽 Grails 2.2 新功能</a></p>

<blockquote><p>Grails 是受到 Ruby on Rails (RoR) 啟發的 Java EE 開發框架，它利用 Java 世界的 Groovy Scripting 語言實現與 Rails MVC 架構相似的開發工具；因為基於 Java 豐富的企業元件基礎，可以同時獲得敏捷的開發效率，並且和既有的 Java 程式保持相容。</p></blockquote>

<p>最近開始想要幫家裡開發一個資訊發佈平台，因為我本身習慣開發 java，這陣子經由 <a href="http://blog.lyhdev.com/">lyhcode</a> 的介紹開始使用 Grails，發現他真的是一個充滿驚奇的 framework，一開始可能會因為他的 <strong>精簡</strong> 讓你感到困惑，原本可能需要的步驟被省略後反而無法理解… 但一旦深入了解並且了解其習性後，才發現原來開發 java 也可以這麼快速！</p>

<p>一旦使用 Grails 後，你就不想用原始的 java 開發程式，正所謂回不去了… 除了骨子裡是 java，外在的部分基本上已經完全不一樣了，是說變帥了嘛？（誤）</p>

<p>回到正題，在一般 blog 的網站，很常用到的 tag (標籤)在實作上… 說實在的細節實在很多，我也不知道該怎麼實作… 在完全不知道怎麼實作光構思就可能花上一天，在加上開發運氣好的話或許 3 天解決，但今天我所要介紹的，只花你 1 小時，就完成 taggable 的實作！！很難想像嘛？就讓我們繼續看下去。</p>

<p>此範例參考下列網站：<a href="http://blog.armbruster-it.de/2011/04/a-perfect-team-grails-taggable-plugin-and-jquery-tagit/">Grails Taggable plugin and JQuery Tagit</a>，在這個範例中用的 grails 版本：1.4；jquery-tagit 版本：1.5。</p>

<p>而本文章撰寫時所使用的 grails 版本：2.2；jquery-tagit 版本：2.0。雖然版本不一樣但步驟上大致相同，首先我們必須安裝 taggable plugin。</p>

<h1>taggable &amp; jquery-ui plugin install</h1>

<p>在新版 2.2 grails 中已不建議使用 plugin install，根據官方的建議我們只要在 BuildConfig.groovy 新增下列：</p>

<pre><code>compile ':spring-security-ui:latest.release'
compile ":taggable:1.0.1"
</code></pre>

<p>一旦進入 grails 運行環境時將會自動安裝 plugin，就是這麼簡單，而 resources plugin 在 2.2 版已內建，所以不需要安裝，接著我們來處理…</p>

<h1>jquery tagit install</h1>

<p>下載 <a href="http://aehlke.github.com/tag-it/">jquery tagit</a></p>

<p>解壓縮後將檔案放置於：</p>

<ul>
<li>jquery.tagit.css: 'web-app/tagit/css/jquery.tagit.css'</li>
<li>tagit.ui-zendesk.css: 'web-app/tagit/css/tagit.ui-zendesk.css'</li>
<li>tag-it.js: 'web-app/tagit/js/tag-it.js'</li>
</ul>


<p>接著需要定義 ApplicationResourses.goovy</p>

<pre><code>tagit {
    dependsOn 'jquery-ui'
    resource url: 'tagit/css/jquery.tagit.css'
    resource url: 'tagit/css/tagit.ui-zendesk.css'
    resource url: 'tagit/js/tag-it.js'
}
</code></pre>

<p> 如此一來，基本環境與需要的套件都已經 ready 了，就讓我們開始實作 taggable 功能，就先從定義…</p>

<h2>domain object</h2>

<p>在 grails 中所謂的 domain object 就是所謂的資料表物件，定義資料結構的地方，假設我們是要開發自己的 blog 平台，那每一篇文章在資料庫中我們就可以定義 table 為 post，相關程式碼如下：</p>

<pre><code>package sample

class Post {
    String title
    String content
}
</code></pre>

<p>我們所要做的就是將 <code>org.grails.taggable.Taggable</code> import 進去，並且實作 Taggable</p>

<pre><code>package sample
import org.grails.taggable.Taggable

class Post implements Taggable {
    String title
    String content
}
</code></pre>

<p>ok～我們的 domain object 準備好的，不需要額外的設定，而且完整的程式碼就是這樣而已，其他勒？沒有了… 詳細 taggable 可以如何操作請參考 grails 官方 <a href="http://www.grails.org/plugin/taggable">taggable plugin api</a>，接著我們需將先將介面也就是 view 的部份完成。</p>

<h2>view</h2>

<p>在 view 的撰寫上，基本上與原文中一樣，這邊對重點的部份進行說明</p>

<p>``` groovy
  ...
  &lt;%-- in the head section --%>
  &lt;%-- 下面會將剛剛在 ApplicationResourses 所定義需要載入的 tagit 相關 js、css 載入 --%>
  &lt;r:use modules="tagit"/>
  ...
  &lt;%-- in the form section --%>
  <fieldset class="form"></p>

<pre><code>&lt;r:script&gt;
  $(function() {
    /*將${g.createLink(action: 'tags')}：產生 postController action 為 tags 的連結
    * 透過設定 jquery tagit 的 tagSource 的網址，一旦當你輸入 tag name
    * 將會透過 ajax 的方式比對輸入的資料與資料庫中的 tag 來當做 auto-completion
    * 的資料來源  
    */
    $("ul[name='tags']").tagit({select:true, tagSource: "${g.createLink(action: 'tags')}"});
  });
&lt;/r:script&gt;

&lt;h3&gt;Tags&lt;/h3&gt;
&lt;div class="fieldcontain"&gt;
  &lt;ul name="tags"&gt;
     &lt;%-- 透過 ${post.tags} 取得 tags 的資料 --%&gt;
    &lt;g:each in="${post.tags}"&gt;
      &lt;li&gt;${it}&lt;/li&gt;
    &lt;/g:each&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>  </fieldset>
```</p>

<p>view 的部分這樣就算完成啦，跟前面比起來稍微複雜一點，但還是挺簡單的，接著我們就需要定義 controller 的部份。</p>

<h2>controller</h2>

<p>首先我們先把 tag 的 auto-completion 實作完成，我們需要先將相關的套件載入</p>

<p>  import org.grails.taggable.Tag
  import grails.converters.JSON</p>

<p>接著我們就可以新增 controller 中的 action</p>

<p>``` groovy
  def tags = {</p>

<pre><code>render Tag.findAllByNameIlike("${params.term}%").name as JSON
</code></pre>

<p>  }
```</p>

<p>如此就完成了 tag 的 auto-completion 實作，不要懷疑，真的就是這樣！我們來看看這句程式碼代表的意義：</p>

<p>  render ... as JSON</p>

<p>指的是將查出來的結果轉為 JSON，接著看下面：</p>

<p>  Tag.findAllByNameIlike("${params.term}%")</p>

<p>根據 <a href="http://grails.org/doc/latest/guide/GORM.html#domainClasses">grails domainClasses API</a> 的說明，提到：</p>

<blockquote><p>Ilike - Similar to a Like, except case insensitive</p></blockquote>

<p>也就是區別大小寫，找出所有的 Name like "${params.term}%"，其中 params.term 是當你在前端 view 的 tag field keyin 尚未被處理為 tag 時回傳的變數名稱，一旦有定義 tagit 的 tagSource，將透過 get http method 的 url params 回傳；所以一旦你 keyin 就會觸動，http request 查詢相似的 tag 名稱，假設我輸入了 t 就會查出 Tag table 中符合資料的欄位 name 轉換為 json 回傳給前端，如下：</p>

<p>  ["test1","test2"]</p>

<p>如此一來在 web 網頁輸入 tag 名稱時就會帶出候選的 tag 讓使用者選取，執行畫面如下：</p>

<p><img src="https://lh5.googleusercontent.com/-CVYWTvOLJNc/UTClM-RrXQI/AAAAAAAALjg/DKmD2J-EhOU/s743/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-03-01+%E4%B8%8B%E5%8D%888.43.34.jpg" alt="img" /></p>

<p>很棒吧！假設 tag 輸入完畢了，我們必須把 tag 的資料寫入資料庫我們定義 action 為 update，相關程式碼如下：</p>

<p>``` groovy
  def update(Long id) {</p>

<pre><code>def post = Post.get(id)
post.properties = params
post.tags = params.tags // 為了儲存 tags 只要新增這行
post.save(flush: true)
</code></pre>

<p>  }
```</p>

<p>就這樣完成 taggable 的開發，包括漂亮的介面、方便的輸入以及資料的更新與讀取，使用 grails 對於開發 java web 應用程式實在是太幸福了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程式東西軍： grails & play!]]></title>
    <link href="http://smlsun.com/blog/2013/02/21/grails-play/"/>
    <updated>2013-02-21T16:37:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/21/grails-play</id>
    <content type="html"><![CDATA[<p>grails 與 play! 是當今比較完整的 java framework，當然兩者也常被拿來比較，要說比較優？其實各有各的好。</p>

<p>學習一樣工具需要花很多時間，在開始學習一樣新東西時，當然需要知道哪個是比較值得投入的，人生苦短阿！</p>

<p>因此，在搜尋相關資訊時，發現一個比較 grails and play! 的優缺點很不錯的網站，介紹給大家：</p>

<p><a href="http://www.ubertracks.com/preso/#/">Play vs. Grails Smackdown</a></p>

<p><img src="https://lh4.googleusercontent.com/-64F82PXFzn8/USXlKERNNuI/AAAAAAAALiA/4BTWEumSSzg/s786/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-02-21+%E4%B8%8B%E5%8D%885.12.13.jpg" alt="image" /></p>

<p>這網站的內容是用簡報的方式來呈現，個人是蠻喜歡的，他做了兩個網站，分別使用 grails and play! 進行建置，分別是<a href="http://bike.ubertracks.com/">grils - Bike Über Tracks</a> 以及 <a href="http://hike.ubertracks.com/">play! - Hike Über Tracks</a>；當然在比較時需要從各個面向來進行，該網站先從開發一個專案舉凡資料庫、MVC 架構、設定方式等來進行比較。</p>

<p><img src="https://lh4.googleusercontent.com/-fAoYv2Tr204/USXlLVE-RNI/AAAAAAAALiI/AJgJkzTA45w/s786/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-02-21+%E4%B8%8B%E5%8D%885.12.44.jpg" alt="image" /></p>

<p>接著透過一些應用程式評比工具來測試兩者的優劣，除了開發方便性，效能測試外，對於發展趨勢也有很完整的介紹。</p>

<p>最後的結論由三個面向來做為總結，分別是：程式碼、統計分析、生態系統來做為總結。</p>

<p>雖然有時候比較有點無濟於事，況且對於事物的看法每個人都有所不同，沒有絕對對錯，假如你也正在煩惱哪個比較好，希望這樣的資訊能夠協助你判斷囉。</p>

<p>我個人看完以後看起來是 grails 目前佔上風，不過… 科技日新月異，況且 play! 在 hacker news 數上完勝 grails，誰知道呢？</p>

<p>最後提醒大家，不管黑貓白貓，會抓老鼠的就是好貓，用起來最順手的就是好工具！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java OCP 題目解析：關於 java 指標的運作觀念]]></title>
    <link href="http://smlsun.com/blog/2013/01/17/java-pointer/"/>
    <updated>2013-01-17T11:44:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/01/17/java-pointer</id>
    <content type="html"><![CDATA[<p>最近在看 OCP java 證照的題目，有個觀念與大家分享，在實際開發上才不會因為觀念不清楚產生 bug 時死的不明不白，題目如下：</p>

<p>資料來源：<a href="http://yaya741228.pixnet.net/blog">來喝杯JAVA咖啡</a></p>

<p>Given:</p>

<p>``` java</p>

<pre><code>class Foo {
    private int x;

    public Foo(int x) {
        this.x = x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getX() {
        return x;
    }
}

public class Gamma {
    static Foo fooBar(Foo foo) {
        foo = new Foo(100);
        return foo;
    }

    public static void main(String[] args) {
        Foo foo = new Foo(300);
        System.out.print(foo.getX() + "-");

        Foo fooFoo = fooBar(foo);
        System.out.print(foo.getX() + "-");
        System.out.print(fooFoo.getX() + "-");

        foo = fooBar(fooFoo);
        System.out.print(foo.getX() + "-");
        System.out.print(fooFoo.getX());
    }
}
</code></pre>

<p>```
What is the output?</p>

<pre><code>A. 300-100-100-100-100
B. 300-300-100-100-100
C. 300-300-300-100-100
D. 300-300-300-300-100
</code></pre>

<p>答案：</p>

<pre><code>B
</code></pre>

<p>解析：</p>

<pre><code>做這題頭腦不夠清楚可能會被搞混喔
這題是考JAVA 隱藏的指標觀念，其實規則很容易：
1. 方法的呼叫永遠都是傳值，方法在接到值之後，會另外產生一個空間來存這個值，也就是有兩份值，兩個位址
2. 等號的運算有分為基本資料型態(int, float等等) 和物件兩種
    2.1. 等號處理基本資料型態時是傳值
    2.2. 等號處理物件時是傳位址
</code></pre>

<p>依照題目的情況來模擬一下：</p>

<p>``` java</p>

<pre><code>Foo foo = new Foo(300);
Foo fooFoo = fooBar(foo);
</code></pre>

<p>```</p>

<p>生成一個物件，並且呼叫下面方法，在呼叫之前，記憶體的情況如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>

    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>

    </tr>

  </tbody>
</table>


<p>``` java</p>

<pre><code>    static Foo fooBar(Foo foo) {
        foo = new Foo(100);
        return foo;
    }
</code></pre>

<p>```</p>

<p>方法第一行接收了物件之後就另外產生空間複製一份，記憶體如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
    </tr>

  </tbody>
</table>


<p>方法第二行new 了一個物件，也就是生成了新的位址，把這個物件位指指派給foo，記憶體如下</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td>main:foo</td>
      <td></td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=100</td>
    </tr>

  </tbody>
</table>


<p>你會發現，有一個空間沒有指標指到它了，沒錯，這樣一來這個空間隨時會被空間回收程序收走</p>

<p>方法第三行回傳了fooBar: foo指標</p>

<p>後來在主方法執行了這一行</p>

<pre><code>foo = fooBar(fooFoo);
</code></pre>

<p>之後記憶體狀況會變成</p>

<table class="table">

  <tbody>
    <tr>
      <td>指標</td>
      <td></td>
      <td></td>
      <td>fooBar:foo</td>
    </tr>
    <tr>
      <td>內容</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=300</td>
      <td>Foo物件:X=100</td>
    </tr>

  </tbody>
</table>


<p>只要記住前述兩大規則，就可以掌握所有JAVA 中所有的指標規則</p>

<p>我只有將排版美化，其他都是原作者的內容，另外還有一題特殊情形：</p>

<p>Given:</p>

<p>``` java</p>

<pre><code>public class KungFu {
    public static void main(String[] args) {
        Integer x = 400;
        Integer y = x;
        x++;
        StringBuilder sb1 = new StringBuilder("123");
        StringBuilder sb2 = sb1;
        sb1.append("5");
        System.out.println((x == y) + " " + (sb1 == sb2));
    }
}
</code></pre>

<p>```</p>

<p>What is the result?</p>

<pre><code>A. true true
B. false true
C. true false
D. false false
E. Compilation fails.
F. An exception is thrown at runtime.
</code></pre>

<p>答案：</p>

<pre><code>B
</code></pre>

<p>解析：</p>

<p>Integer是int的WapperClass，雖然以物件的形式來表現，不過在做等於運算的時候要視為基本資料型態，以傳值的作法來做</p>

<p>一般物件的話當然做等於運算就是傳指標了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Grails: 特性以及各種不同約定放置程式的用途介紹]]></title>
    <link href="http://smlsun.com/blog/2013/01/15/intrduction-grails/"/>
    <updated>2013-01-15T20:17:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/01/15/intrduction-grails</id>
    <content type="html"><![CDATA[<p>之前在某次 nodejs 聚會應邀說明 <a href="http://smlsun.com/slides/java-with-node.html">nodejs 在 java 上如何結合運用</a>，其中有介紹到 Grails，一個完整的 java frameworks，涵蓋前端到後端所有的程式開發，除此之外，他還效法了 ruby on rails 的精神，大量簡化了 java 在開發流程上繁瑣的編譯、打包、佈署等相關的作業，以及複雜的環境設定，而之前對我而言只知道其特性，並沒有很深入去使用，剛好最近有幸使用他來開發一些應用，故想透過這個機會，慢慢把所學整理起來，介紹給大家，作為這系列的第一篇，將說明 grails 的特性，以及其各種不同用途的 Class(groovy) 介紹。</p>

<p>Grails 的特性，只要熟悉 ruby on rails 的朋友應該可以大致了解，在加上 java 的血統，其比較重要的特性如下：</p>

<ul>
<li>Groovy：與Java 平台集成性最好的動態語言作為Grails的基礎</li>
<li>建構於 Spring、Hibernate、Quartz、SiteMesh、JUnit、Ant 成熟開源框架之上</li>
<li>URLMappings：Don’t Repeat Yourself</li>
<li>約定優於配置：Convention over Configuration</li>
<li>自動產生 CRUD 維護畫面：scaffold</li>
</ul>


<p>使用 Groovy，做為 grails 開發的基礎，其特性就是大量簡化 java 語言繁瑣的程式指令步驟。</p>

<p>可以看到 Grails 算是集目前 java 世界許多成熟的套件，這些原本單獨使用很繁瑣的套件，在 Grails 上都有某種程度的簡化，簡單到一開始很難直覺想像，往後會會在詳細介紹，這邊不多談。</p>

<p>接著就是設定的部份，在傳統的 java 開發我們常常需要設定像是 jdbc config 、 spring aop 設定的位置等，在 Grails 中，是基於「約定優於配置」的精神，也就是只要放對位置，設定就會生效。</p>

<p>以及 Don’t Repeat Yourself 的精神，在網路應用程式的開發，假設有用到 restful 的技術，在傳統的 JAVA 開發，總要為每個 class 設定 url 規則，如果一多是很繁瑣的。</p>

<p>最後就是自動產生 CRUD 維護畫面，在開發初期，常常需要快速的建立測試資料，以往要是前端與後端程式開發是分開的，總是需要等到後端工程師將 API 開出來後才能開始進行資料庫操作，在 grails 效法 ruby rails 也提供了快速產生維護畫面的功能。</p>

<p>以上是 grails 的特性簡介，不過！絕對不只如此其他還有很多特性，往後會在一一介紹，完全改變對於 Java 開發的習慣。</p>

<p>再來就要在簡單介紹，在 grails 各種不同用途的 Class(groovy) 介紹：</p>

<p><img src="https://lh6.googleusercontent.com/-qgBQ7bBJaDg/UPVP_UtqoxI/AAAAAAAALfQ/rPBPRd5iLXk/s223/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-01-15+%E4%B8%8B%E5%8D%888.46.39.jpg" alt="img" /></p>

<p>在「約定優於配置」的精神下，grails 本身就針對不同責任的程式進行分類，可以看到如上圖幾種，這邊將簡單介紹各個項目所有處理的事情：</p>

<ul>
<li>domain: 簡單來講就是原本 hibernate 的 DAO 物件，如果沒有用過類似 O/R MAPPING 的技術可以以把它想像成每個不同的 table 的定義，屬於 MVC 架構中的 Model</li>
<li>controllers: 也就是 MVC 架構中的 control，用來操作 Model，以及將運算結果呈現給 view</li>
<li>view: MVC 架構中的 view，在 grails 的世界，是用 gsp ，可以想像成 jsp</li>
<li>taglib: 可以在 view 中使用一些已經定義好的 tag ，原本在傳統的 j2ee 是非常繁瑣的技術，在 grails 可以很方便使用。</li>
<li>services: 商業邏輯放置的位置，這部份的程式可任意在 domain、controllers、taglib中直接宣告，將利用 spring 進行注入，有 scope 以及 transaction 交易安全的屬性可以進行操作</li>
<li>utils: 檢查數值或資料是否符合特定的規格運算程式放置的地方，比如說 email</li>
<li>scripts: 可以撰寫在 terminal 或是 command line 下可以執行的程式，搭配 <code>grails create-script execute-report</code> 使用。</li>
<li>i18n: 也就是多語系啦，可以搭配 taglib 在 view 層進行語系的轉換</li>
<li>src/java: 在 grails 如果你要寫傳統 java 也是 ok 的只要放在這個資料夾，就會編譯成 class</li>
<li>src/groovy: 上述分類中無法歸屬，或著原本有寫過純 groovy 的程式碼就放在這</li>
<li>test/utils: 單元測試，只要放在這資料夾的測試程式，都會被執行</li>
<li>test/integration: 整合測試，也就是會將上述所有的不同功能都載入進行測試。</li>
</ul>


<p>大致上上面所說的就是 grails 中一開始需要習慣的地方，與以往的 free style 的開發雖然多了些限制，但有了約定，基本上程式也不會亂放導致東一塊西一塊，並且透過了解上面的結構，對於程式初學也可以較清楚知道一個完整的程式，必須包含哪些不同責任的元件。</p>

<p>也許有些專案成員沒有辦法立即現有的工作換到新的開發框架，不過！找時間玩玩看，相信可以更了解程式的責任釐清，像我就是！陸續會在根據不同責任的程式使用的方式個別進行詳細說明，文章就到這啦！</p>

<p>這篇花了我一小時的時間，寫文章還是不夠快速，要在加油…</p>

<p>最後如果想要更進一步<strong>及早</strong>了解可以參考 <a href="http://grails.org/doc/latest/">Grails Quick Start</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ireport use qrcode]]></title>
    <link href="http://smlsun.com/blog/2012/12/07/ireport-use-qrcode/"/>
    <updated>2012-12-07T10:41:00+08:00</updated>
    <id>http://smlsun.com/blog/2012/12/07/ireport-use-qrcode</id>
    <content type="html"><![CDATA[<p>其實這篇才是最後的目的，讓我們回顧一下系列文章：</p>

<ul>
<li><p><a href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/">Agile Java With Gradle: 使用 Gradle 快速開發 Java</a></p>

<p>  利用gradle 快速開發java，並且包成jar，所要做的就是下一篇文章scriptlet 會用到的jar</p></li>
<li><p><a href="http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet/">Ireport Use Scriptlet</a></p>

<p>  說明如何引入自己寫的class在ireport可以使用</p></li>
</ul>


<p>最後所有做的就是</p>

<h2>ireport 產生 QRCode</h2>

<p>So，之前兩篇文章把一些細節都說明過了，就直接進入重點吧！</p>

<p>參考這篇文章</p>

<p><a href="http://stackoverflow.com/questions/7626013/google-zxing-barcode-generator-in-ireport">google-zxing-barcode-generator-in-ireport</a></p>

<p>把第二篇的javacode改寫後，程式碼如下：</p>

<p>``` java
package com.smlsun.ireport;
import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import net.sf.jasperreports.engine.JRDefaultScriptlet;
import net.sf.jasperreports.engine.JRScriptletException;</p>

<p>public class QRCodeScriptlet extends JRDefaultScriptlet {</p>

<pre><code>public void afterDetailEval() throws JRScriptletException {
    QRCodeWriter writer = new QRCodeWriter();
    BitMatrix matrix = null;

    try {
        matrix = writer.encode(getFieldValue("ORDERID").toString(), BarcodeFormat.QR_CODE, 256, 256);
        this.setVariableValue("BarCodeImage", MatrixToImageWriter.toBufferedImage(matrix) );
    } catch (WriterException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>不多說了，重點如下：</p>

<ul>
<li>需要用的套件與版本，請參考 <a href="http://smlsun.com/blog/2012/12/06/agile-java-with-gradle/">Agile Java With Gradle: 使用 Gradle 快速開發 Java</a> 的gradle.build，其中 <code>com.google.zxing</code> 主要是要用來產生QRcode</li>
<li>將你要轉換成QRcode 的文字傳入，此範例用的是 Field ORDERID</li>
<li>同樣將處理結果塞到 ireport的 Variable，此範例命名為 BarCodeImage</li>
<li>在此 Variable 的型別為 BufferedImage</li>
</ul>


<p>回到ireport，我們同樣要進行 <a href="http://smlsun.com/blog/2012/12/06/ireport-use-scriptlet/">Ireport Use Scriptlet</a> 中，ireport的設定，其中不一樣的是：</p>

<ul>
<li>Variable 的 type 要改成 java.awt.image.BufferedImage</li>
<li>然後原本用的是text field 改成用 Image</li>
<li>Image的type 改成 java.awt.Image</li>
</ul>


<p>上面都處理好，就可以來看結果了</p>

<p><img src="https://lh5.googleusercontent.com/-XWqDIn7kLFs/UMFcwQZq9MI/AAAAAAAALXg/PTyLE0dmsLk/s640/ireport%2520qrcode.jpg" alt="qrcode" /></p>

<p>DONE!!如果有此需求，趕快動手做做看囉～</p>

<h3>請搭配我的github project 服用～</h3>

<blockquote><p><a href="https://github.com/smlsunxie/ireport-qrcode">ireport-qrcode github</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
