<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extjs | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/extjs/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-08-06T10:19:19+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs-5-30 事件宣告的建議]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-5-30/"/>
    <updated>2013-08-05T23:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-5-30</id>
    <content type="html"><![CDATA[<p>在使用 extjs 時，我們有幾個地方可以宣告事件的處理：</p>

<ol>
<li>在 controller 下宣告</li>
<li>在 component 下宣告</li>
</ol>


<p>一般剛開始使用 extjs 會搞不清楚什麼時候該使用 mvc 中的 controller 來定義，又或者直接宣告在 component 上，特別是 extjs 4 一大特性 mvc，會讓使用者覺得宣告在 controller 是第一選擇，這樣架構上比較符合官方建議，其實不然，既然 extjs 也支援在 component 上宣告事件，自然有其意義。</p>

<p>既然兩個方式都可以宣告事件，我們該如何區別事件的歸屬呢？筆者認為可以從事件發生關係到的元件或者元件特性（特定功能或是共用元件）來做區別，在明確的說，假設事件所操作的對象所涵蓋的範圍只有該元件以及元件 item 屬性底下所掛載的其他元件，那就應該定義在元件上，若是事件處理涵蓋多個元件的組合互動，那就應該要使用 controller 來定義。</p>

<p>另一個角度，如果該功能屬於共用元件，那事件應該定義在元件底下，屬於特定的功能事件，那應該使用 controller 來處理。</p>

<p>如此一來，如果是定義在元件上的事件，只要某功能有引入該元件，就不需要重覆定義，該元件就有基本的事件互動，一旦需要調整，也不需要一一去改有用到的元件，只要修改宣告事件的元件即可，這樣的情形就像通用元件的狀況，相反地，定義在 controller 的事件就是個別功能的特性了。</p>

<p>舉例來說，如筆者上一篇 <a href="http://smlsun.com/blog/2013/08/05/extjs-4-30/">精簡程式碼案例分享</a> 中的範例是一個標準的功能工具列，事件的定義就是宣告在元件定義上，之後只要有引入使用該標準工具列，就不需要在定義相關的事件。</p>

<p>最後根據上述的內容，整理出建議的事件定義對象</p>

<ol>
<li>如果事件的處理需要整合多個元件那應該定義在 controller 底下</li>
<li>如果該元件屬於特定功能才有的元件就算事件範圍只在某元件底下，事件還是要要定義在 controller 底下。</li>
<li>如果事件處理範圍只屬於某個元件底下並且屬於公用元件，那事件應該定義在元件</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs-4-30 精簡程式碼案例分享]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-4-30/"/>
    <updated>2013-08-05T19:54:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-4-30</id>
    <content type="html"><![CDATA[<p>程式的寫法百百種，要能夠完成一個特定功能沒有標準答案，但要寫的精簡需要經驗的累積，甚至需要對語言特性要有一定的了解，剛好筆者最近 review 了一段 extjs 程式碼，可以與大家分享。</p>

<p>在開始之前，必須先提到一個觀念，extjs 雖然是 RIA，並且有自己的類別化系統，不過他的類別或物件脫離不了 javascript，因此 javascript 中的<a href="http://www.josephjiang.com/presentation/OOJS/object-basic.html">物件</a>、<a href="http://blog.joomla.org.tw/javascript/54-general/81-javascript-functon-basic.html">函數</a>、<a href="http://smlsun.com/blog/2013/01/31/javascript-what-is-this/">this</a> 的特性他也都有。</p>

<p>接著我們來看一段 extjs 類別的程式碼，如下：</p>

<p>這樣的結構可以參考 extjs 官方對於 <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext-method-define">Ext.define</a> 的說明，其中函數所包含的參數 <code>define( className, data, createdFn )</code> data 的形態就是 Object，所以在下列程式第二個參數所傳入的就是標準的 javascript Object，只是裡面所定義的屬性 extjs 有自己的特定的命名以便辨別作為處理，但不代表你不可以把它當作一般的 Object 來操做，在使用 extjs 時很容易讓使用的人誤解認為他是個特別的存在，其實他也只是 javascript。</p>

<p>有了這樣的認知，我們看看下面的程式碼，裡面有很多段重覆的程式碼，參考註解。</p>

<p>``` javascript
Ext.define('foodprint.view. ', {</p>

<pre><code>extend: 'Ext.toolbar.Toolbar',
alias: 'widget.stdeditortoolbar',

requires: [
    'foodprint.view.CreateBtn',
    'foodprint.view.DeleteBtn',
    'foodprint.view.SaveBtn',
    'foodprint.view.ReadBtn',
    'foodprint.view.UpdateBtn'
],

itemId: 'stdEditorToolbar',

initComponent: function() {
    var me = this;

    Ext.applyIf(me, {
        items: [
            {
                xtype: 'createbtn',
                listeners: {
                    click: {
                        fn: me.onCreateBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'deletebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onDeleteBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'savebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onSaveBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'readbtn'
            },
            {
                xtype: 'updatebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onUpdateBtnClick,
                        scope: me
                    }
                }
            }
        ]
    });

    me.callParent(arguments);
},

onCreateBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=btn;
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    delbtn.setDisabled(true);
    savbtn.setDisabled(false);
    updbtn.setDisabled(true);
    redbtn.setDisabled(true);
},

onDeleteBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button;
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    delbtn.setDisabled(true);
},

onSaveBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button;
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    savbtn.setDisabled(true);
},

onUpdateBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button;
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    updbtn.setDisabled(true);
}
</code></pre>

<p>});
```</p>

<p>上面的每一個函式都重覆宣告了 5 個 btn，這樣在維護上是沒有效率的，假設我們需要在加一個按鈕，我們就必須每個函式在加一個宣告，其實還有更好的方式，假設你了解了物件、函式、還有 this 的特性，我們可以將這五個按鈕的參照存在第二個參數 data 下，透過例如：<code>this.updateBtn=component.down('button[itemId=createBtn]');</code> 如下面程式碼中 <code>onStdEditorToolbarRender</code>，用到的事件 binding 是 extjs Component <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Component-event-render">render 事件</a> 元件實體化後觸動該事件進行處理，只要找到一個這樣只執行一次的進入點，將需要用到的元件存入 this 這個物件，之後我們就不需要重覆 query 物件的參照，也更加快處理速度，雖然這樣的調整可能效果不明顯，但累積起還是很可觀的，特別當你感覺到慢的時候，可能已經遍佈程式碼中，<strong>好習慣要從日常養成</strong>。</p>

<p>``` javascript
Ext.define('foodprint.view.StdEditorToolbar', {</p>

<pre><code>extend: 'Ext.toolbar.Toolbar',
alias: 'widget.stdeditortoolbar',

requires: [
    'foodprint.view.CreateBtn',
    'foodprint.view.DeleteBtn',
    'foodprint.view.SaveBtn',
    'foodprint.view.ReadBtn',
    'foodprint.view.UpdateBtn'
],

itemId: 'stdEditorToolbar',

initComponent: function() {
    var me = this;

    Ext.applyIf(me, {
        items: [
            {
                xtype: 'createbtn',
                listeners: {
                    click: {
                        fn: me.onCreateBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'deletebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onDeleteBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'savebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onSaveBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'readbtn'
            },
            {
                xtype: 'updatebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onUpdateBtnClick,
                        scope: me
                    }
                }
            }
        ],
        listeners: {
            render: {
                fn: me.onStdEditorToolbarRender,
                scope: me
            }
        }
    });

    me.callParent(arguments);
},

onCreateBtnClick: function(button, e, eOpts) {
    this.delbtn.setDisabled(true);
    this.savbtn.setDisabled(false);
    this.updbtn.setDisabled(true);
    this.redbtn.setDisabled(true);
},

onDeleteBtnClick: function(button, e, eOpts) {
    this.delbtn.setDisabled(true);
},

onSaveBtnClick: function(button, e, eOpts) {
    this.savbtn.setDisabled(true);
},

onUpdateBtnClick: function(button, e, eOpts) {
    this.updbtn.setDisabled(true);
},

onStdEditorToolbarRender: function(component, eOpts) {
    this.crebtn=component.down('button[itemId=createBtn]');
    this.delbtn=component.down('button[itemId=deleteBtn]');
    this.savbtn=component.down('button[itemId=saveBtn]');
    this.updbtn=component.down('button[itemId=updateBtn]');
    this.redbtn=component.down('button[itemId=readBtn]');

}
</code></pre>

<p>});</p>

<p>```</p>

<p>優化過的程式碼，可以看到物件的 query 只有一次，之後都可以透過 this 來存取，每個函式所執行的都是關鍵的程式碼，沒有多餘的宣告，雖然是很簡單的觀念與應用，如果知道將會受用無窮，不只在 extjs 在一般的 javascript 開發也可以應用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs-3-30 mixins(混和) 特性說明]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-3-30/"/>
    <updated>2013-08-05T11:56:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-3-30</id>
    <content type="html"><![CDATA[<p>extjs4 中的 mixsins 是 extjs4 的新特性，在筆者之前寫過的文章中<a href="http://ithelp.ithome.com.tw/question/10120091">extjs 4 系列 1/5：新特性與基本概念</a> mixins (混合複數classes) 章節，有做過簡單介紹，讀者可以參考相關說明，了解 mixsins 的特性，官方 API 可參考連結：<a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Class-cfg-mixins">mixins API</a>，在 extjs 中屬於 Ext.Class 的函式，也就等於所有不管 mvc 或是元件，都可以使用 mixins 的特性。</p>

<p>接著，想要知道 mixins 在不同狀況下的處理方式可參考 <a href="http://www.cnblogs.com/fsjohnhuang/archive/2013/01/29/2880705.html#o1.3.3.">Ext JS 4 First Look 中文翻譯</a> mixins 章節，在使用上就必須要注意什麼情況下函式或屬性在捨麼情況下會被保留，什麼會被覆蓋。</p>

<p>舉個例子，假設我們有兩個 controller 分別如下：</p>

<p>共用元件之 controller：</p>

<p>``` javascript
Ext.define('foodprint.controller.StdController', {</p>

<pre><code>extend: 'Ext.app.Controller',

views: [
    'StdEditorToolbar'
],

refs: [
    {
        ref: 'stdEditorToolbar',
        selector: 'stdeditortoolbar'
    }
],

initial: function(tbar) {
    ...
},

onCreateBtnClick: function(btn) {
 ... 
}
</code></pre>

<p>});</p>

<p>```</p>

<p>另一個別功能之 controller:</p>

<p>``` javascript
Ext.define('foodprint.controller.AController', {</p>

<pre><code>extend: 'Ext.app.Controller',

mixins: {
    StdEditorToolbarCtrl: 'foodprint.controller.StdController'
},

views: [
    'BatchEditor'
],

refs: [
    {
        ref: 'batchGrid',
        selector: 'batchgrid'
    }
],

init: function(application) {
    ...
},

readBatch: function(obj, record, item, index, e, eOpts) {
    ...
},
</code></pre>

<p>});
```</p>

<p>在上述的使用情境中，StdController 中的 refs 將會失效，保留 AController 中的 refs，因此在這樣狀況下，若要在 AController 也要能夠有 StdController 中 refs 定義的元件，勢必要在 AController 再次定義一次 StdController 的 refs。</p>

<p>另一種使用情境：假設被 mixins 的類別跟基礎類別有同名的函式，但是我們希望兩個個別實作同名函式<strong>都可以被執行</strong>可以參考 <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Class-cfg-mixins">mixins API</a>的範例：</p>

<p>``` javascript</p>

<p>Ext.define('CanSing', {</p>

<pre><code> sing: function() {
     alert("I'm on the highway to hell...")
 }
</code></pre>

<p>});</p>

<p>Ext.define('Musician', {</p>

<pre><code> mixins: {
     canSing: 'CanSing'
 },

 sing: function() {
     // delegate singing operation to mixin
     this.mixins.canSing.sing.call(this);
 }
</code></pre>

<p>})
```</p>

<p>希望透過本篇可以讓讀者了解 mixins 的特性，進而有效的重覆利用函式，減少不必要的重覆程式碼。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs 2/30:使用 sencha architect 開發注意事項]]></title>
    <link href="http://smlsun.com/blog/2013/08/01/extjs-2-30/"/>
    <updated>2013-08-01T22:52:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/01/extjs-2-30</id>
    <content type="html"><![CDATA[<p>在使用 sencha architect 開發時，我們很難對 js 檔進行檔案修改，基本上所有的檔案調整，都是透過 architect 存檔時一並寫入對應的原始檔案，其中關於每個 js 的原始檔放於 <code>EXTJS_HOME/metadata</code>，但一旦你進入該資料夾檢視相關的檔案，可以發現他跟一般的 js 有出入，所以你也不要想再裡面進行編輯，有可能會造成整個專案運作異常。</p>

<p>除此之外在專案裡面，有兩個設定檔為 architect 所產生分別是 <code>.architect</code> 以及 <code>projectName.xds</code>，其中 <code>.architect</code> 會自動產生，但 xds 就不好搞了，如果你是一個人開發，還不致於發生問題，但若是多人開發，再加上有使用版本控管，問題就來了；xds 檔所記錄的似乎是在 architect 建立 extjs 元件之間的關聯，因此若是多人開發不同的功能，並且在版本控管的情況下，該檔案很容易有衝突；而在編修衝突時，很多時候會不知道該如何下手，因為代表元件的相關檔案識別皆已編碼，只有 IDE 才看的懂對應的關係，如果 xds 的內容無關緊要或是會重新產生那就算了，偏偏 xds 檔在 architect 是主要專案的進入點，因此如果處理的不好，很容易造成專案運作異常。</p>

<p>就筆者的經驗，一般 extjs 元件的建立或修改基本上都比較不會有問題，最容易產生異常的通常是在 application.js 這個檔案，在 extjs 的世界裡，該檔案定義了一個應用程式在運行時，需要載入 extjs 中 mvc 各個物件，為什麼他很容易出現問題呢？主要因為在使用 architect 時，當你新增元件時，IDE 將會自動將你新增的元件載入到 application.js 中，多人開發情形下，Application.js 就會是所有人的交集，不然照理分別開發新功能所新增的元件皆不同不應該會頻繁造成衝突，而因為 application.js 的多人異動，造成再 xds 中對 application.js 的檔案識別常常會有不同的代表造成衝突，一旦 xds 衝突一發生，編修時一不小心讓 IDE 不認得 Application.js，就會造成 Application.js 無法被識別，導致 IDE 認為沒有建立 Application.js，則以最原始的狀態 Application.js 作為預設，也就是沒有任何元件載入，導致於系統運作異常。</p>

<p>知道問題發生的原因，那上述問題怎麼解？其實只要改變我們建立物件的習慣即可，在說明作法前，需要先讓大家了解一下 extjs 如何載入相關 js 檔的，在 extjs 中，不管你是宣告 mvc 其中的任一類型的元件，或是繼承 extjs 原生的類別，很多時候我們會使用 require 這個宣告，來告訴 extjs 該元件要運作需要哪些類別配合，一旦你有定義 require，當元件運行時，extjs 就會自動將相關 require 的類別進行載入，這是個很方便的特性，幫助我們省去在 html 中載入所需 js 的麻煩，進一步的減少元件忘記或是載入錯誤。</p>

<p>前面有提到 application.js 是多人開發時的交集，一個方法是減少交集的產生，而我們該如何減少交集呢？可以用到 extjs 自動載入元件的特性，將我們需要用到的元件皆定義在 controller 底下，而在 application.js 只載入 controller 相關元件，如此就可以減少 application.js 變動，即使真的不幸還是造成 application.js 異常，我們知道只要將所有 controller 載入即可恢復，除了避免多人開發時造成程式碼衝突，將需要的物件定義在 controller 裡面也才是較正確的方式，完善的定義該功能再運行時所需的元件，可以帶來更易於維護的優點，另外在使用 architect 時，一旦你將相關物件加入 controller 時，IDE 也會問你要不要將設定在 application 載入的元件移除，如此一來元件所責任的功能也會更加清楚。</p>

<p>上述的解法，是筆者根據經驗認為比較優的解法，如果讀者有更好的想法也歡迎分享，希望可以讓有同樣困擾的人節省一點時間。</p>

<p>最後綜合上述的內容，整理出使用 architect 開發需要注意的重點如下：</p>

<ol>
<li>.sencha 檔案可以不用加入版本控管，一旦你使用 architect 進行存檔時，該檔案都會重新產生，衝突情形也可以直接覆蓋最新版本</li>
<li>xds 檔，很多時候都會有衝突，更新程式碼有衝突時，編修完成後記得開啟 architect 確認 application.js 中掛載的元件是否還好好的在那邊。</li>
<li>因為 architect 在編輯過程中不會動態載入你的元件，因此一旦你在 IDE 開啟中的狀態要進行程式碼更新，建議先對專案進行存檔，並且程式碼一旦更新為最新的，記得將 IDE 重啟以便重新載入所有更新過程式碼。</li>
<li>建立 extjs 元件時，不要懶惰讓 IDE 自行將元件加入到 application.js 可以的話建立該功能所需要的 controller 將其歸屬進去，整個功能架構也會更加清楚。</li>
<li>在 application 中，原則上只管理需要載入的 controller 即可，一旦編修衝突不順利，可以很快的進行復原。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs 1/30:form 表單之 submit 透過 rest 與後端 grails 的整合]]></title>
    <link href="http://smlsun.com/blog/2013/08/01/extjs-1-30/"/>
    <updated>2013-08-01T21:49:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/01/extjs-1-30</id>
    <content type="html"><![CDATA[<p>在 web appication 的開發中，常常會使用到的 form 表單的送出，在 extjs 中我們可以很輕易的使用 <code>Ext.form.Panel</code>，來完成表單的建立。</p>

<p>可參考 <a href="http://try.sencha.com/extjs/4.1.1/community/extjs4-mvc-ajax-xml-form/viewer.html">extjs form sample</a>所提供的範例，來了解程式的運作。</p>

<p>為了簡化表單送出的開發，盡量使用 extjs 所提供的 <code>submit()</code> 來進行表單的送出，他的好處是不需把 form 的欄位收集起來成為 json 往後傳，透過該函式 extjs 會自動將表單所屬元件所定義的 id 作為 request 中的 form data 往後傳，如此一來，一旦表單的內容有所改變，我們也不需調整。</p>

<p>而在筆者目前開發的專案中使用 extjs + grails 的組合並且前後端整合使用 rest 的方式來做為前後端的溝通協定。如下面網址的說明：<a href="http://grails.org/doc/latest/guide/webServices.html#13.1%20REST">grails rest</a>，根據文章中建議的 http method 所對應的不同方法來進行資料的增修改查。</p>

<p>不料在過程中，當要進行 PUT 對應的 UPDATE 時，發生 grails 無法解析表單資料的情形，拜一下 google 找到下面資料：</p>

<p><a href="http://grails.1312388.n4.nabble.com/HTTP-request-params-in-a-PUT-never-reach-the-controller-td1353329.html">HTTP request params in a PUT never reach the controller</a></p>

<p>節錄裡面的重點：</p>

<blockquote><p>It's possible that the servlet container will not parse PUT data as if
it's POST data. I assume that if you use the URL:</p>

<p><code>http://localhost:8080/app/api/users?userId=5</code></p>

<p>then "userId" will appear in the "params" object. However, Grails
handles the parsing of XML and JSON requests, so it you were to send
your parameters as XML, they would probably appear in the "params"
instance.</p></blockquote>

<p>也就是說，在 http method 使用 put 要可以在 grails 中的 params 存取相關的標單資料，必須使用網址方式來傳遞，但若這麼做，就失去我們使用 extjs form 所提供 submit() 的好處，還有資料內容將會輕易的被讀取，更重要的誰也不希望多寫幾行程式，為了要解決此問題，在開始說明解法前我們必須必須了解 http method 中 POST 與 GET 的差異。</p>

<p>一般而言，POST 是用於將表單內的資料送出，PUT 透過 JSON 或是 XML 來將表單送出，也因此後端 server 在接到 request 的 http request method 為 PUT 時，就算有參數包在 request body(form data) grails 也不會進行解析。</p>

<p>了解了表單送出的概念以及在 PUT 的情形下正確的表單資料送出的方式，我們就必須讓 extjs form 在表單送出時，將表單內容轉換為 json，在搜尋 extjs 的 api 總算讓我找到解法，<a href="http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.form.Basic-cfg-jsonSubmit">Ext.form.Basic cfg jsonSubmit</a> 就有此參數，一旦設定為 true，當 from 透過函式 submit() 將表單內容送出就會轉換為 json 格式，並且 content-type 變為 application/json。</p>

<p>最後我們只要在 grails 中的 urlMapping.groovy 中，針對你要送出的 route 加上，<code>parseRequest: true</code>，如下</p>

<p>"/$controller/$action?/$id?"(<strong>parseRequest: true</strong>) {...}</p>

<p>如此就可以解決在 form submit 並且 http method 為 PUT 時，grails 無法將 form 送出的表單資料進行存取的問題。</p>

<p>此問題與我的夥伴 <a href="http://blog.lyhdev.com/p/by-lyhcode.html">lyhcode</a>共同發現並解決，也可以參考由他所撰寫詳盡的說明 <a href="http://blog.lyhdev.com/2013/07/ext-js-grails-restful-web-services-put.html">Ext JS + Grails RESTful Web Services 實作問題之 PUT 表單資料
</a></p>

<p>Ext JS 教學內容由思創軟體提供，共同作者 <a href="http://blog.lyhdev.com/p/by-lyhcode.html">@lyhcode</a> 與 <a href="http://smlsun.com/aboutme/">@smlsun</a> 目前在校園及企業從事 JavaScript（含 Node.js, Ext JS）與 Java（含 Groovy, Grails, Gradle） 教育訓練及顧問工作。</p>
]]></content>
  </entry>
  
</feed>
