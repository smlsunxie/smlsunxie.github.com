<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extjs | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/extjs/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-18T12:47:39+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs: DOM、Element 以及 Component 的差別]]></title>
    <link href="http://smlsun.com/blog/2013/02/18/extjs-dom-element-component/"/>
    <updated>2013-02-18T12:32:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/18/extjs-dom-element-component</id>
    <content type="html"><![CDATA[<p>資料來源：</p>

<ul>
<li><a href="http://hi.baidu.com/andriond/item/757d24dcb1b8f139e3108f8a">理解Html DOM、Ext Element及Component</a></li>
</ul>


<p>學習及應用 extjs，需要理解Html DOM、Ext Element及Component三者的區別。extjs 是 Wed 前端框架，基於標準 W3C 構建設的，使用到的都是HTML、CSS、DIV 等相關技術。無論元件有多少屬性、還是事件、方法等，其最終都會轉化為 HTML 在瀏覽器上顯示出來，而每一個 HTML 頁面都有 DOM，瀏覽器中的所有內容都有相應的 DOM，動態改變頁面的內容正是透過 javascript 來操作 DOM 進行實現。</p>

<p>而在 extjs 中就有個專門用來處理 DOM 的類別 ...</p>

<h2>Ext.DomHelper</h2>

<p>DOM其實就是 W3C 標準定義的原始 API，在 extjs 中對 dom 進行強化，製作了 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.DomHelper">Ext.DomHelper</a></p>

<p>在官方 API 中可以看到該類別屬於 singleton，所謂的 singleton 就是所謂的整個程式在運行時只有一份，且不需宣告即已被實體化，官方文件中的範例：</p>

<pre><code>var dh = Ext.DomHelper; // create shorthand alias
// specification object
var spec = {
    id: 'my-ul',
    tag: 'ul',
    cls: 'my-list',
    // append children after creating
    children: [     // may also specify 'cn' instead of 'children'
        {tag: 'li', id: 'item0', html: 'List Item 0'},
        {tag: 'li', id: 'item1', html: 'List Item 1'},
        {tag: 'li', id: 'item2', html: 'List Item 2'}
    ]
};
var list = dh.append(
    'my-div', // the context element 'my-div' can either be the id or the actual node
    spec      // the specification object
);
</code></pre>

<p>可以看到 <code>var dh = Ext.DomHelper;</code> 並未透過 new 來進行建立實體，而在 Ext.DomHelper 特別針對了原生 javascript 的 Insertion methods 進行封裝，如下：</p>

<ul>
<li>append</li>
<li>insertBefore</li>
<li>insertAfter</li>
<li>overwrite</li>
<li>createTemplate</li>
<li>insertHtml</li>
</ul>


<p>當然 extjs 不只是單純的進行封裝那麼簡單，他還避免了一些在效能上容易造成問題的地方，比如說在我另一篇文章<a href="http://smlsun.com/blog/2013/02/01/javascript-performance/">Javascript: Performance &amp; Tip</a> 有提到的 『9. DOM』 使用 DocumentFragment 避免 ReFlow 的問題，在 extjs 中已採用此作法，可以從原始碼<a href="http://docs.sencha.com/ext-js/3-4/source/DomHelper-more.html#Ext-DomHelper">DomHelper-more</a> 中的 <code>createDom</code> 看到 <code>el = doc.createDocumentFragment();</code> 使用了 DocumentFragment。</p>

<p>而DOM是W3C標準定義的原始API，如果我們要取得 dom 可以透過 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext-method-getDom">Ext.getDom(el)</a>，除了用 dom id 來索引之外，也可以傳入 Element，如：</p>

<pre><code>// gets dom node based on id
var elDom = Ext.getDom('elId');
// gets dom node based on the dom node
var elDom1 = Ext.getDom(elDom);

// If we don't know if we are working with an
// Ext.Element or a dom node use Ext.getDom
function(el){
    var dom = Ext.getDom(el);
    // do something with the dom node
}
</code></pre>

<p>接著來看在 extjs 對 DOM 進行封裝後的物件帶來什麼樣的功能 ...</p>

<h2>Ext.Element</h2>

<p>Ext.Element 是Ext的底層API，主要是由Ext或自定義組件來進行呼叫。並且將 DOM 進行封裝，使用方式如下：</p>

<pre><code>// by id
var el = Ext.get("my-div");

// by DOM element reference
var el = Ext.get(myDivElement);
</code></pre>

<p>可以看到只要透過 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext-method-getDom">Ext.get</a> 取得的物件，將會作為 Ext.Element 回傳。</p>

<p>透過 extjs 將 DOM 封裝為 Ext.Element，通過其操作 DOM 來實現頁面的效果顯示，可以方便做到若要把頁面中的某一個節點移到其它位置，要給某一個節點添加陰影效果，要隱藏或顯示某一個節點等，可以很輕易的執行相關的動畫特效，主要是因為在 Ext.Element 中包含了專門處理特效的類別：<a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Fx">Ext.Fx</a>，而以往都需要通過幾句javascript才能完成。舉例來說，下面這段取得 DOM 的語法：</p>

<pre><code>var el = Ext.get("my-div");

// no animation
el.setWidth(100);
</code></pre>

<p>只是單純的將寬度設為 100 ，若要有類似特效的效果，很簡單：</p>

<pre><code>// default animation
el.setWidth(100, true);
</code></pre>

<p>修改為上面的程式碼即可，詳細可參照 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Element">API-Ext.Element</a></p>

<p>因此，Ext在DOM的基礎上，創建了Ext.Element，可以使用Element來包裝任何DOM，Element 對像中添加了一系列快捷、簡便的實用方法。其中對於事件上的使用，不像 Component 中的事件是屬於 Ext events，在 Element 中的事件是屬於 browser events，在 extjs 官方 api 中有提到：</p>

<blockquote><p>Note that the events documented in this class are not Ext events, they encapsulate browser events.</p></blockquote>

<p>其中因為是屬於原生的 browser events 所以不是所有的事件在較舊的 browser 中都有支援，不過如果是屬於 Ext events 的範圍則都有支援。如官方所言：</p>

<blockquote><p>Some older browsers may not support the full range of events. Which events are supported is beyond the control of ExtJs.</p></blockquote>

<p>extjs 實作了 Element 來對原生的 dom 操作進行了強化，並且透過 Element 的使用可以不必擔心跨瀏覽器的相容性，解決前端令人困擾的問題，但對於終端用戶來說，僅僅有Element是不夠的，也因此 extjs 最強大的部份就是 ...</p>

<h2>Ext.Component</h2>

<p>假設我們需要在開發時要顯示一個表格、樹狀結構或者彈出一個視窗等，為了方便建立相關的元件，除了 Element 以外，Extjs 還建立了一系列的前端顯示元件 Component，我們在撰寫程式時，只要使用這些組件 Componet 即可實現相關數據展示及交互等，而 Component 是較高層次的抽象，每一個組件在渲染 render 的時候，都會依次通過 Element、DOM 來生成最終的頁面效果。</p>

<p>在Ext中，組件渲染以後可以通過訪問 Component 的 properties <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-el">api-el</a> 屬性來得到組件對應的 Element ，通過訪問 Element 的 dom 屬性可以得到其下面的 DOM 對象。</p>

<p>其中如果要取得某元件可以透過 Ext.getCmp 來得到，相關詳細說明可參考我的另一篇文章：<a href="http://smlsun.com/blog/2013/02/05/extjs-component/">Extjs: Component 的使用，找尋 Parent &amp; Child</a></p>

<p>而下面範例說明實際上的使用狀況：</p>

<pre><code>var view=new Ext.Viewport();                //創建了一個組件 Component 
view.el.setOpacity(.5);                         //調用 Element 的 setOpacity 方法
view.el.dom.innerHTML="Hello Ext";  //透過 Element 的 dom 屬性操作 DOM 對象
</code></pre>

<p>以及如何分別取得 dom、element 以及 component</p>

<pre><code>var win=new Ext.Window({id:"win1",title:"my window",width:200,height:200}); 
win .show(); 
var c=Ext.getCmp("win1");           //得到組件win 
var e=Ext.get("win1");              //根據id得到組件win相應的Element 
var dom=Ext .getDom("win1");    //得到id為win1的DOM節點
</code></pre>

<p>若要進一步了解 extjs 的 Class Diagram 可參考下列網址：<a href="http://d.hatena.ne.jp/Tommy1/searchdiary?word=%2A%5BExtJS%5D">Ext JS 3.0 - Class Diagram</a></p>

<h2>深入 extjs</h2>

<p>如果要想深入應用 Ext，那麼閱讀Ext項目的原始碼是必要的，該原始碼非常值的學習，一些 js 技巧，以及應該要避免的 js 陷阱都有考慮到，透過閱讀原始碼可以更加深刻的了解 javascript 的程式開發，其包含了很多精巧的 js 開發與設計模式。在使用Ext的過程中，需要 extend extjs 的元件作為自定義的元件時，如何實作有時就要從原始碼找答案。</p>

<p>當然 Ext 的原始碼是很龐大的，並不需要從頭開始看，建議可以從元件 Component.js、容器 Container.js 以及 Panel.js；而核心中的 Element.js 以及 Ext.js 等也是蠻重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs 3.x: 本地資料 PagingStore 的使用]]></title>
    <link href="http://smlsun.com/blog/2013/02/15/extjs-pagingstore/"/>
    <updated>2013-02-15T18:04:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/15/extjs-pagingstore</id>
    <content type="html"><![CDATA[<p>extjs 3.x 再原生的 PagingStore 只支援遠端 paging，也就是分頁處理必須交由遠端的 server，透過傳入起始頁數以及每頁顯示的筆數，這樣的結構上會造成對server request 次數大增，有些時候將所資料都載入前端，分散 server loading 是提高效能以及使用體驗的手段之一。</p>

<p>當然文章一開始有提到 extjs 3 原生未支援這樣處理的方式，好家在網路上的大神已經有幫我們開發出外掛，讓我們可以很方便去使用，該外掛相關說明以及下載地址：</p>

<p><a href="http://www.sencha.com/forum/showthread.php?71532-Ext.ux.data.PagingStore-v0.5">Ext.ux.data.PagingStore [v0.5]</a></p>

<p>使用是需要注意的重點：</p>

<ul>
<li>根據資料來源的不同會有不同的 store</li>
<li>在分頁 toolbar 的使用，記得也要使用 ux 的版本 <code>Ext.ux.PagingToolbar</code></li>
<li>可以使用 <code>Ext.data.MemoryProxy</code> 當畫面 render 完成後在進行 store.load</li>
</ul>


<p>最後提供一個已經寫好的小範例讓大家參考一下，希望可以讓需要的人快速上手囉！</p>

<iframe style="width: 100%; height: 500px" src="http://jsfiddle.net/smlsun/pw9EK/4/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: component 的使用，找尋 parent & child]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-component/"/>
    <updated>2013-02-05T14:47:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-component</id>
    <content type="html"><![CDATA[<p>了解 component 的運作將有助於在操作 extjs 時，能夠更靈活操作在一個頁面中各個元件的運作，有了 component 查詢父類以及子類的方法可以更方便存取各階層的元件，特別在 single page 的頁面設計下更顯重要，並且在前端程式架構與分工上我們將可以很輕易的將 view 與事件獨立開來，避免重覆設計元件，造成維護上的困擾。</p>

<p>下面將說明查詢父類以及子類的方式</p>

<h2><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component">component</a> hierarchy (階層)</h2>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.BoxComponent">Ext.BoxComponent</a></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Container">Ext.Container</a></li>
</ul>
</li>
</ul>


<h2>取得特定 component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext-method-getCmp">getCmp</a></li>
</ul>


<h2>取得 parent component</h2>

<p>因為 extjs 所有的元件皆繼承於 component，且 Ext.Container 擁有 component，故通常透過下列方式取得的 parent Component 都屬於 Ext.Container，雖然如此，parent 物件還是擁有當初創建 Component 的屬性或方法。</p>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-ownerCt">Component.ownerCt</a></p>

<p>  ownerCt 為 Component 的 properties，因此可直接取得，詳細可查找 extjs api</p></li>
</ul>


<p><code>javascript
parent = child.ownerCt;
</code></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentBy">findParentBy</a></li>
</ul>


<p>``` javascript   <br/>
var form=this.findParentBy(function(p) {
  //定義你要索引的 parent 的條件式，若回傳為 true 將會回傳該 container parent</p>

<pre><code>return p.getForm;
</code></pre>

<p>});
```</p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentByType">findParentByType</a> (  String/Class xtype ) : Container</li>
</ul>


<p>主要透過 findParentBy 實作，找出最接近且符合傳入 xtype</p>

<p>``` javascript</p>

<p>function (xtype) {
  return Ext.isFunction(xtype) ?</p>

<pre><code>this.findParentBy(function(p){
    return p.constructor === xtype;
}) :
this.findParentBy(function(p){
    return p.constructor.xtype === xtype;
});
</code></pre>

<p>}
```</p>

<h2>取得 child component</h2>

<ul>
<li>getComponent</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').getComponent('childPanel09');
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>find</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').find('id', 'childPanel09')[0]; // [0] because find returns array
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li><p>findBy</p>

<p>  使用方式同 findParentBy</p></li>
<li><p>findByType</p>

<p>  使用方式同 findParentByType</p></li>
</ul>


<p>父子都搞定了，再來就看你自己了～XD</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: events]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-events/"/>
    <updated>2013-02-05T10:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-events</id>
    <content type="html"><![CDATA[<p>資料來源: 次世代 Ajax 解決方案 EXTjs 開發實戰</p>

<p>作者:徐會生、何啟偉、康愛媛</p>

<h2>Extjs 事件</h2>

<p>ExtJs對事件的管理非常強大，主要定義在Ext.EventManager對象(單例模式)中。先看註冊事件監聽方式，ExtJs提供了幾種方式來註冊元素監聽函數</p>

<ul>
<li>透過 <code>Ext.EventManager.addListener/on</code> 函數來為指定元素的某種事件註冊監聽函數。例如：<code>Ext.EventManager.on('test1','click',clickMe,this);</code></li>
<li>透過ExtJs元素的on函數來為自身註冊某種事件的監聽處理函數。例如：
<code>Ext.get('test1').on('click', clickMe,this,{preventDefault:true});</code></li>
</ul>


<p>其中 options參數是事件配置項，各項說明如下：</p>

<ul>
<li>scope ：可指定執行上下文</li>
<li>delegate ：事件代理</li>
<li>stopEvent ：阻止冒泡和默認行為</li>
<li>preventDefault ：阻止默認行為</li>
<li>stopPropagation ：停止事件冒泡</li>
<li>normalized ：僅傳原生事件對象</li>
<li>delay ：延遲執行</li>
<li>single :僅執行一次</li>
<li>buffer ：延遲執行，多次時最後一次覆蓋前一次</li>
<li>target :指定在父元素上執行</li>
</ul>


<p>舉例來說，假如我要進行事件延遲處理，就可以使用 delay</p>

<p>``` javascript
Ext.onReady( function (){</p>

<pre><code>Ext.get( "btnAlert" ).on( "click" ,a, this ,{delay:2000});   
</code></pre>

<p>});
```</p>

<p>要知道更詳細的解說可以查看 extjs api: <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.EventManager-method-addListener">Ext.EventManager-method-addListener</a></p>

<h2>Extjs 之事件模型</h2>

<p>所有繼承自 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.util.Observable">Ext.util.observable</a> 類別的控制項皆可以支援事件。因此可對這些繼承自 Ext.util.observable 的物件定義事件，並為這些事件配置監聽器。當某個事件被觸發，Ext會自動呼叫對應的監聽器，此即為Ext之事件模型。</p>

<p>下面是個簡單的例子</p>

<h3>定義Person類別</h3>

<ul>
<li>此例定義了一個Person物件，擁有一個屬性 name。</li>
<li>使用 this.addEvent() 函式定義了 walk、eat與sleep三個自訂事件。</li>
<li>使用 Ext.extend() 讓Person物件繼承Ext.util.observable所有屬性。</li>
<li>並擴充一個新函數 info()，並設計info() 函式可傳回Person的資訊。</li>
</ul>


<p>``` javascript
Person = function(name){
  this.name = name;
  this.addEvents(“walk”,”eat”,”sleep”);
}</p>

<p>Ext.extend(Person, Ext.util.observable, {
  info: function(event) {</p>

<pre><code>return this.name + ‘is’ + event + ‘ing.’;
</code></pre>

<p>  }
});
```</p>

<h3>建立Person實體物件(instance)，並為其事件配置監聽器(listener)</h3>

<ul>
<li>on 為 addListener() 的簡寫型式。</li>
<li>on 函式第一個函數為事件名稱，第二個參數為事件發生時所執行的函數。</li>
</ul>


<p>``` javascript
var person = new Person(‘Lingo’);
person.on(‘walk’ , function() {</p>

<pre><code>Ext.Msg.alert(‘event’ , person.name + “is walking…”);
</code></pre>

<p>});
person.on(‘eat’, function(breakfast, lunch, supper){</p>

<pre><code>Ext.Msg.alert(‘event’, person.name + “want to eat” + breakfast + “and ”+ lunch + “and ” + supper + “.”);
</code></pre>

<p>});
person.on(‘sleep’, function(time) {</p>

<pre><code>Ext.Msg.alert(‘event’,person.name + “從” + time.format(“H”) + “點開始睡覺。”); 
</code></pre>

<p>})
```</p>

<h3>觸發事件</h3>

<ul>
<li>呼叫fireEvent() 即觸發函式，傳入一個事件名稱，其對應之監聽函式即會執行。</li>
<li>與 on() 相反，un() 為 removeListener() 函式的簡寫，用途為刪除某事件之對應函數。</li>
<li>另有一 purgeListeners() 函數，可將所有監聽器刪除。</li>
</ul>


<p>``` javascript
Ext.get(‘walk’).on(‘click’ , function{
  person.fireEvent(‘walk’);
});</p>

<p>Ext.get(‘eat’).on(‘click’, function(){
  person.fireEvent(‘eat’, ‘早餐’, ‘午餐’, ‘晚餐’);
});</p>

<p>Ext.get(‘sleep’).on(‘click’,function(){
  person.fireEvent(‘sleep’, new Date());
});
```</p>

<h2>瀏覽器事件</h2>

<ul>
<li>主要使用 Ext.EventManager, Ext.EventObject 與 Ext.lib.Event 對原生瀏覽器事件進行包裝。</li>
<li>HTML 瀏覽器事件屬於單一綁定，Ext框架則是對於同一個事件可以綁定至多個事件處理控制碼上。</li>
</ul>


<h3>原生 HTML</h3>

<p><code>javascript
var e=document.getElementById(“test”);
e.onclick=function(){alert(“handle1”)};
e.onclick=function(){alert(“hangle2”)};
</code></p>

<blockquote><p>按下 test後，只會顯示 handle2 提示框。</p></blockquote>

<h3>extjs</h3>

<p>``` javascript
Ext.onReady( function(){
  var test = Ext.get(‘test’);
  test.on(‘click’, function() {</p>

<pre><code>alert(“handle1”); 
</code></pre>

<p>  });</p>

<p>  test.on(‘click’, function(){</p>

<pre><code>alert(“handle2”);
</code></pre>

<p>  });
});
```</p>

<blockquote><p>按下 test 後，handle1 與 handle2 提示框皆會依序顯示。</p></blockquote>
]]></content>
  </entry>
  
</feed>
