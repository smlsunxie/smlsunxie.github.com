<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extjs | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/extjs/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-05-09T22:23:31+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[企業級開發框架：extjs 與 grails 的完美組合]]></title>
    <link href="http://smlsun.com/blog/2013/05/09/extjs-with-grails/"/>
    <updated>2013-05-09T21:44:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/05/09/extjs-with-grails</id>
    <content type="html"><![CDATA[<p>本篇的重點在於說明 extjs 作為 web 應用程式前端的 framework，如何與目前常用的 full stack framework 進行整合，在此將以 grails 為例，當然不只可以跟 grails 整合，其他像 RoR 或者 .net，甚至是 node.js 都可以作為 extjs 的後端服務提供者。</p>

<p>透過 grails 這樣的整合範例，希望可以讓讀者體會不只能夠快速開發，一旦應用程式大到一定程度，也可以很方便的維護，並且在開發流程中的循環都可以順暢的不停轉動。</p>

<hr />

<h2>前後端分工</h2>

<p>開發大型軟體，或是時程上較趕的時候最怕等來等去，在開發應用程式時，最需要確認的是資料庫的設計，一旦定義好之後，如何快速完成 model 並且將測試資料建立完成，以便進行測試，透過 grails 與 extjs 剛好可以完美的解決此問題，前幾篇介紹到的關於 extjs model 類別的使用，其概念與 grails 剛好一拍即合，同樣以之前 <a href="http://ithelp.ithome.com.tw/question/10120206">extjs mvc 為例</a> 裡面用到的 Item，batch，以及 itemImage，在 grails 中宣告如下：</p>

<p>``` groovy
package finder
class Item {</p>

<pre><code>    String name
    String title=""
    String description=""
    static hasMany=[itemImages:ItemImage]
</code></pre>

<p>}</p>

<p>package finder
class Batch {</p>

<pre><code>    String name
    static belongsTo =[item:Item]
</code></pre>

<p>}</p>

<p>package finder
class ItemImage {</p>

<pre><code>Item item
String name
</code></pre>

<p>}
```</p>

<p>grails 可以把它看做 java 中的 RoR，因此也有「約定優於配置」的特性，以往在傳統 java 對於 O/R mapping 這樣的技術，往往需要大量的 xml 定義，在 grails 只要將寫好的 model 放在 grails 下的 model 資料夾，而三個資料表定義就像上面的程式碼一樣，輕鬆簡單！不需要在對資料庫進行 table create，一旦 grails 啟動就會檢查資料庫是否有對應的資料表，判斷若是 develop mode 將會使用虛擬資料庫，在記憶體中就會建立好三個 table，不需要有實體就可以開始對你的應用程式開始進行測試，一旦開發完成，只要進行設定轉換為實體資料庫即可，接著在 grails 中有個類別 BootStrap 在這裡可以定義你要測試的初始資料，以便進行相關應用開發，如下：</p>

<p>``` groovy
import finder.*</p>

<p>class BootStrap {</p>

<p>  def init = { servletContext -></p>

<pre><code>    environments {
        development {
            def item1 = new Item(name:"item1").save(failOnError: true, flush: true)
            def batch1 = new Batch(name:"batch1",item:item1).save(failOnError: true, flush: true)
            def itemImage1 = new ItemImage(name:"itemImage1.jpg",item:item1).save(failOnError: true, flush: true)
        }
    }
</code></pre>

<p>  }
  def destroy = {
  }
}
```</p>

<p>一旦伺服器啟動就會執行在 BootStrap 中的程式碼，如果我們在此區塊撰寫新增資料的程式，每次啟動 grails 都會有新的資料可以進行測試，反覆測試的過程中將免去每次都要建立測試資料的麻煩，並且有預設的設定值也可以在此定義，資料準備好了，前後端就可以分開進行，接著來看如何快速定義好 extjs 與 grails 的溝通橋樑。</p>

<h2>以 RESTful 進行前後端溝通</h2>

<p>extjs 4 有個新的 proxy type：rest，一但定義為 rest proxy，在資料操作上將會根據你對前端資料的更新動作給予不同的 http method，如下：</p>

<ul>
<li>新增：POST</li>
<li>修改：UPDATE</li>
<li>刪除：DELETE</li>
<li>查詢：GET</li>
</ul>


<p>我們會用到另一個敏捷開發特性：Don’t Repeat Yourself(DRY)，在 Grails 有另一個設定檔 URLMappings 可以讓我們設定根據前端 request 的 http method 導入至特定後端 controller method，該檔案設定如下：</p>

<p>``` groovy
class UrlMappings {</p>

<pre><code>static mappings = {
    "/$controller/$action?/$id?"{
        constraints {
        }
    }
    "/rest/$controller/$id"{
        action = [GET: "show", PUT:"update", DELETE:"delete"]
        constraints {
        }
    }
    "/rest/$controller"{
        action = [GET:"listAll", POST: "create"]
        constraints {
        }
    }
    "/"(view:"/home/index")
    "500"(view:'/error')
}
</code></pre>

<p>}
```</p>

<p>可以看到在 URLMappings 的設定中：</p>

<p>``` groovy
"/rest/$controller/$id"{</p>

<pre><code>action = [GET: "show", PUT:"update", DELETE:"delete"]
constraints {
}
</code></pre>

<p>}</p>

<p>"/rest/$controller"{</p>

<pre><code>action = [GET:"listAll", POST: "create"]
constraints {
}
</code></pre>

<p>}
```</p>

<p>代表如果有傳入 id 則是上述的第一種 mapping 方式，根據 http method 的不同對應到不同的 controller 的 method；若沒有 id 則是第二種，實際代表的網址可能為 <code>http://localhost/rest/item/1</code> 或者 <code>http://localhost/rest/batch/</code>，就會根據 UrlMappings 的定義觸動在 controller 中的 method，範例如下：</p>

<p>``` groovy
package finder
import grails.converters.JSON
class ItemController {</p>

<pre><code>def listAll = {
    def items=Item.list()
    render (contentType: 'text/json') {
  [
            items: items,
            total: items.size()
        ]
    }
}

def show = { Long id -&gt;
    def item=Item.findById(id)
    render (contentType: 'text/json') {
  [
            item: item
        ]
    }

}

def create = {
    ...
}
def update = {
    ...
}
def delete={
    ...
}
</code></pre>

<p>}
```</p>

<p>剛剛提到對應的 controller method 就如同上面程式碼中的 listAll，show 等等，到這邊，後端的 server 算是已經準備好，可以開始進行測試，是否發現跟一般 java 比，簡潔很多，寫起來還有點像 javascript？實際上 Grails 骨子裡還是 java，執行時會編譯為 class，因為搭配了 java 中的動態語言 groovy 才有這樣的效果，且並沒有捨棄 java 多年累積廣大的第三方套件，當你需要時皆可以引入，不需重新造輪。</p>

<h2>extjs：store.sync() - 簡化更新</h2>

<p>後端 server 快速準備好後，在 extjs 更加簡化呼叫更新資料請求的程序，在 store 的類別提供一個 method 為 sync()，作用在於一旦 store 載入後，只要對 store 執行 insert，remove，insert 確定更新完成後，一旦執行就會對後端 server 發出 http request，所以，你不用勞你費心，extjs 已幫你完成相關程序，範例 controller 如下：</p>

<p>``` javascript
Ext.define('Frontend.controller.common.Standard', {</p>

<pre><code>extend: 'Ext.app.Controller',

doRead: function() {
    this.store.load();
},
doCreate: function() {
    this.store.insert(0, this.model);
},
doDelete:function(){
    var selection = this.grid.getSelectionModel().getSelection()[0];
    if (selection) {
        this.store.remove(selection);
    }
},
doUpdate: function() {
        //更新對 store 的異動
    this.store.sync({
        success : function(){
            console.log("success");
            Ext.Msg.alert('Status', '更新成功');
        },
        failure : function(response, options){
            console.log("failure");
            Ext.Msg.alert('Status', '更新失敗');
        }  
    });
}
</code></pre>

<p>});
```</p>

<h2>快速前端元件建立</h2>

<p>即使用像 grails 這樣的 full stack framework 對於前端介面還是需要自己重頭刻起，若是搭配 sencha architect 將可以補齊這方面的不足：快速建立前端介面，並且為了敏捷快速的開發，一旦介面拉好，就可以儘快確認需求與操作介面，所完成的介面就可以開始著手開發，介面的變動也可以在 architect 中完成，還記得之前有介紹過在 extjs 中的每個小元件都可以作為類別存在，並且 controller 若以每個元件為目標設計，透過混和（mixins）的特性組合 controller 就可以快速調整介面的呈現與互動。</p>

<h2>extjs develop mode &amp; test</h2>

<p>一個好的框架，必須還要能夠方便測試，在 extjs 中可以很方便的指定某個類別作為初始的 view，可以參考上一篇 <a href="http://ithelp.ithome.com.tw/question/10120289">Sencha Architect 快速開發 extjs</a>中「方便進行測試與開發」的介紹，即使你沒有用 Architect，也可以自行定義，別忘了利用這樣的特性對開發中的介面進行測試。</p>

<h2>extjs production mode</h2>

<p>應用程式開發到一個階段，就會從 develop 進階到所謂的 production mode，其目的就是要盡量加速資源的載入，在前端的世界就是要將所有的 js 檔最小化，並且合為一個 js 檔，雖然 extjs 有動態載入，實際在 production 模式這樣是很耗效能的，如果我們要自行利用 minify 工具進行壓縮，在 extjs 中各類別的相依性就無法顧慮到，並且可能因為組成檔案順序不正確造成衝突，所幸，extjs 也注意到這樣的問題，提供 Sencha cmd 來處理 minify js 的程序，並且可以搭配 Architect 使用，步驟如下：</p>

<ol>
<li><p>利用 sencha cmd 產生 extjs 專案</p>

<pre><code> sencha -sdk {extjs_home} generate app {projectName} {projectLocation}
</code></pre></li>
<li><p>修改 sencha 設定檔：修改 {projectLocation}/.sencha/app/sencha.cfg，加入下面兩行 ：</p>

<pre><code> app.dir={projectLocation}
 app.classpath=${app.dir}/app.js,${app.dir}/app
</code></pre></li>
<li><p>進到 {projectLocation} 執行 production 編譯</p>

<pre><code> sencha app build production
</code></pre></li>
</ol>


<p>如此一來就會將執行完的結果產出在 {projectLocation}/build 底下，就是這們簡單！</p>

<h2>resource 控管</h2>

<p>extjs 所完成的介面在 grails 中將作為 resource 存在，且對 grails 而言屬於靜態檔案，因此可以進行快取來加速資源載入，而在 grails 有一設定檔 ApplicationResources 專門在定義要載入的 resource，在設定時必須考慮 develop 與 production 的不同，設定方式如下:</p>

<p>``` groovy
import org.codehaus.groovy.grails.web.context.ServletContextHolder as SCH
modules = {</p>

<pre><code>// develop mode 使用
extjs4_dev {
    defaultBundle 'finder_dev'

    resource url: 'extjs4_dev/resources/ext-theme-neptune/ext-theme-neptune-all.css'        
    resource url: 'ext/ext-all.js'
    resource url: 'ext/ext-theme-neptune.js'
    resource url: 'app.js'

    getFilesForPath('app').each {
        resource url: it
    }
}   
// production mode 使用
</code></pre>

<p>  extjs4 {</p>

<pre><code>    defaultBundle 'finder'
    resource url: 'extjs4/resources/finder_extjs-all.css'
    resource url: 'extjs4/all-classes.js'
}   
</code></pre>

<p>}</p>

<p>// 載入 path 參數底下所有的檔案作為 resource
def getFilesForPath(path) {</p>

<pre><code>def webFileCachePaths = []
def servletContext = SCH.getServletContext()

if(!servletContext) return webFileCachePaths
def realPath = servletContext.getRealPath('/')
def appDir = new File("$realPath/$path")
appDir.eachFileRecurse {File file -&gt;
    if (file.isDirectory() || file.isHidden()) return
    webFileCachePaths &lt;&lt; file.path.replace(realPath, '')
}
webFileCachePaths
</code></pre>

<p>}
```
經由這樣的設定，grails 會自動將 block 中所定義的 js 檔自動合為單一 js 檔，接著我們只要在 grails 中特有的 gsp 加入下列判斷：</p>

<p>```
&lt;g:if env='development'></p>

<pre><code>&lt;r:require modules="extjs4_dev"/&gt;
</code></pre>

<p>&lt;/g:if>
&lt;g:else></p>

<pre><code>&lt;r:require modules="extjs4"/&gt;
</code></pre>

<p>&lt;/g:else>
```
就會根據不同的開發模式載入不同的 resource 組合。</p>

<h2>打完收工，期待下次在相會！</h2>

<p>這是個想法，目前我們也正在投入這樣的應用，預期可以帶來不一樣的開發方式，軟體開發方式不停的在進步，也許還有很多團隊還在使用老舊的方法，這樣的組合，除了可以敏捷快速的開發，利用 extjs 所提供的方便性，相信可以帶來效率的提升，特別是前端的物件建立與操作，表單式的應用程式非常適合，筆者也曾在企業進行 extjs 的教育訓練，歡迎有興趣的讀者可以互相切磋。</p>

<p>系列文章到此告一段落，期待下次在與大家分享！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用 Sencha Architect 快速開發 extjs]]></title>
    <link href="http://smlsun.com/blog/2013/05/09/extjs4-sencha-architect-intro/"/>
    <updated>2013-05-09T10:45:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/05/09/extjs4-sencha-architect-intro</id>
    <content type="html"><![CDATA[<p>Sencha Architect，基於 extjs 的可視化開發工具，如果你目前主要的前端開發框架選擇的是 extjs，那你就不能錯過，Sencha Architect 提供的功能比妳想像的多更多，他不只是使用 extjs 的元件來進行 mockup 而已，妳可以利用他完成所有妳想到的功能，幫你節省很多除錯的時間，如果有過開發 extjs 的經驗純文字開發除錯是非常費時的。</p>

<p>早在 Sencha Architect 前一代 designer 時，筆者就有使用過，這一版在徹底大改版後的物件化設計，好用許多，非常值得一試。</p>

<hr />

<p>使用 Sencha Architect 來開發 extjs 的好處，除了他會幫你檢查一些常見的問題，比如 id 與 class 名稱的重覆與錯誤，對於前端很最重要的畫面呈現，經由他所組合出來的畫面，幾乎就是實際運行的結果，網路上對於一些基礎的使用技巧已有詳細介紹，這邊就不贅述，在開始閱讀下面的內容時妳可以先參考下面連結，先對基本操作有些概念。</p>

<p><a href="http://ithelp.ithome.com.tw/question/10091599">使用 Sencha Architect 2 快速搞定 Web App 的 UI</a></p>

<p>假設妳已經讀過上面連結，最好還能夠實際操作看看，相信有些概念後會更容易吸收。</p>

<p>並且可以先了解一下 <a href="http://ithelp.ithome.com.tw/question/10120206">extjs 中的 mvc 還有物件導向的特性</a>，在 Sencha Architect 中，妳將可以很輕易做到，一些基礎的使用方式筆者就不贅述，本篇將介紹進階使用技巧。</p>

<h2>物件導向：元件重覆使用</h2>

<p>拜 extjs 所賜，讓前端純 javascript 的開發也能用物件導向的方式來進行，我們可以將一些常用的元件重覆使用，一旦我們需要調整時，只要調整基礎元件，就可以同時影響所有有使用到的元件，參考下圖：</p>

<p><img src="https://lh6.googleusercontent.com/-r6dKsDsjny8/UYoJTVdWbrI/AAAAAAAALq4/ZcWWw55l13s/w295-h351-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-02+%25E4%25B8%258A%25E5%258D%258811.13.42.jpg" alt="image" /></p>

<p>可以看到 saveBtn 同時出現在三個自定元件，在 Sencha Architect 裡如果是屬於 link 元件將會用藍色線連結，讓你可以一目了然，一旦改了最原始的 saveBtn 將會連動其他的元件，如下圖</p>

<p><img src="https://lh3.googleusercontent.com/-CRJZ6KfxDso/UYoJT3XjC2I/AAAAAAAALrE/e1G0YHxzXfw/w297-h487-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-02+%25E4%25B8%258A%25E5%258D%258811.21.51.jpg" alt="image" /></p>

<p>物件導向的特性讓你將共用與特有的屬性能夠有效率的管理，在妳需要時組合成妳想的介面。</p>

<h2>toolbox</h2>

<p>除了利用類別的方式，我們也可將我們自定義的元件加入 toolbox 以利重覆使用，使用上如下圖：</p>

<p><img src="https://lh3.googleusercontent.com/-iZyb8gySybw/UYoJUgko80I/AAAAAAAALrI/SmexsiI1Ty4/w529-h270-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-02+%25E4%25B8%258A%25E5%258D%258811.26.43.jpg" alt="image" /></p>

<p>一旦此元件屬於標準元件妳可以將其加入 toolbox 加以管理，需要使用時，拖拉至妳需要放置的位置即可。</p>

<h2>model 資料表令 Store 連結真實資料</h2>

<p>除了在一開始基礎操作連結中有說明到可以定義 model 之外，妳也可以連真實的資料來進行呈現。</p>

<p>一旦連結成功，在 store 旁，將會有一個黑色眼睛，表示資料已連結，實際在 Architect 裡，也會將資料真實呈現。</p>

<p><img src="https://lh4.googleusercontent.com/-zqKWz11Vqx8/UYoJVkvPa1I/AAAAAAAALrY/Jte5iEJvZkE/w602-h229-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-02+%25E4%25B8%258A%25E5%258D%258811.38.22.jpg" alt="image" /></p>

<p>如此一來，除了 grid 的欄位顯示，我們也可以透過 Architect 知道實際呈現時資料內容是否正確。</p>

<h2>進階屬性定義</h2>

<p>在 Sencha Architect 裡的每個元件皆有預設的屬性可以讓您方便的進行定義，但實際上妳可能會找不到妳要的屬性，沒關係，妳也可以自定，如下圖：</p>

<p><img src="https://lh5.googleusercontent.com/-5ghG4LSpW68/UYoJVMRl7UI/AAAAAAAALrQ/jaTUxgolSD4/w301-h291-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-02+%25E4%25B8%258A%25E5%258D%258811.31.02.jpg" alt="image" /></p>

<p>一旦妳輸入的屬性不存在，妳可以點選 add，就會加入下方的屬性，並且可選取該屬性的資料型態，根據妳所選的資料屬性 Architect 會幫你進行資料型態檢查。</p>

<h2>介面 layout 定義</h2>

<p>這部份是筆者認為非常棒的功能，在使用 extjs 時，如果是利用純文字編輯，對於元件的佈置很難直覺的想像，透過 Architect 可以很方便完成我們希望的介面呈現，舉個例子：</p>

<p><img src="https://lh3.googleusercontent.com/-2x6Rf3kw21Y/UYo606h83XI/AAAAAAAALrw/NkggFPdeqkY/w436-h126-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25886.55.06.jpg" alt="image" /></p>

<p>上圖是在<a href="http://ithelp.ithome.com.tw/question/10120206">上一篇 MVC</a> 文章中，用到的 ItemGrid 可以看到若是單獨看此元件的話，其實是縮在一起的，但如果我們要確認實際放入 ItemEditor tab 中的狀況就可以透過 Architect：</p>

<p><img src="https://lh5.googleusercontent.com/-5zPQbOzLYk4/UYo61v204lI/AAAAAAAALr4/sO0SnYOfakE/w603-h178-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25886.58.44.jpg" alt="image" /></p>

<p>圖中可以看到使用的 layout 為 vbox，結構上如下圖：</p>

<p><img src="https://lh6.googleusercontent.com/-ZSGWB1J0R-0/UYo62Dv1_mI/AAAAAAAALsA/i6lYouhtbQU/w225-h110-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25887.03.16.jpg" alt="image" /></p>

<p>由 listToolbar 以及 itemGrid 組成，在這邊希望能夠將下方得 itemGrid 填滿全部，如下圖，實際呈現上 grid 並沒有填滿：</p>

<p><img src="https://lh5.googleusercontent.com/-yKNyzxCP6Cw/UYo77sp5o9I/AAAAAAAALsc/uTg9bFi3XD0/w603-h148-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25887.49.25.jpg" alt="image" /></p>

<p>那是因為沒有設置 Flex，所以我們將 grid 的 Flex 設為 1，可以看到，顯示上已全部填滿可以顯示的區域:</p>

<p><img src="https://lh6.googleusercontent.com/-WCIo746bzlQ/UYo63BQT0mI/AAAAAAAALsI/yTewTe8q944/w603-h468-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25887.07.28.jpg" alt="image" /></p>

<p>此時如果我們要看其他 layout 情形將可以很方便完成，以往直覺上我們可能會使用 fit，但是結果可能不是我們所預期，透過這樣的工具我們可以很快速完成佈置，專注在重要的互動事件與邏輯上，最後附上若同樣的介面，使用 fit 會是怎樣的情形：</p>

<p><img src="https://lh4.googleusercontent.com/-vwy-OwEHBtM/UYo63hR1XHI/AAAAAAAALsQ/I5k90ZYFgLU/w603-h462-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25887.11.17.jpg" alt="image" /></p>

<p>只有 toolbar 被填滿，grid 不見了，所以，妳可以省下寶貴生命快速確認介面的呈現。</p>

<h2>方便進行測試與開發</h2>

<p>在 extjs 的 application.js 中可以定義一個屬性為 <code>autoCreateViewport</code>，一旦定義此屬性為 true，extjs 會在 view 底下自動顯示檔案為 Viewport.js 定義的內容，而在 Architect 中每一個 view 類別都可以標示為 Initial View，如下圖中的 Mark as Initial View：</p>

<p><img src="https://lh3.googleusercontent.com/-uGliPz2sLMU/UYo60ILc2WI/AAAAAAAALro/RM6EnhQDGjk/w259-h249-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258B%25E5%258D%25886.45.47.jpg" alt="image" /></p>

<p>這樣有什麼好處？在開發 extjs 時，如果應用程式是需要進行登入的，每次更新程式後要進行測試，免不了需要經過登入步驟以及點選功能來開啟需要測試的功能，次數少還好，如果反覆測試的情況下，著實浪費時間，更甚者，假設應用程式是多人開發，可能在執行某應用程式前，需要經過別的應用程式，但如果前面步驟尚未完成，就無法進行測試，這時候這樣的功能就很方便，因為我們可以針對單一元件進行單元功能開發與測試，大大降低功能間的相依性，一旦各自元件開發完成，就可以進行組合最終在進行整合功能測試即可！</p>

<p>Sencha Architect 確實有他存在及使用的價值，筆者使用純文字開發 extjs 多年，遇到很多介面上的問題，並且依靠經驗除過不少 bug，但是都沒有使用 Sencha Architect 來的快及準確，話雖這麼說，IDE 也沒有辦法幫你寫出「對」的程式，強烈建議使用 Sencha Architect 務必先了解 extjs 的原理，如此才能夠讓你駕馭 Architect，就像開車一樣，沒有先了解如何開車就上路，開的不好錯怪車子，還有可能出車禍喔。</p>

<p>經由這四篇文章，希望可以帶給讀者 extjs 從入門到進階的知識，以及如何透過 IDE 快速建立應用網站外觀，並且確認，減少不必要的反覆測試。</p>

<p>最後的第五天，要為大家說明在實際的開發環境，extjs 如何與後端應用程式進行互動，在軟體開發技術上越來越方便的現在，更提倡敏捷快速的開發，善用 extjs MVC 架構作為 view 層，來與後端的 MC(?)搭配，將以 java 中 Ruby on Rails：Grails 來為大家介紹，企業級開發框架：extjs 與 grails 的完美組合。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs mvc 架構：繼承與模組重覆使用]]></title>
    <link href="http://smlsun.com/blog/2013/05/08/extjs-oo/"/>
    <updated>2013-05-08T08:42:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/05/08/extjs-oo</id>
    <content type="html"><![CDATA[<p>兩篇對 extjs 的基本介紹後，總算要進入主菜了，也就是在 extjs 中的物件導向 MVC 架構，物件導向的觀念，在網路上或書上都可以找到相關資料，用不用的好就是一個人的功力，此篇文章中，將透過幾個例子讓讀者了解 extjs 的物件導向操作。</p>

<hr />

<p><a href="http://www.showframework.com/2012/07/extjs-mvc-architecture/">ExtJS 4 MVC架構講解</a></p>

<p>引用上述文章的開頭：</p>

<blockquote><p>大規模客戶端應用通常不好實現不好組織也不好維護，因為功能和人力的不斷增加，這些應用的規模很快就會超出掌控能力，ExtJS 4 帶來了一個新的應用架構，不但可以組織代碼，還可以減少實現的內容 新的應用架構遵照一個類 MVC 的模式，模型（Models）和控制器（Controllers）首次被引入。業界有很 ​​多種 MVC 架構，基本大同小異，ExtJS 4的定義如下：</p>

<ul>
<li>Model: 資料的集合，例如 User 帶有 username 和 password 的資料，model 知道如何持久化自己的數據，並且可以和其他 model 關聯，model 跟 ExtJS 3中 的 Record 有點像（區別是，Record 只是單純的扁平結構，而 Model 可以 nest ），通常都用在 Store 中去展示 grid 和其他組件的資料</li>
<li>View: 用於界面展示– grid, tree, panel都是view</li>
<li>Controllers: 安放所有使你的 app 正確工作的代碼的位置，具體一點應該是所有動作，例如如何渲染 view，如何初始化 model，和 app 的其他邏輯</li>
</ul>
</blockquote>

<p>在我早先的令一篇文章中也有引用到，<a href="http://smlsun.com/blog/2013/03/21/extjs4-mvc/">Extjs4: Mvc 使用簡介與範例介紹</a>，在該篇文章中說明到較多的實作細節，本篇專注於 mvc 結構與特性，如果讀者有興趣也可以參考閱讀，在開始之前，先提一下兩個重要的物件導向觀念：</p>

<ul>
<li>單一責任原則（single responsibility principle:SRP）：當一個類別需要修改時應該只有一個理由。</li>
<li>關注點分離（separation of conserns:SoC）：把應用程式功能分解成數個不重疊的模組。</li>
</ul>


<p>遵循這兩個原則，最重要的好處就是要能夠重覆使類別，令單一類別不要過於複雜，如此一來程式在設計上就可以比較接近組合積木，一個個零件完成後，可以根據不同的狀況組合。</p>

<p>為了能夠設計出可以重覆使用的類別，將針對三種不同的課題，繼承，混和以及 model 關連建立，就讓我們從 mvc 中的 model 資料模型開始。</p>

<h2>model - 關連建立</h2>

<p>假設我們設計一個應用程式，其資料模型如下：</p>

<p><img src="https://lh5.googleusercontent.com/-0q850mONEZ0/UYnJDk0otZI/AAAAAAAALqA/sIPHKvaPjZs/w603-h115-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%25881.01.45.jpg" alt="image" /></p>

<p>可以看到有三個 table：item（品項），itemImage（品項圖片），batch（批號），其中 item 可以有多張圖片，批號屬於 item，根據這樣的描述，可以整理出兩個關係：</p>

<ul>
<li>item 可以有多張圖片：item hasMany itemImage</li>
<li>批號屬於 item：batch belongsTo item</li>
</ul>


<p>根據這樣的關係，我們可以利用 extjs 來建立對應的類別。</p>

<p>三個資料表的基本宣告程式碼如下：</p>

<p>``` javascript
//品項
Ext.define('finder_extjs.model.Item', {</p>

<pre><code>extend: 'Ext.data.Model',

fields: [
    {
        name: 'id'
    },
    {
        name: 'name'
    },
    {
        name: 'title'
    }
]
</code></pre>

<p>});</p>

<p>//圖片
Ext.define('finder_extjs.model.ItemImage', {</p>

<pre><code>extend: 'Ext.data.Model',

fields: [
    {
        name: 'id'
    },
    {
        mapping: 'item.id',
        name: 'item_id'
    }
]
</code></pre>

<p>});</p>

<p>//批號
Ext.define('finder_extjs.model.batch', {</p>

<pre><code>extend: 'Ext.data.Model',

fields: [
    {
        name: 'id'
    },
    {
        mapping: 'item.id',
        name: 'item_id'
    },
    {
        name: 'name'
    }
]
</code></pre>

<p>});
```</p>

<p>如此一來，三個資料表算是建立完成，但是彼此之間都是獨立沒有關係的，為此，我們需要要在加上關連的定義。</p>

<p>``` javascript
//item hasMany itemImage
Ext.define('finder_extjs.model.Item', {</p>

<pre><code>extend: 'Ext.data.Model',
//使用到的關連 model 務必引入  
uses: [
    'finder_extjs.model.ItemImage'
],  
...
hasMany: {
    associationKey: 'itemImages',
    model: 'finder_extjs.model.ItemImage',

    // 設定 foreignKey 將會作為查詢的 property name
    foreignKey: 'item_id',
    //跟據 name 將會產生對應的參照 function
    name: 'itemImages' 
}
</code></pre>

<p>});
```</p>

<p>多定義了關係一定要有用處，不然何必要花時間，實際在使用上我們可以：</p>

<p>``` javascript
//item hasMany itemImage</p>

<p>var item = new finder_extjs.model.Item({id:1});</p>

<p>// 一旦定義 hasMany extjs 將自動產生對應 name 的 function 回傳關連資料的 store 實體
//取得關連資料
item.itemImage().load();
```</p>

<p>在上面的程式碼中，如果你有定義 model 的連結方式，實際上將會透過 http request 向後端查詢資料，並且帶有參數為：<code>filter:[{"property":"item_id","value":1}]</code>，一旦結果回傳，會根據 model 的 fields mapping 相關的欄位資料，如此一來當你有存取相關的資料時，就可以很方便的使用，免去撰寫重覆 ajax request 的步驟，接著來看 belongsTo 的例子。</p>

<p>``` javascript
//batch belongsTo item
Ext.define('finder_extjs.model.batch', {</p>

<pre><code>extend: 'Ext.data.Model',
uses: [
    'finder_extjs.model.Item'
],
...
belongsTo: {
    model: 'finder_extjs.model.Item',
    // 根據定義的 getterName 產生 function 來取得所屬 model 的參照
    getterName: 'getItem'  
}
</code></pre>

<p>});</p>

<p>var batch = new finder_extjs.model.Batch({id:1});</p>

<p>// 根據 getterName 的設定將自動產生對應 name 的 function 回傳關連資料的 record
// 取得關連資料
batch.getItem();
```</p>

<p>同樣的一旦呼叫了 <code>batch.getItem();</code> 也會向後端請求取得資料，如此一來，只要資料結構與關係定義好，往後在使用時，就可以很方便的取得，甚至妳也可以這樣使用：<code>batch.getItem().itemImages().load()</code></p>

<p>在資料串查上，可以從關關連快速完成資料的取得，再來我們就來看看，mvc 中的 view 如何在 extjs 物件化，並且能夠重覆使用。</p>

<h2>view - 繼承與連結</h2>

<p>單純的建立 view 的元件這邊不多做說明，主要還是針對 extjs 物件導向特性來做說明，假設我們需要建立如同下圖的畫面：</p>

<p><img src="https://lh5.googleusercontent.com/-6uDmCuSY5vE/UYnJFCExBMI/AAAAAAAALqQ/wy7BAOoryi4/w603-h323-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%258810.02.13.jpg" alt="image" /></p>

<p>在圖片中可以看到主要是由 form 以及 grid 所組成，有個共同的地方，就是兩者皆有同樣的 toolbar，因此在設計的時候，我們可以將 toolbar 獨立成一個類別，在兩個地方引入，如下圖：</p>

<p><img src="https://lh5.googleusercontent.com/-1IPFyWhNQRg/UYnJEl2Tk7I/AAAAAAAALqM/gry2WHV0LhU/w242-h393-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%25889.49.54.jpg" alt="image" /></p>

<p>上圖的結構是利用 sencha Architect 所呈現的，可以看到元件 StdEditorToolbar 就是獨立的類別，藍色線代表作為連結使用在另外兩個自定元件裡面，如此一來相同的元件與 ID 定義，就不需要重覆多次，在索引時也較一致性，如果讀者有看我上一篇 <a href="http://smlsun.com/blog/2013/02/19/extjs-component/">ID 與 itemId 的不同</a>，就會知道這樣是可行的，而因為 extjs 4 在這次多了 controller 的類別，所以我們的 view 層都是單純的介面元件，沒有特殊的邏輯，所以可以重覆使用，除此之外，我們也可以交由多人協助完成相關的元件，最後在將他們組合成最終要呈現的畫面，參考上一張圖片的樹狀結構，最終的呈現將由三個主要元件組成，ItemGrid，ItemViewer，ItemEdtor，步驟上就可以先將 ItemGrid，ItemViewer 完成以後，ItemEdtor 作為 tabpanel 連結 ItemGrid，ItemViewer 完成整個畫面，如下圖：</p>

<p><img src="https://lh5.googleusercontent.com/-XKtk5cWSqsk/UYnJFiXo1CI/AAAAAAAALqY/qYUtCJjeKrM/w603-h285-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%258810.02.55.jpg" alt="image" /></p>

<p><img src="https://lh4.googleusercontent.com/-_P3Jgg56zw4/UYnJGQ8iwFI/AAAAAAAALqg/sHmkQdYRubo/w603-h397-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%258810.03.16.jpg" alt="image" /></p>

<p>就是如此簡單愉快，上面所完成的自定元件都使用到了在物件導向中繼承的特性，基本上都是經由繼承 extjs 的元件加以客製化，當然自定元件同樣也可以作為別人的父類別，端看如何設計。mvc 中的前兩項完成了，接著我們就來看最後一個 C，controller 的部份。</p>

<h2>Controller - 混和</h2>

<p>作為 view 與 model 的溝通橋樑，與操作 view 中元件的互動，Controller 扮演的角色是很重要的，他必須要很方便存取以及定義欲操作的元件，extjs 在這邊也確實做到了，還記得上一篇最提到的關於 extjs 如何查詢 component，當你在撰寫 Controller 將會大量使用到，延續上一節的 view 中三個元件：ItemGrid，ItemViewer，ItemEdtor，來進行說明。</p>

<ul>
<li>ItemGrid：如果是作為 grid 單獨存在，將只會有讀取資料的功能，因此在 controller 中，我們只需要定義 read 的功能實作。</li>
<li>ItemViewer：作為 Viewer 本身只是個空殼，需要由外部傳入資料後進行資料呈現，因此我們需要定義得是 display 的功能</li>
<li>ItemEditor：組合了 ItemGrid 與 ItemViewer，兩個介面，也因此實作的內容就為兩者之間的互動，一旦點選 ItemGrid 中的資料，就將其作為 ItemViewer 的資料來源進行呈現，因此我們要實作的是 readItem。</li>
</ul>


<p>大致上解釋一下設計概念後，粗糙一點我們可以把上面三個功能都定義在 ItemEditor，但如果 ItemGrid 以及 ItemViewer 會作為獨立功能，或者組合到不同的介面，這時候我們就必須要寫兩個同樣的 function，這不是個好辦法，因此我們可以利用 extjs 提供的另一個特性：混和(mixsins)，在系列文章的<a href="http://ithelp.ithome.com.tw/question/10120091">第一篇</a>有提到，一旦我們個別定義好 ItemGrid，ItemViewer 的邏輯函式，我們可以將他混和入 ItemEditor 如此一來就可以各自專注各自的責任，除了可以組合在一起，也可以各自獨立運作，是不是很美好呢！接著我們就來看範例程式碼與結構：</p>

<p><img src="https://lh4.googleusercontent.com/--nSzi3U1WrQ/UYnJG2grGnI/AAAAAAAALqo/SA-TwLD_zg4/w215-h289-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-05-08+%25E4%25B8%258A%25E5%258D%258810.48.04.jpg" alt="image" /></p>

<p>參考上圖，可以看到我們為了三個介面分別做了三個 controller，就如同前面提到的三點，個別設定了三個函數，在這邊我就不詳述各個 controller 的實作，直接來看 ItemEditorController：</p>

<p>``` javascript
Ext.define('finder_extjs.controller.ItemEditorController', {</p>

<pre><code>extend: 'Ext.app.Controller',

// 混和： ItemViewerController 以及 ItemGridController
mixins: {
    itemViewerCtrl: 'finder_extjs.controller.ItemViewerController',
    ItemGridCtrl: 'finder_extjs.controller.ItemGridController'
},

// 目標 views
views: [
    'ItemEditor'
],

// 定義操作對象
refs: [
    {
        ref: 'itemViewer',
        selector: 'itemviewer'
    },
    {
        ref: 'itemGrid',
        selector: 'itemgrid'
    },
    {
        ref: 'itemEditor',
        selector: 'itemeditor'
    }
],

init: function(application) {
        // event binding
    this.control({
        'itemeditor button[itemId=readBtn]':{
            click:this.doRead
        },
        //一旦 grid 中的資料被雙擊，執行 readItem
        'itemeditor grid[itemId=itemGrid]':{
            itemdblclick:this.readItem
        }
    });
},

// 將傳入的目標資料，作為顯示的資料來源進行呈現
readItem: function(obj, record, item, index, e, eOpts) {
    this.getItemEditor().setActiveTab(this.getItemViewer().up());

    //屬於 itemViewerController 所定義的函數
    this.doDisplay(record);
}
</code></pre>

<p>});
```</p>

<p>這篇文章中，說明了 MVC 的運作，以及個別利用了物件導向開發中的資料關連，繼承以及混和；當然不只這些，還有很多奇巧淫技等著學習並熟練，程式的世界是學也學不完，希望藉由這樣的說明，能夠讓讀者有個概念，在使用 extjs 這樣的物件導向設計時可以有個參考，文章進行到這裡，對於 extjs 的概念與使用，相信應該有些了解，不過如果有實際經歷過 extjs 開發的讀者應該可以體會，因為他是這樣的複雜，在除錯上有時並不是那麼容易，特別是物件導向式的開發方式會有很多獨立的類別，如何能夠快速開發減少不必要的錯誤，就要善用工具啦！幸好官方提供了 sencha architect，可以幫助我們減少開發中的錯誤，並且快速完成介面的建立，最後要強調的是，ide 只是輔助，請在熟練基礎過後在服用，不然...嘿嘿～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs4: mvc 使用簡介與範例介紹]]></title>
    <link href="http://smlsun.com/blog/2013/03/21/extjs4-mvc/"/>
    <updated>2013-03-21T08:42:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/03/21/extjs4-mvc</id>
    <content type="html"><![CDATA[<p><a href="http://www.showframework.com/2012/07/extjs-mvc-architecture/">ExtJS 4 MVC架構講解</a></p>

<p>引用上述文章的開頭：</p>

<blockquote><p>大規模客戶端應用通常不好實現不好組織也不好維護，因為功能和人力的不斷增加，這些應用的規模很快就會超出掌控能力，ExtJS 4帶來了一個新的應用架構，不但可以組織代碼，還可以減少實現的內容 新的應用架構遵照一個類MVC的模式，模型（Models）和控制器（Controllers）首次被引入。業界有很 ​​多種MVC架構，基本大同小異，ExtJS 4的定義如下：</p>

<ul>
<li>Model: 資料的集合，例如 User 帶有 username 和 password 的資料，model 知道如何持久化自己的數據，並且可以和其他 model 關聯，model 跟 ExtJS 3中 的 Record 有點像（區別是，Record 只是單純的扁平結構，而 Model 可以 nest ），通常都用在 Store 中去展示 grid 和其他組件的資料</li>
<li>View: 用於界面展示– grid, tree, panel都是view</li>
<li>Controllers: 安放所有使你的 app 正確工作的代碼的位置，具體一點應該是所有動作，例如如何渲染 view，如何初始化 model，和 app 的其他邏輯</li>
</ul>
</blockquote>

<p>對於 extjs 4 的 mvc 有點概念後，我們可以實際來看例子進一步了解運作的方式。</p>

<h2>Application</h2>

<p>每個 ExtJS 4 的應用都從一個 Application 開始，這個實例包含應用的全域配置（例應用的名字），這個實例也負責維護對全部模型、視圖、控制器的引用的維護，還有一個 <code>launch</code> 函數，會在所有加載項加載完成之後呼叫。首先需要選擇一個全域命名空間，所有 ExtJS 4 應用都需要有一個全域命名空間，以讓所有應用中的 class 安放到其中</p>

<p>```javascript</p>

<pre><code>Ext.Loader.setConfig({
    enabled: true,
    //disableCaching: true //強制關閉 cache
});

Ext.application({
    name: 'Frontend',   //app folder 別名為 Frontend
    appFolder: 'app',   //檔案 root 存放位置
    controllers: [

    'SYS.SYS001',   //使用者登入
    'SYS.SYS002',   //主畫面
    'MN.MNM001',     //群組權限維護
    'US.USM002'    //使用者群組維護
    ],
    launch: function() {
        Ext.create('Ext.container.Viewport', {
            id: 'mainVP',
            layout: 'fit',
            items: [{
                xtype: 'sys001loginform',
                url: 'http://localhost:8080/agricloud/user/login.json'
            }]
        });
    }
});
</code></pre>

<p>```</p>

<h2>Model</h2>

<p>定義來源資料的 mapping 以及資料型態</p>

<p>```javascript</p>

<pre><code>// app/model/MN/MNM001/MenuGroup.js
Ext.define('Frontend.model.MN.MNM001.MenuGroup', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'menuId', type: 'string'},
        {name: 'menuDes',  type: 'string'},
        {name: 'userGroupId',  type: 'string'},
        {name: 'userGroupDes',  type: 'string'}
    ]
});
</code></pre>

<p>```</p>

<h2>Store</h2>

<p>設定資料獲取的來源，以及取得資料的方式，載入上一節的 model <code>Frontend.model.MN.MNM001.MenuGroup</code>。一旦資料讀取成功，將會依據 model 進行資料 mapping 作為 view 層的資料呈現來源。</p>

<p>```javascript</p>

<pre><code>// app.store.MN.MNM001.Store.js
Ext.define('Frontend.store.MN.MNM001.Store' ,{
    model:'Frontend.model.MN.MNM001.MenuGroup', 
    extend: 'Ext.data.Store',
    alias : 'widget.mnm001store',
    autoLoad: true,
    proxy: {
        type: 'rest',   // 使用 rest 來與後端 server 溝通
        url: 'http://localhost:8080/agricloud/rest/menuGroup/',
        reader: {
            type: 'json',
            root: 'items'
        },
        writer: {
            type: 'json'
        },
        afterRequest:function(request,success){
            var operation = request.operation;
            var response = operation.response; 
            if(success){
            }else{}
        }
    },
    listeners: {
        // 讀取完資料後，進行 load 
        write: function(store, operation) {
            store.load();
        }
    }
});
</code></pre>

<p>```</p>

<h2>Controller</h2>

<p>用於整合 model 的資料讓 view 可以使用，並且定義 view 各個事件要執行的內容，如此一來 view 將可以被獨立設計，一旦 view 被使用於別的功能也不會有衝突的事件定義。在使用上 Controller 也可以進行繼承，下面的 parent Controller 範例實作一些常用的事件，因為對於 controller 而言，所載入的各個 store 都視為 controller 的屬性，故只要繼承至 parent Controller 都有給定要求的變數內容，所定義的事件將會運作正常</p>

<h3>parent Controller</h3>

<p>```javascript</p>

<pre><code>/**
 * std Controller
 */
Ext.define('Frontend.controller.common.Standard', {
    extend: 'Ext.app.Controller',
    execute: function(params) {
        var tab = Ext.getCmp('mainTab');
        tab.add({
            id: params.id,
            title: params.title,
            closable: true,
            layout:'fit',
            items: {
                xtype: params.tabXtype
            }
        });
    },
    doRead: function() {
        console.log("doRead")
        this.store.load();
    },
    doCreate: function() {
        this.store.insert(0, this.model);
    },
    doDelete:function(){
        var selection = this.grid.getSelectionModel().getSelection()[0];
        if (selection) {
            this.store.remove(selection);
        }
    },
    doUpdate: function() {
        this.store.sync({
            success : function(){
                console.log("success");
                Ext.Msg.alert('Status', '更新成功');
            },
            failure : function(response, options){
                console.log("failure");
                Ext.Msg.alert('Status', '更新失敗');
            }  
        });
    },
    onGridSelection:function(selModel, selections,eOpts){
        this.selections=selections;
        this.selModel=selModel;

        //必須利用refs 取得實體介面已 render的物件
        this.deleteButton.setDisabled(selections.length === 0);

    },
    onPanelRendered: function() {
        //將載入的 view 指定為此 controller 的屬性
        this.grid=this.getGridPanel();
        this.deleteButton=this.getDeleteButton();
    }
});
</code></pre>

<p>```</p>

<h3>main controller</h3>

<p>繼承於上一節的 parent Controller，在主要使用的 controller 需透過 <code>views</code>、<code>stores</code>、<code>models</code> 將對應的 mvc 載入，以及透過 refs 將需要控制的 Component 找出來並且給予別名，如此一來，我們在之後 <code>init</code> 事件定義元件的動作時可以方便的參照相關的元件。</p>

<p>```javascript</p>

<pre><code>// app.controller.MN.MNM001.js
/**
 * 功能群組維護
 */
Ext.define('Frontend.controller.MN.MNM001', {
    extend: 'Frontend.controller.common.Standard',
    views: [
        'MN.MNM001.Panel'
    ], 

    refs: [{
        ref: 'deleteButton',
        selector: 'mnm001panel commonbuttondelete'
    },{
        ref: 'gridPanel',
        selector: 'mnm001panel'
    },{
        ref: 'combobox',
        selector: 'mnm001combobox'
    }],
    init: function() {

        定義各個元件所要執行的事件以及相關的函數
        this.control({
            'mnm001panel commonbuttoncreate': {
                click: this.doCreate
            },
            'mnm001panel commonbuttondelete': {
                click: this.doDelete
            },
            'mnm001panel commonbuttonupdate': {
                click: this.doUpdate
            },
            'mnm001panel commonbuttonread': {
                click: this.doRead
            },
            'mnm001combobox': {
                select:this.comboboxSelect
            },
            'mnm001panel': {
                selectionchange: this.onGridSelection,
                render: this.onPanelRendered
            }
        })
        //ref 的使用對象為 Conpoment
        //store 的取得直接用 this 
        //在 view 所組成的 compoment 中有使用到的 store 皆可以在 controllr 中存取

        this.store=this.getStore("MN.MNM001.Store");

    },
    execute: function(params) {
        //定義此 contoller 所使用之屬性，controller 一旦被執行此事件將會最先被執行
        params.tabXtype='mnm001panel';
       //結果將透過下列程式呼叫繼承來的 controller 之 execute
        this.callParent(arguments);
    },
    comboboxSelect: function( combo, records, eOpts ) {
        this.selections[0].set('userGroupDes',records[0].get('description') );
    }
});
</code></pre>

<p>```</p>

<h2>View</h2>

<p>view 的使用依賴於 controller 有載入的內容，在這邊只作為介面的呈現，不進行事件的定義，除非該事件為通用的事件。</p>

<h3>Combobox</h3>

<p>使用的第一個 store <code>US.USM002.Store</code></p>

<p>```javascript</p>

<pre><code>Ext.define('Frontend.view.MN.MNM001.Combobox', {
    extend: 'Ext.form.ComboBox',
    alias : 'widget.mnm001combobox',
    id:'mnm001combobox',
    itemId:'mnm001combobox',
    store: 'US.USM002.Store',
    queryMode: 'local',
    displayField: 'userGroupId',
    valueField: 'userGroupId'
});
</code></pre>

<p>```</p>

<h3>Panel</h3>

<p>使用的第二個 store <code>MN.MNM001.Store</code>，其中 <code>Frontend.view.common.gridpanel.standard</code> 是自定義通用的 gridpanel，假設你有第二個類似的功能就可以繼承他，只要修改 columns 的定義即可，並且載入額外套件。</p>

<p>```javascript</p>

<pre><code>Ext.define('Frontend.view.MN.MNM001.Panel' ,{
    extend: 'Frontend.view.common.gridpanel.standard',
    alias : 'widget.mnm001panel',
    requires:['Frontend.view.MN.MNM001.Combobox'],
    columns: [
        { 
            header: 'menuId',  
            dataIndex: 'menuId', 
            flex: 1,
            field: {
                xtype: 'textfield'
            }
        },
        { 
            header: 'menuDes', 
            dataIndex: 'menuDes'
        },
        { 
            header: 'userGroupId', 
            dataIndex: 'userGroupId',
            field: {
                xtype: 'mnm001combobox'
            }
        },
        { 
            header: 'userGroupDes', 
            dataIndex: 'userGroupDes' 
        }
    ],
    plugins: [{
            ptype:'rowediting'
    }],
    store:'MN.MNM001.Store'
});
</code></pre>

<p>```</p>

<h2>執行結果</h2>

<h3>功能一</h3>

<p><img src="https://lh5.googleusercontent.com/-lx8V6k3xoO8/UUp-XqNiMnI/AAAAAAAALmk/19RA9GS5zrE/s615/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-03-21+%E4%B8%8A%E5%8D%8811.25.17.jpg" alt="image" /></p>

<h3>功能二</h3>

<p><img src="https://lh4.googleusercontent.com/-HjzcF7nh4y0/UUp-YUkVjUI/AAAAAAAALms/sls8kHck6LI/s614/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-03-21+%E4%B8%8A%E5%8D%8811.25.28.jpg" alt="image" /></p>

<p>可以看到兩個功能外框是類似的，差別在欄位的不同，其中共用的部分：</p>

<ul>
<li>功能二的 grid 與功能一的 userGroupId 的 combobox store 為同一個 <code>US.USM002.Store</code></li>
<li>兩個功能之 panal 皆繼承於 <code>Frontend.view.common.gridpanel.standard</code></li>
<li>controller 也繼承於 <code>Frontend.controller.common.Standard</code></li>
</ul>


<p>透過 extjs 的模組化功能，我們可以很輕易的將重覆的程式碼進行利用，在 mvc 三個維度也可以很方便進行分工，只要各個元件的 id 索引定義清楚，幾乎可以獨立開發，剩下的就是最後的整合運作需要一起 debug，extjs 在前端 mvc 的架構卻實作的蠻漂亮的，有興趣可以參考一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: tree 的建立與使用]]></title>
    <link href="http://smlsun.com/blog/2013/02/19/extjs-tree/"/>
    <updated>2013-02-19T18:40:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/19/extjs-tree</id>
    <content type="html"><![CDATA[<p>資料來源：</p>

<ul>
<li><a href="http://blog.yslifes.com/archives/738">範例Tree元件的使用Ext.tree.TreePanel</a></li>
<li><a href="http://nano-chicken.blogspot.tw/2009/08/extjs-exttreetreepanel_2847.html">extjs - Ext.tree.TreePanel 簡介</a></li>
</ul>


<p>ExtJS的TreePanel樹是繼承Ext.Panel，所以它可以算是一個Container，不過它也是算是一個ExtJS的Component，給於TreeNode來完成樹狀結果，可以應用在選單或是分類等地方。</p>

<p>這裡將介紹兩種 tree 的建立方式：</p>

<h1>利用物件來產生 tree</h1>

<pre><code>Ext.onReady( function() {

    var root = new Ext.tree.TreeNode( {
        text : '根'
    });

    var node1Child1 = new Ext.tree.TreeNode( {
        text : '個人資料維護',
        leaf : 'true'// 是否為末結果,樹葉
    });
    var node1Child2 = new Ext.tree.TreeNode( {
        text : '密碼變更',
        leaf : 'true'// 是否為末結果,樹葉
    });

    var node1 = new Ext.tree.TreeNode( {
        text : '個人資料'
    });
    node1.appendChild(node1Child1);
    node1.appendChild(node1Child2);

    root.appendChild(node1);

    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : root

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>利用 script 來產生 tree 透過 AsyncTreeNode</h2>

<p>若是用此方法需要使用 <code>AsyncTreeNode</code>，此外你的 children 也可以掛載 json Object 需要注意的是組成 tree 所需要的 config 都需要有才能正確產生，以及 <code>AsyncTreeNode</code> 的特性，如果節點一次都沒有打開過，若想要經由 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild</a>來取得參照是沒辦法的，因為是 Async (非同步)，所以未開啟其節點尚未實體化。</p>

<pre><code>Ext.onReady( function() {
    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : new Ext.tree.AsyncTreeNode( {
            text : '根',

            children : [ {
                text : '個人資料',
                children : [ {
                    text : '個人資料維護',
                    leaf : true
                }, {
                    text : '密碼變更',
                    leaf : true
                } ]
            }, {
                text : '客戶資料',
                children : [ {
                    text : '客戶基本資料查詢維護',
                    leaf : true
                }, {
                    text : '客戶基本資料列印',
                    leaf : true
                } ]
            }]
        })

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>讀取 json 資料來源產生 tree</h2>

<p>假設遠端的 json 資料來源：</p>

<pre><code>[{
    id: 1,
    text: 'A leaf Node',
    leaf: true
},{
    id: 2,
    text: 'A folder Node',
    children: [{
        id: 3,
        text: 'A child Node',
        leaf: true
    }]
}]
</code></pre>

<p>leaf 屬性會在 load 的時候，判斷是否要在遞迴產生子節點。而原本的 Ext.tree.TreeNode 並不支援 Ajax，所以也要改成 Ext.tree.AsyncTreeNode，程式碼如下：</p>

<pre><code>Ext.onReady(function() {
    var root = new Ext.tree.AsyncTreeNode({text: 'root'});
    var tree = new Ext.tree.TreePanel({
        el: 't',
        width: 150,
        autoHeight: true,
        root: root,
        loader: new Ext.tree.TreeLoader({dataUrl: 'tree.json'})
    });
    tree.render();
});
</code></pre>

<p>與上面的例子差別在多了使用了 Ext.tree.TreeLoader。</p>

<h2>讀取 xml 資料來源產生 tree</h2>

<p>除了 json 結構讀取外，在 extjs 的 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-loader.html">官方 sample</a> 有資料來源為 xml 的範例。</p>

<p>其中使用 extjs 延伸套件 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/ux/XmlTreeLoader.js">Ext.ux.tree.XmlTreeLoader</a>，使用上必須先自行定義 component extend Ext.ux.tree.XmlTreeLoader 並且實作 processAttributes，使用上無法定義 maping 的方式，他會把所有的 xml tag 跑過一變，必須在 tag 中的 Attribute 能有識別的方式，其中若是 tag 裡的內容預設會塞入 innerText 參數。</p>

<ul>
<li><a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-data.xml">xml 資料來源</a></li>
</ul>


<h2>tree 的操作與參照</h2>

<p>上面介紹了各種產生 tree 的方式，這邊要介紹一下如何透過 extjs 提供的函數來操作相關的節點，幾個重要的函數：</p>

<ul>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.tree.TreePanel-method-expandPath">expandPath( path, [attr], [callback] )</a></p>

<p>  預設的 path 是根據 id 來作為目錄結構的敘述，[attr] 可以改變目錄索引的屬性。</p></li>
<li><p>selectPath( path, [attr], [callback] )</p>

<p>  使用方式同上，不同的是會執行 expandPath 在做 selectPath</p></li>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild( attribute, value, [deep] )</a></p>

<p>  用來查詢特定的節點，其中若未設置 deep ＝ tree 將只搜尋使用此函數之物件的下一層，另外在上面有提到，如果是使用 AsyncTreeNode 尚未開啟節點前是找不到的。</p></li>
</ul>


<p>其他請參照 API，以下有實際使用飯例：</p>

<pre><code>Ext.onReady( function() {
  var viewport = new Ext.tree.TreePanel( {
    title : "系統相關",
    width : 200,
    height : 500,
    rootVisible : true,//root結點顯不顯示
    root : new Ext.tree.AsyncTreeNode( {
      text : '根',
      id:'r',

      children : [ {
        text : '個人資料',
        id:'c1',
        children : [ {
            text : '個人資料維護',
            id:'c1c1',
            leaf : true

        }, {
            text : '密碼變更',
            myid:'c1c2',
            leaf : true
        } ]
      }, {
        text : '客戶資料',
        id:'c2',
        children : [ {
            text : '客戶基本資料查詢維護',
            leaf : true,
            id:'c2c1'
        }, {
            text : '客戶基本資料列印',
            leaf : true,
            id:'c2c2'
        } ]
      } ]
    })

  });

  viewport.render('toolbar');
  viewport.doLayout();

  var btn=new Ext.Button({
    renderTo:"btn",
    id:'test',
    text:'test',
    handler:function(){

        // selectPath 可以做到 expand 之後在進行 select
      viewport.selectPath('/r/c2/c2c1');

      // 選取另一個節點需注意的是若 c1c1 此節點未被開啟，結果會為 undifine
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 一旦開啟過節點，再次 findChild 就會取得實體。
      viewport.expandPath('/r/c1/c1c1');
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 除了 id 之外，我們也可以用別的屬性來做搜尋
      viewport.root.findChild( 'myid', 'c1c2', true ).select();
    }
  });

});
</code></pre>

<p>說明都在程式註解中，這邊就不再多做說明，以下是實際範例運行的結果：</p>

<iframe style="width: 100%; height: 600px" src="http://jsfiddle.net/smlsun/xyvJX/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>



]]></content>
  </entry>
  
</feed>
