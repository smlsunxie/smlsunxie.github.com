<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extjs | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/extjs/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-17T20:07:00+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs 3.x: 本地資料 PagingStore 的使用]]></title>
    <link href="http://smlsun.com/blog/2013/02/15/extjs-pagingstore/"/>
    <updated>2013-02-15T18:04:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/15/extjs-pagingstore</id>
    <content type="html"><![CDATA[<p>extjs 3.x 再原生的 PagingStore 只支援遠端 paging，也就是分頁處理必須交由遠端的 server，透過傳入起始頁數以及每頁顯示的筆數，這樣的結構上會造成對server request 次數大增，有些時候將所資料都載入前端，分散 server loading 是提高效能以及使用體驗的手段之一。</p>

<p>當然文章一開始有提到 extjs 3 原生未支援這樣處理的方式，好家在網路上的大神已經有幫我們開發出外掛，讓我們可以很方便去使用，該外掛相關說明以及下載地址：</p>

<p><a href="http://www.sencha.com/forum/showthread.php?71532-Ext.ux.data.PagingStore-v0.5">Ext.ux.data.PagingStore [v0.5]</a></p>

<p>使用是需要注意的重點：</p>

<ul>
<li>根據資料來源的不同會有不同的 store</li>
<li>在分頁 toolbar 的使用，記得也要使用 ux 的版本 <code>Ext.ux.PagingToolbar</code></li>
<li>可以使用 <code>Ext.data.MemoryProxy</code> 當畫面 render 完成後在進行 store.load</li>
</ul>


<p>最後提供一個已經寫好的小範例讓大家參考一下，希望可以讓需要的人快速上手囉！</p>

<iframe style="width: 100%; height: 500px" src="http://jsfiddle.net/smlsun/pw9EK/4/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: component 的使用，找尋 parent & child]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-component/"/>
    <updated>2013-02-05T14:47:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-component</id>
    <content type="html"><![CDATA[<p>了解 component 的運作將有助於在操作 extjs 時，能夠更靈活操作在一個頁面中各個元件的運作，有了 component 查詢父類以及子類的方法可以更方便存取各階層的元件，特別在 single page 的頁面設計下更顯重要，並且在前端程式架構與分工上我們將可以很輕易的將 view 與事件獨立開來，避免重覆設計元件，造成維護上的困擾。</p>

<p>下面將說明查詢父類以及子類的方式</p>

<h2><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component">component</a> hierarchy (階層)</h2>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.BoxComponent">Ext.BoxComponent</a></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Container">Ext.Container</a></li>
</ul>
</li>
</ul>


<h2>取得特定 component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext-method-getCmp">getCmp</a></li>
</ul>


<h2>取得 parent component</h2>

<p>因為 extjs 所有的元件皆繼承於 component，且 Ext.Container 擁有 component，故通常透過下列方式取得的 parent Component 都屬於 Ext.Container，雖然如此，parent 物件還是擁有當初創建 Component 的屬性或方法。</p>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-ownerCt">Component.ownerCt</a></p>

<p>  ownerCt 為 Component 的 properties，因此可直接取得，詳細可查找 extjs api</p></li>
</ul>


<p><code>javascript
parent = child.ownerCt;
</code></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentBy">findParentBy</a></li>
</ul>


<p>``` javascript   <br/>
var form=this.findParentBy(function(p) {
  //定義你要索引的 parent 的條件式，若回傳為 true 將會回傳該 container parent</p>

<pre><code>return p.getForm;
</code></pre>

<p>});
```</p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentByType">findParentByType</a> (  String/Class xtype ) : Container</li>
</ul>


<p>主要透過 findParentBy 實作，找出最接近且符合傳入 xtype</p>

<p>``` javascript</p>

<p>function (xtype) {
  return Ext.isFunction(xtype) ?</p>

<pre><code>this.findParentBy(function(p){
    return p.constructor === xtype;
}) :
this.findParentBy(function(p){
    return p.constructor.xtype === xtype;
});
</code></pre>

<p>}
```</p>

<h2>取得 child component</h2>

<ul>
<li>getComponent</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').getComponent('childPanel09');
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>find</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').find('id', 'childPanel09')[0]; // [0] because find returns array
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li><p>findBy</p>

<p>  使用方式同 findParentBy</p></li>
<li><p>findByType</p>

<p>  使用方式同 findParentByType</p></li>
</ul>


<p>父子都搞定了，再來就看你自己了～XD</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: events]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-events/"/>
    <updated>2013-02-05T10:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-events</id>
    <content type="html"><![CDATA[<p>資料來源: 次世代 Ajax 解決方案 EXTjs 開發實戰</p>

<p>作者:徐會生、何啟偉、康愛媛</p>

<h2>Extjs 事件</h2>

<p>ExtJs對事件的管理非常強大，主要定義在Ext.EventManager對象(單例模式)中。先看註冊事件監聽方式，ExtJs提供了幾種方式來註冊元素監聽函數</p>

<ul>
<li>透過 <code>Ext.EventManager.addListener/on</code> 函數來為指定元素的某種事件註冊監聽函數。例如：<code>Ext.EventManager.on('test1','click',clickMe,this);</code></li>
<li>透過ExtJs元素的on函數來為自身註冊某種事件的監聽處理函數。例如：
<code>Ext.get('test1').on('click', clickMe,this,{preventDefault:true});</code></li>
</ul>


<p>其中 options參數是事件配置項，各項說明如下：</p>

<ul>
<li>scope ：可指定執行上下文</li>
<li>delegate ：事件代理</li>
<li>stopEvent ：阻止冒泡和默認行為</li>
<li>preventDefault ：阻止默認行為</li>
<li>stopPropagation ：停止事件冒泡</li>
<li>normalized ：僅傳原生事件對象</li>
<li>delay ：延遲執行</li>
<li>single :僅執行一次</li>
<li>buffer ：延遲執行，多次時最後一次覆蓋前一次</li>
<li>target :指定在父元素上執行</li>
</ul>


<p>舉例來說，假如我要進行事件延遲處理，就可以使用 delay</p>

<p>``` javascript
Ext.onReady( function (){</p>

<pre><code>Ext.get( "btnAlert" ).on( "click" ,a, this ,{delay:2000});   
</code></pre>

<p>});
```</p>

<p>要知道更詳細的解說可以查看 extjs api: <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.EventManager-method-addListener">Ext.EventManager-method-addListener</a></p>

<h2>Extjs 之事件模型</h2>

<p>所有繼承自 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.util.Observable">Ext.util.observable</a> 類別的控制項皆可以支援事件。因此可對這些繼承自 Ext.util.observable 的物件定義事件，並為這些事件配置監聽器。當某個事件被觸發，Ext會自動呼叫對應的監聽器，此即為Ext之事件模型。</p>

<p>下面是個簡單的例子</p>

<h3>定義Person類別</h3>

<ul>
<li>此例定義了一個Person物件，擁有一個屬性 name。</li>
<li>使用 this.addEvent() 函式定義了 walk、eat與sleep三個自訂事件。</li>
<li>使用 Ext.extend() 讓Person物件繼承Ext.util.observable所有屬性。</li>
<li>並擴充一個新函數 info()，並設計info() 函式可傳回Person的資訊。</li>
</ul>


<p>``` javascript
Person = function(name){
  this.name = name;
  this.addEvents(“walk”,”eat”,”sleep”);
}</p>

<p>Ext.extend(Person, Ext.util.observable, {
  info: function(event) {</p>

<pre><code>return this.name + ‘is’ + event + ‘ing.’;
</code></pre>

<p>  }
});
```</p>

<h3>建立Person實體物件(instance)，並為其事件配置監聽器(listener)</h3>

<ul>
<li>on 為 addListener() 的簡寫型式。</li>
<li>on 函式第一個函數為事件名稱，第二個參數為事件發生時所執行的函數。</li>
</ul>


<p>``` javascript
var person = new Person(‘Lingo’);
person.on(‘walk’ , function() {</p>

<pre><code>Ext.Msg.alert(‘event’ , person.name + “is walking…”);
</code></pre>

<p>});
person.on(‘eat’, function(breakfast, lunch, supper){</p>

<pre><code>Ext.Msg.alert(‘event’, person.name + “want to eat” + breakfast + “and ”+ lunch + “and ” + supper + “.”);
</code></pre>

<p>});
person.on(‘sleep’, function(time) {</p>

<pre><code>Ext.Msg.alert(‘event’,person.name + “從” + time.format(“H”) + “點開始睡覺。”); 
</code></pre>

<p>})
```</p>

<h3>觸發事件</h3>

<ul>
<li>呼叫fireEvent() 即觸發函式，傳入一個事件名稱，其對應之監聽函式即會執行。</li>
<li>與 on() 相反，un() 為 removeListener() 函式的簡寫，用途為刪除某事件之對應函數。</li>
<li>另有一 purgeListeners() 函數，可將所有監聽器刪除。</li>
</ul>


<p>``` javascript
Ext.get(‘walk’).on(‘click’ , function{
  person.fireEvent(‘walk’);
});</p>

<p>Ext.get(‘eat’).on(‘click’, function(){
  person.fireEvent(‘eat’, ‘早餐’, ‘午餐’, ‘晚餐’);
});</p>

<p>Ext.get(‘sleep’).on(‘click’,function(){
  person.fireEvent(‘sleep’, new Date());
});
```</p>

<h2>瀏覽器事件</h2>

<ul>
<li>主要使用 Ext.EventManager, Ext.EventObject 與 Ext.lib.Event 對原生瀏覽器事件進行包裝。</li>
<li>HTML 瀏覽器事件屬於單一綁定，Ext框架則是對於同一個事件可以綁定至多個事件處理控制碼上。</li>
</ul>


<h3>原生 HTML</h3>

<p><code>javascript
var e=document.getElementById(“test”);
e.onclick=function(){alert(“handle1”)};
e.onclick=function(){alert(“hangle2”)};
</code></p>

<blockquote><p>按下 test後，只會顯示 handle2 提示框。</p></blockquote>

<h3>extjs</h3>

<p>``` javascript
Ext.onReady( function(){
  var test = Ext.get(‘test’);
  test.on(‘click’, function() {</p>

<pre><code>alert(“handle1”); 
</code></pre>

<p>  });</p>

<p>  test.on(‘click’, function(){</p>

<pre><code>alert(“handle2”);
</code></pre>

<p>  });
});
```</p>

<blockquote><p>按下 test 後，handle1 與 handle2 提示框皆會依序顯示。</p></blockquote>
]]></content>
  </entry>
  
</feed>
