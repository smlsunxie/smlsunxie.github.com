<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-28T21:05:29+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[javascript: 流程控制 - 並發(類多執行續)與等待(類循序程序)]]></title>
    <link href="http://smlsun.com/blog/2013/02/23/javascript-sync/"/>
    <updated>2013-02-23T13:50:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/23/javascript-sync</id>
    <content type="html"><![CDATA[<p>在開發網站應用程式時，假設有用到與後端的 server 透過 ajax 互動交換資料，為了確保當 ajax 執行完成後，能夠循序的執行之後的資料呈現，一般來說我們會使用 callback 來確保順序是正確的，不過 callback 一多程式是比較多層一點，對與我以往的經驗有是用過 DWR 提供的 setAsync(false) 來達到同樣的效果，不過該作法有個缺點，如果某個函數執行時間過長，會感覺好像整個瀏覽器都當掉一樣，因此我們需要更好的作法。</p>

<p>在找相關資料時，剛好有的不錯的參考介紹給大家：<a href="http://book.nodejs.tw/zh-tw/node_javascript.html#id1">JavaScript 與 NodeJS - 流程控制</a>，雖然該篇文章是以 NodeJS 為主，但實際上NodeJS 就是利用 javascript 來進行程式撰寫，所以概念上相當類似，其中關於流程控制章節，就是我們要參考的內容。</p>

<h2>並發與等待</h2>

<p>所謂的併發就是有點像多執行續，而等待就是等所有執行續都完成後在執行指定的函式，簡單來說假設你有 a, b, c 三個函式，其中你必須等待 a, b 兩個函式都執行完成後在執行 c 這個函式，最直覺的作法就是使用 callback 一個一個執行，但實際上如果一多的話程式會變得很難閱讀，所以換個方式來處理這樣的問題，我們來看一下下面的範例：</p>

<p>``` javascript</p>

<pre><code>var wait = function(callbacks, done) {
    console.log('wait start');
    var counter = callbacks.length;
    var results = [];

    var next = function(result) {//接收函數執行結果，並判斷是否結束執行
        //closure 
        results.push(result);
        if(--counter == 0) {
            done(results);//如果結束執行，就把所有執行結果傳給指定的callback處理
        }
    };

    for(var i = 0; i &lt; callbacks.length; i++) {//依次呼叫所有要執行的函數
        //每個 callback 皆呼叫 next 函式，一旦 counter 歸 0 則執行 done 函式。
        callbacks[i](next);
    }
    console.log('wait end');
}
</code></pre>

<p>```</p>

<p>上面的 wait 函式實作了多函數 callbacks 執行完後在執行 done 的函式，透過每個函數執行完後就將 counter 減一，檢查 counter 是否歸 0，而下面就是實際應用的範例：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            setTimeout(function(){
                // callback 呼叫 next 函數
                console.log('done a');
                var result = 500;
                next(result)
            },500);
        },
        function(next){
            setTimeout(function(){
                console.log('done b');
                var result = 1000;
                next(result)
            },1000);
        },
        function(next){
            setTimeout(function(){
                console.log('done c');
                var result = 1500;
                next(1500)
            },1500);
        }   
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        var ret = 0, i=0;
        for(; i&lt;results.length; i++) {
            ret += results[i];
        }
        console.log('done all. result: '+ret);
    }
);
</code></pre>

<p>```</p>

<p>如上面的例子，我們就可以很簡單的處理需要同步執行的狀況啦！</p>

<p>在舉個例子假設我們要使用 extjs 的 msg box 一旦確定完成後才執行後續程式，我們可以改寫成：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        },
        function(next){
            next(" hello!")
        }  
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        Ext.MessageBox.alert('Status', 'results id '+ results[0]+' and '+ results[1]);
    }
);
</code></pre>

<p>```</p>

<p>就是這麼簡單！而在進階一點如果我們需要連續兩次 confirm 該怎麼做？直覺上，如果應該會如此處理：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        },
        function(next){
             Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        }  
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        Ext.MessageBox.alert('Status', 'results id '+ results[0]+' and '+ results[1]);
    }
);
</code></pre>

<p>```</p>

<p>但是！實際上只會有一個 confirm 跳出來，因為是同時執行對於 ext 而言 Ext.MessageBox 是同一個物件，所以最後一個執行的會把前述的 confirm 蓋掉，因此就只會有一個 confirm，正確來說我們可以在  done 在執行一個 wait，如下：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        }
    ],

    function(resultsA){
        wait(
            [
                function(next){
                    Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
                }
            ],

            function(resultsB){
                Ext.MessageBox.alert('Status', 'results id '+ resultsA[0]+' and '+ resultsB[0]);
            }
        );
    }
);
</code></pre>

<p>```</p>

<p>如此一來，就可以正確擷取到兩次 confirm 的內容，基本上上述的函式在使用上必須注意，所謂的併發就是個函數之間不能有先後關係，只能與等待的函數有先後關係，透過上述的例子要操作相關的函數執行流程就不是問題了。</p>

<p>另外一個流程控制的議題，假設你有個連續的 ajax 請求需求，且必須照順序執行可參考下列文章：<a href="http://blog.darkthread.net/post-2012-09-05-sequential-ajax-with-jquery.aspx">以jQuery循序執行AJAX呼叫，並依結果決定是否繼續</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: tree 的建立與使用]]></title>
    <link href="http://smlsun.com/blog/2013/02/19/extjs-tree/"/>
    <updated>2013-02-19T18:40:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/19/extjs-tree</id>
    <content type="html"><![CDATA[<p>資料來源：</p>

<ul>
<li><a href="http://blog.yslifes.com/archives/738">範例Tree元件的使用Ext.tree.TreePanel</a></li>
<li><a href="http://nano-chicken.blogspot.tw/2009/08/extjs-exttreetreepanel_2847.html">extjs - Ext.tree.TreePanel 簡介</a></li>
</ul>


<p>ExtJS的TreePanel樹是繼承Ext.Panel，所以它可以算是一個Container，不過它也是算是一個ExtJS的Component，給於TreeNode來完成樹狀結果，可以應用在選單或是分類等地方。</p>

<p>這裡將介紹兩種 tree 的建立方式：</p>

<h1>利用物件來產生 tree</h1>

<pre><code>Ext.onReady( function() {

    var root = new Ext.tree.TreeNode( {
        text : '根'
    });

    var node1Child1 = new Ext.tree.TreeNode( {
        text : '個人資料維護',
        leaf : 'true'// 是否為末結果,樹葉
    });
    var node1Child2 = new Ext.tree.TreeNode( {
        text : '密碼變更',
        leaf : 'true'// 是否為末結果,樹葉
    });

    var node1 = new Ext.tree.TreeNode( {
        text : '個人資料'
    });
    node1.appendChild(node1Child1);
    node1.appendChild(node1Child2);

    root.appendChild(node1);

    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : root

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>利用 script 來產生 tree 透過 AsyncTreeNode</h2>

<p>若是用此方法需要使用 <code>AsyncTreeNode</code>，此外你的 children 也可以掛載 json Object 需要注意的是組成 tree 所需要的 config 都需要有才能正確產生，以及 <code>AsyncTreeNode</code> 的特性，如果節點一次都沒有打開過，若想要經由 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild</a>來取得參照是沒辦法的，因為是 Async (非同步)，所以未開啟其節點尚未實體化。</p>

<pre><code>Ext.onReady( function() {
    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : new Ext.tree.AsyncTreeNode( {
            text : '根',

            children : [ {
                text : '個人資料',
                children : [ {
                    text : '個人資料維護',
                    leaf : true
                }, {
                    text : '密碼變更',
                    leaf : true
                } ]
            }, {
                text : '客戶資料',
                children : [ {
                    text : '客戶基本資料查詢維護',
                    leaf : true
                }, {
                    text : '客戶基本資料列印',
                    leaf : true
                } ]
            }]
        })

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>讀取 json 資料來源產生 tree</h2>

<p>假設遠端的 json 資料來源：</p>

<pre><code>[{
    id: 1,
    text: 'A leaf Node',
    leaf: true
},{
    id: 2,
    text: 'A folder Node',
    children: [{
        id: 3,
        text: 'A child Node',
        leaf: true
    }]
}]
</code></pre>

<p>leaf 屬性會在 load 的時候，判斷是否要在遞迴產生子節點。而原本的 Ext.tree.TreeNode 並不支援 Ajax，所以也要改成 Ext.tree.AsyncTreeNode，程式碼如下：</p>

<pre><code>Ext.onReady(function() {
    var root = new Ext.tree.AsyncTreeNode({text: 'root'});
    var tree = new Ext.tree.TreePanel({
        el: 't',
        width: 150,
        autoHeight: true,
        root: root,
        loader: new Ext.tree.TreeLoader({dataUrl: 'tree.json'})
    });
    tree.render();
});
</code></pre>

<p>與上面的例子差別在多了使用了 Ext.tree.TreeLoader。</p>

<h2>讀取 xml 資料來源產生 tree</h2>

<p>除了 json 結構讀取外，在 extjs 的 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-loader.html">官方 sample</a> 有資料來源為 xml 的範例。</p>

<p>其中使用 extjs 延伸套件 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/ux/XmlTreeLoader.js">Ext.ux.tree.XmlTreeLoader</a>，使用上必須先自行定義 component extend Ext.ux.tree.XmlTreeLoader 並且實作 processAttributes，使用上無法定義 maping 的方式，他會把所有的 xml tag 跑過一變，必須在 tag 中的 Attribute 能有識別的方式，其中若是 tag 裡的內容預設會塞入 innerText 參數。</p>

<ul>
<li><a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-data.xml">xml 資料來源</a></li>
</ul>


<h2>tree 的操作與參照</h2>

<p>上面介紹了各種產生 tree 的方式，這邊要介紹一下如何透過 extjs 提供的函數來操作相關的節點，幾個重要的函數：</p>

<ul>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.tree.TreePanel-method-expandPath">expandPath( path, [attr], [callback] )</a></p>

<p>  預設的 path 是根據 id 來作為目錄結構的敘述，[attr] 可以改變目錄索引的屬性。</p></li>
<li><p>selectPath( path, [attr], [callback] )</p>

<p>  使用方式同上，不同的是會執行 expandPath 在做 selectPath</p></li>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild( attribute, value, [deep] )</a></p>

<p>  用來查詢特定的節點，其中若未設置 deep ＝ tree 將只搜尋使用此函數之物件的下一層，另外在上面有提到，如果是使用 AsyncTreeNode 尚未開啟節點前是找不到的。</p></li>
</ul>


<p>其他請參照 API，以下有實際使用飯例：</p>

<pre><code>Ext.onReady( function() {
  var viewport = new Ext.tree.TreePanel( {
    title : "系統相關",
    width : 200,
    height : 500,
    rootVisible : true,//root結點顯不顯示
    root : new Ext.tree.AsyncTreeNode( {
      text : '根',
      id:'r',

      children : [ {
        text : '個人資料',
        id:'c1',
        children : [ {
            text : '個人資料維護',
            id:'c1c1',
            leaf : true

        }, {
            text : '密碼變更',
            myid:'c1c2',
            leaf : true
        } ]
      }, {
        text : '客戶資料',
        id:'c2',
        children : [ {
            text : '客戶基本資料查詢維護',
            leaf : true,
            id:'c2c1'
        }, {
            text : '客戶基本資料列印',
            leaf : true,
            id:'c2c2'
        } ]
      } ]
    })

  });

  viewport.render('toolbar');
  viewport.doLayout();

  var btn=new Ext.Button({
    renderTo:"btn",
    id:'test',
    text:'test',
    handler:function(){

        // selectPath 可以做到 expand 之後在進行 select
      viewport.selectPath('/r/c2/c2c1');

      // 選取另一個節點需注意的是若 c1c1 此節點未被開啟，結果會為 undifine
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 一旦開啟過節點，再次 findChild 就會取得實體。
      viewport.expandPath('/r/c1/c1c1');
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 除了 id 之外，我們也可以用別的屬性來做搜尋
      viewport.root.findChild( 'myid', 'c1c2', true ).select();
    }
  });

});
</code></pre>

<p>說明都在程式註解中，這邊就不再多做說明，以下是實際範例運行的結果：</p>

<iframe style="width: 100%; height: 600px" src="http://jsfiddle.net/smlsun/xyvJX/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: component 的使用，找尋 parent & child，以及區別 id、itemid 以及 ref 的不同]]></title>
    <link href="http://smlsun.com/blog/2013/02/19/extjs-component/"/>
    <updated>2013-02-19T14:47:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/19/extjs-component</id>
    <content type="html"><![CDATA[<p>了解 component 的運作將有助於在操作 extjs 時，能夠更靈活操作在一個頁面中各個元件的運作，有了 component 查詢父類以及子類的方法可以更方便存取各階層的元件，特別在 single page 的頁面設計下更顯重要，並且在前端程式架構與分工上我們將可以很輕易的將 view 與事件獨立開來，避免重覆設計元件，造成維護上的困擾。</p>

<p>下面將說明查詢父類以及子類的方式</p>

<h2><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component">component</a> hierarchy (階層)</h2>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.BoxComponent">Ext.BoxComponent</a></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Container">Ext.Container</a></li>
</ul>
</li>
</ul>


<h2>取得特定 component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext-method-getCmp">getCmp</a></li>
</ul>


<h2>取得 parent component</h2>

<p>因為 extjs 所有的元件皆繼承於 component，且 Ext.Container 擁有 component，故通常透過下列方式取得的 parent Component 都屬於 Ext.Container，雖然如此，parent 物件還是擁有當初創建 Component 的屬性或方法。</p>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-ownerCt">Component.ownerCt</a></p>

<p>  ownerCt 為 Component 的 properties，因此可直接取得，詳細可查找 extjs api</p></li>
</ul>


<p><code>javascript
parent = child.ownerCt;
</code></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentBy">findParentBy</a></li>
</ul>


<p>``` javascript   <br/>
var form=this.findParentBy(function(p) {
  //定義你要索引的 parent 的條件式，若回傳為 true 將會回傳該 container parent</p>

<pre><code>return p.getForm;
</code></pre>

<p>});
```</p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentByType">findParentByType</a> (  String/Class xtype ) : Container</li>
</ul>


<p>主要透過 findParentBy 實作，找出最接近且符合傳入 xtype</p>

<p>``` javascript</p>

<p>function (xtype) {
  return Ext.isFunction(xtype) ?</p>

<pre><code>this.findParentBy(function(p){
    return p.constructor === xtype;
}) :
this.findParentBy(function(p){
    return p.constructor.xtype === xtype;
});
</code></pre>

<p>}
```</p>

<h2>取得 child component</h2>

<ul>
<li>getComponent</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').getComponent('childPanel09');
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>find</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').find('id', 'childPanel09')[0]; // [0] because find returns array
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li><p>findBy</p>

<p>  使用方式同 findParentBy</p></li>
<li><p>findByType</p>

<p>  使用方式同 findParentByType</p></li>
</ul>


<h2>id 與 itemid 的不同</h2>

<p>從官方的 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-id">Ext.Component-cfg-id</a> 以及 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-itemId">Ext.Component-cfg-itemId</a> 的說明可以看到文件內容記載，為了避免翻譯上的落差，使用中英文對照：</p>

<h3>id</h3>

<p>節錄比較重要的部分，全文請參考官方 API</p>

<p>id 是作為 component 的 唯一識別，如果沒有設置 id 將會自動產生 id。</p>

<blockquote><p>The unique id of this component (defaults to an auto-assigned id).</p></blockquote>

<p>必須注意的是 id 會作為 html 中 element 的 id，一旦該物件已經被 rendered。</p>

<blockquote><p>Note that this id will also be used as the element id for the containing HTML element that is rendered to the page for this component.</p></blockquote>

<p>如果你有需要改變 component 的 css 就可以透過 id 來進行操作，如果也需要改變 component 底下的 子元件也必須使用 id 來操作。</p>

<blockquote><p>This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to select sub-elements using this component's id as the parent.</p></blockquote>

<p>官方文件說明的很清楚，我就不再補述了。接著我們在來看 itemid 的說明。</p>

<h3>itemid</h3>

<p>itemid 可以作為參照 component 的替代方案</p>

<blockquote><p>An itemId can be used as an alternative way to get a reference to a component when no object reference is available.</p></blockquote>

<p>其中：</p>

<ul>
<li>id 可用於 Ext.getCmp</li>
<li>itemid 用於 Ext.Container.getComponent</li>
</ul>


<p>區別兩者不同，並且善用能夠取得設定該 config 相關的元件</p>

<blockquote><p>Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.</p></blockquote>

<p>一旦 itemid 設置於 container 底下的任何物件 (MixedCollection)，則 itemId 他的範圍 (Scope) 將只限於 container 並且是區域性的。</p>

<blockquote><p>Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container</p></blockquote>

<p>最後為了避免淺在衝突，若是使用 Ext.ComponentMgr 必須要有唯一的 id 可進行識別</p>

<blockquote><p>avoiding potential conflicts with Ext.ComponentMgr which requires a unique id.</p></blockquote>

<p>從上面的敘述中可以看出一些使用上需注意的地方</p>

<ol>
<li>若你要取得相關的 Component 若是屬於 container 請設置 id</li>
<li>若是只屬於某個 container 底下的元件，請設置 itemId；某些情況下當然你也可以連同 id 一起設置，比如需要改變 css style，除此之外 itmeid 還是優先的選擇</li>
<li>getCmp 以及 getComponent 是不一樣的，使用上必須注意，必須搭配 id 以及 itemid 使用</li>
</ol>


<p>如此一來 id 與 itemid 就會有從屬關係，非必要不需定義 id，也不會造成在定義 id 時需要編碼避免重覆，而因為 itemid 是屬於某個 id 底下的，所以即使 itemid 重覆，也可以利用唯一的 id 利用 Ext.getCmp 取得參照後，在接著使用 getComponent 取得所屬 itemId 的參照。</p>

<p>實際的使用參考官方範例：</p>

<pre><code>var c = new Ext.Panel({ //
    height: 300,
    renderTo: document.body,
    layout: 'auto',
    items: [
        {
            itemId: 'p1',
            title: 'Panel 1',
            height: 150
        },
       {
        itemId: 'p2',
            title: 'Panel 2',
            height: 150
        }
    ]
})
p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
p2 = p1.ownerCt.getComponent('p2'); // reference via a sibling
</code></pre>

<p>除了上述 id 以及 itemid 可用於索引元件取得參照之外，我們還可以使用以下方法</p>

<h2>ref</h2>

<p>使用 ref 可以更加方便得取得 container 底下的 Component，連 getComponent 都可以免了。</p>

<p>參考官方文件 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-ref">Ext.Component-cfg-ref</a></p>

<p>ref 是使用路徑的語法，該路徑相關於 Component 的 ownerCt，ownerCt 所參照的是該物件的所屬的 Container 也就是他的上層父元件</p>

<blockquote><p>A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named reference to this Component.</p></blockquote>

<p>從上面的敘述有個概念後，來看實例會更清楚 ref 的作用，如下：</p>

<p>``` javascript</p>

<pre><code>// 自定義數一個元件，繼承於 Ext.form.FormPanel
MyComponent = Ext.extend(Ext.form.FormPanel, {
    frame: true,

    initComponent: function() {

        // 這個元件擁有兩個欄位，以及兩個 button
        var config = {
            items: [{
                        xtype: 'textfield',
                        fieldLabel: 'Name'
                    }, {
                        xtype: 'textfield',
                        fieldLabel: 'Address'
                    }],
            /* 
            * 對於 bbar 裡的 button 使用 ref
            * 在這層結構上為 panel &gt; toolbar &gt; button
            * 為了改變為 panel &gt; button
            * 所以以 button 的 ownerCt 為 root 也就是 toolbar 的情況下
            * 在往上一層就如同上述的結構透過 ../ 將層級提昇
            */
            bbar: ['-&gt;', {
                        text: 'Cancel',
                        minWidth: 100,
                        ref: '../cancelButton' 
                    }, {
                        text: 'Save',
                        minWidth: 100,
                        ref: '../saveButton' 
                    }]
        };

        //將 initComponent 裡設置好的初始 config 與 initialConfig 合併作為初始的元件
        Ext.apply(this, Ext.apply(this.initialConfig, config));

        //執行 superclass.initComponent 並且指定自定義好的元件作為 this 
        MyComponent.superclass.initComponent.apply(this, arguments);

    }
});

//對新元件註冊 xtype 透過 Ext.reg
Ext.reg('my_component_xtype', MyComponent);


// Create a display a window with the panel in it...

var w = new Ext.Window({
            modal: true,
            items: {
                // 一旦 my_component_xtype 也就是 MyComponent
                // 被實體化後就會有兩個欄位與兩個 button
                xtype: 'my_component_xtype',
                title: 'Panel 1',
                // 在這邊的階層為 window &gt; panel
                ref: 'theFormPanel'
            }
        });
w.show();


// See how we can use the references...
// 因為在 MyComponent 改變了 ref 往上一層跳過 toolbar
// 所以我們就可以如以下操作該物件

w.theFormPanel.saveButton.on('click', function() {
            console.log('Save was clicked');
        }, this);
</code></pre>

<p>```</p>

<p>詳細註解與說明都在上面程式的註解裡，這邊就不多做說明，可以看到透過 ref 的使用，我們可以更加方變得操作 extjs 裡的元件。除了 id 以及 itemid 之外也多了一個可以更方便敘述物件關係的方式。</p>

<p>在這篇文章寫好之前，上面的差異我從來都不知道，也這樣用了好幾年… 說來慚愧，使用一個新的語言或框架基礎還是很重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: grid 中的欄位使用 templete 並且能夠呼叫 rowIndex 以及 colIndex 屬性]]></title>
    <link href="http://smlsun.com/blog/2013/02/18/extjs-grid-column-use-templete-get-rowindex-and-colindex/"/>
    <updated>2013-02-18T19:12:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/18/extjs-grid-column-use-templete-get-rowindex-and-colindex</id>
    <content type="html"><![CDATA[<p>在 grid 中的 column 使用 templete 除了顯示自定的欄位內容外，有些時候我們希望可以存取資料行的索引，如此一來才可以對資料內容進行相對定的事件處理並且能夠正確操作相關的物件。</p>

<p>但是原生的 templete 並沒有對應的 rowIndex 或者事件定義可以讓我們存取，所以我們必須轉個彎來達到這目的，有兩個方式 ...</p>

<h2>透過對 Ext.grid.TemplateColumn 進行繼承改寫</h2>

<p>開始說明作法之前需先了解在 extjs 中 Ext.grid.TemplateColumn 的運作方式，原始碼如下：</p>

<pre><code>Ext.grid.TemplateColumn = Ext.extend(Ext.grid.Column, {

    constructor: function(cfg){
        Ext.grid.TemplateColumn.superclass.constructor.call(this, cfg);
        var tpl = (!Ext.isPrimitive(this.tpl) &amp;&amp; this.tpl.compile) ? this.tpl : new Ext.XTemplate(this.tpl);
        this.renderer = function(value, p, r){
            return tpl.apply(r.data);
        };
        this.tpl = tpl;
    }
});
</code></pre>

<p>其中</p>

<pre><code>this.renderer = function(value, p, r){
    return tpl.apply(r.data);
};
</code></pre>

<p>可以看到其實他的實作方式就是利用 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.grid.Column">Ext.grid.Column 中的 renderer</a> config 來自動呼叫 tpl.apply，其實在官方文件中 renderer 還有後面的參數可以使用，分別是 rowIndex，colIndex，store，完整可以參考 API。</p>

<p>既然原生的 renderer 就有 rowIndex，colIndex 我們只要 extent Ext.grid.TemplateColumn 並且改寫 renderer 令 templete 新增參數即可，所以我們可以這樣做：</p>

<pre><code>Ext.grid.CusTemplateColumn = Ext.extend(Ext.grid.TemplateColumn, {
constructor: function(cfg){
    Ext.grid.TemplateColumn.superclass.constructor.call(this, cfg);
        var tpl = (!Ext.isPrimitive(this.tpl) &amp;&amp; this.tpl.compile) ? this.tpl : new Ext.XTemplate(this.tpl);    

    this.renderer = function(value, p, r, rowIndex, colIndex){

            //第一種方法 
            var newData=Ext.apply({rowIndex: rowIndex, colIndex: colIndex}, r.data);
            return tpl.apply(newData);

            //第二種方法
            //r.data.rowIndex = rowIndex;
            //r.data.colIndex = colIndex;
            //return tpl.apply(r.data);

            //未修改前
            //return tpl.apply(r.data);
        };

        this.tpl = tpl;
}
});
</code></pre>

<p>在上面程式碼中， Ext.apply 所做的就是將目前的物件與傳進來的物件屬性進行合併，如 API 中的敘述</p>

<blockquote><p>Copies all the properties of config to obj. apply</p></blockquote>

<p>其中，tpl 所使用的 tpl.apply 與 Ext.apply 是不一樣的，他是 applyTemplate 的別名</p>

<blockquote><p>Alias for applyTemplate Returns an HTML fragment of this template with the specified values applied.</p></blockquote>

<p>最主要的概念就是針對 tpl.apply 參數所需傳入的物件加上 rowIndex，colIndex 就可以令 temlete 中 html可以存取該屬性，如此一來一旦 grid 有分頁的狀況或者改變排序，在 templete 中的 rowindex 也會隨著改變。</p>

<p>實際上範例的運作如下：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/smlsun/TfnRS/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>接著我們就可以將其應用於 grid 的欄位建立：</p>

<pre><code>var template = new Ext.XTemplate('&lt;input type="checkbox" name="check{rowIndex}" id="checkbox" value="{title}"/&gt;');

var myColumn==new Ext.grid.CusTemplateColumn({ 
    ...
tpl:template     
});

var grid = new Ext.grid.GridPanel({
    ...
columns: [
    { id: 'title-col', header: "Title", width: 225, dataIndex: 'title' },
    myColumn     
],
});
</code></pre>

<p>一旦 grid render 時就會觸動在剛剛所實作的 renderer，在 templete 中的 {rowIndex} 也會正確取得對應的值。</p>

<p>有了上面的概念，其實換個方法可以不用 extent TemplateColumn 也可以做到相同效果 ...</p>

<h2>透過 grid 欄位之 renderer</h2>

<p>我們可以在 renderer 中直接使用定義好的 template 如下面程式碼：</p>

<pre><code>var myColumn={ 
    ...
    renderer : function(value, p, r, rowIndex, colIndex){
        r.data.rowIndex = rowIndex;
        r.data.colIndex = colIndex;
        return template.apply(r.data);
    }
}

var grid = new Ext.grid.GridPanel({
    ...
columns: [
    { id: 'title-col', header: "Title", width: 225, dataIndex: 'title' },
    myColumn     
],
});
</code></pre>

<p>效果是一樣的，可以更直接做到相同的效果，實際上範例的運作如下：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/smlsun/A2eUb/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>實際在使用上該選擇哪種方式？</h2>

<p>方法有很多種，只要能夠達到目的都是可用的方法，但總是有較適合的，一個簡單的判斷方式：如果有很多地方需要用到 extend 的 template 那建議用第一個方法，只要寫一次任何時候需要用到只要引入該客製元件即可，一旦往後有需要在對該元件進行修改調整，只要修正一個地方即可；但如果只有一處用會用到那就用第二種方法，避免過度設計，對於資源載入更加精簡。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: DOM、Element 以及 Component 的差別]]></title>
    <link href="http://smlsun.com/blog/2013/02/18/extjs-dom-element-component/"/>
    <updated>2013-02-18T12:32:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/18/extjs-dom-element-component</id>
    <content type="html"><![CDATA[<p>資料來源：</p>

<ul>
<li><a href="http://hi.baidu.com/andriond/item/757d24dcb1b8f139e3108f8a">理解Html DOM、Ext Element及Component</a></li>
</ul>


<p>學習及應用 extjs，需要理解 Html DOM、Ext Element及Component 三者的區別。extjs 是 Wed 前端框架，基於標準 W3C 構建設的，使用到的都是HTML、CSS、DIV 等相關技術。無論元件有多少屬性、還是事件、方法等，其最終都會轉化為 HTML 在瀏覽器上顯示出來，而每一個 HTML 頁面都有 DOM，瀏覽器中的所有內容都有相應的 DOM，動態改變頁面的內容正是透過 javascript 來操作 DOM 進行實現。</p>

<p>而在 extjs 中就有個專門用來處理 DOM 的類別 ...</p>

<h2>Ext.DomHelper</h2>

<p>DOM其實就是 W3C 標準定義的原始 API，在 extjs 中對 dom 進行強化，製作了 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.DomHelper">Ext.DomHelper</a></p>

<p>在官方 API 中可以看到該類別屬於 singleton，所謂的 singleton 就是所謂的整個程式在運行時只有一份，且不需宣告即已被實體化，官方文件中的範例：</p>

<pre><code>var dh = Ext.DomHelper; // create shorthand alias
// specification object
var spec = {
    id: 'my-ul',
    tag: 'ul',
    cls: 'my-list',
    // append children after creating
    children: [     // may also specify 'cn' instead of 'children'
        {tag: 'li', id: 'item0', html: 'List Item 0'},
        {tag: 'li', id: 'item1', html: 'List Item 1'},
        {tag: 'li', id: 'item2', html: 'List Item 2'}
    ]
};
var list = dh.append(
    'my-div', // the context element 'my-div' can either be the id or the actual node
    spec      // the specification object
);
</code></pre>

<p>可以看到 <code>var dh = Ext.DomHelper;</code> 並未透過 new 來進行建立實體，而在 Ext.DomHelper 特別針對了原生 javascript 的 Insertion methods 進行封裝，如下：</p>

<ul>
<li>append</li>
<li>insertBefore</li>
<li>insertAfter</li>
<li>overwrite</li>
<li>createTemplate</li>
<li>insertHtml</li>
</ul>


<p>當然 extjs 不只是單純的進行封裝那麼簡單，他還避免了一些在效能上容易造成問題的地方，比如說在我另一篇文章<a href="http://smlsun.com/blog/2013/02/01/javascript-performance/">Javascript: Performance &amp; Tip</a> 有提到的 『9. DOM』 使用 DocumentFragment 避免 ReFlow 的問題，在 extjs 中已採用此作法，可以從原始碼<a href="http://docs.sencha.com/ext-js/3-4/source/DomHelper-more.html#Ext-DomHelper">DomHelper-more</a> 中的 <code>createDom</code> 看到 <code>el = doc.createDocumentFragment();</code> 使用了 DocumentFragment。</p>

<p>而DOM是W3C標準定義的原始API，如果我們要取得 dom 可以透過 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext-method-getDom">Ext.getDom(el)</a>，除了用 dom id 來索引之外，也可以傳入 Element，如：</p>

<pre><code>// gets dom node based on id
var elDom = Ext.getDom('elId');
// gets dom node based on the dom node
var elDom1 = Ext.getDom(elDom);

// If we don't know if we are working with an
// Ext.Element or a dom node use Ext.getDom
function(el){
    var dom = Ext.getDom(el);
    // do something with the dom node
}
</code></pre>

<p>接著來看在 extjs 對 DOM 進行封裝後的物件帶來什麼樣的功能 ...</p>

<h2>Ext.Element</h2>

<p>Ext.Element 是Ext的底層API，主要是由Ext或自定義組件來進行呼叫。並且將 DOM 進行封裝，使用方式如下：</p>

<pre><code>// by id
var el = Ext.get("my-div");

// by DOM element reference
var el = Ext.get(myDivElement);
</code></pre>

<p>可以看到只要透過 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext-method-getDom">Ext.get</a> 取得的物件，將會作為 Ext.Element 回傳。</p>

<p>透過 extjs 將 DOM 封裝為 Ext.Element，通過其操作 DOM 來實現頁面的效果顯示，可以方便做到若要把頁面中的某一個節點移到其它位置，要給某一個節點添加陰影效果，要隱藏或顯示某一個節點等，可以很輕易的執行相關的動畫特效，主要是因為在 Ext.Element 中包含了專門處理特效的類別：<a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Fx">Ext.Fx</a>，而以往都需要通過幾句 javascript 才能完成。舉例來說，下面這段取得 DOM 的語法：</p>

<pre><code>var el = Ext.get("my-div");

// no animation
el.setWidth(100);
</code></pre>

<p>只是單純的將寬度設為 100 ，若要有類似特效的效果，很簡單：</p>

<pre><code>// default animation
el.setWidth(100, true);
</code></pre>

<p>修改為上面的程式碼即可，詳細可參照 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Element">API-Ext.Element</a></p>

<p>因此，Ext 在 DOM 的基礎上創建了 Ext.Element，可以使用 Element 來包裝任何 DOM；Element 類別中添加了一系列快捷、簡便的實用方法。其中對於事件上的使用，不像 Component 中的事件是屬於 Ext events，在 Element 中的事件是屬於 browser events，在 extjs 官方 api 中有提到：</p>

<blockquote><p>Note that the events documented in this class are not Ext events, they encapsulate browser events.</p></blockquote>

<p>其中因為是屬於原生的 browser events 所以不是所有的事件在較舊的 browser 中都有支援，不過如果是屬於 Ext events 的範圍則都有支援。如官方所言：</p>

<blockquote><p>Some older browsers may not support the full range of events. Which events are supported is beyond the control of ExtJs.</p></blockquote>

<p>extjs 實作了 Element 來對原生的 dom 操作進行了強化，並且透過 Element 的使用可以不必擔心跨瀏覽器的相容性，解決前端令人困擾的問題，但對於終端用戶來說，僅僅有Element是不夠的，也因此 extjs 最強大的部份就是 ...</p>

<h2>Ext.Component</h2>

<p>假設我們需要在開發時要顯示一個表格、樹狀結構或者彈出一個視窗等，為了方便建立相關的元件，除了 Element 以外，Extjs 還建立了一系列的前端顯示元件 Component，我們在撰寫程式時，只要使用這些組件 Componet 即可實現相關數據展示及交互等，而 Component 是較高層次的抽象，每一個組件在渲染 render 的時候，都會依次通過 Element、DOM 來生成最終的頁面效果。</p>

<p>在Ext中，組件 render 以後可以通過存取 Component 的 properties <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-el">api-el</a> 屬性來得到 Component 對應的 Element ，通過存取 Element 的 dom 屬性可以得到其下面的 DOM。</p>

<p>其中如果要取得某元件可以透過 Ext.getCmp 來得到，相關詳細說明可參考我的另一篇文章：<a href="http://smlsun.com/blog/2013/02/05/extjs-component/">Extjs: Component 的使用，找尋 Parent &amp; Child</a></p>

<p>而下面範例說明實際上的使用狀況：</p>

<pre><code>var view=new Ext.Viewport();                
//建立了一個組件 Component 
view.el.setOpacity(.5);                     
//呼叫 Element 的 setOpacity 方法
view.el.dom.innerHTML="Hello Ext";  //透過 Element 的 dom 屬性操作 DOM
</code></pre>

<p>以及如何分別取得 dom、element 以及 component</p>

<pre><code>var win=new Ext.Window({id:"win1",title:"my window",width:200,height:200}); 
win .show(); 
var c=Ext.getCmp("win1");           //得到 win 
var e=Ext.get("win1");              //根據 id 得到 win 相應的 Element 
var dom=Ext .getDom("win1");        //得到 id 為 win1 的 DOM 節點
</code></pre>

<p>若要進一步了解 extjs 的 Class Diagram 可參考下列網址：<a href="http://d.hatena.ne.jp/Tommy1/searchdiary?word=%2A%5BExtJS%5D">Ext JS 3.0 - Class Diagram</a></p>

<h2>深入 extjs</h2>

<p>如果要想深入應用 Ext，那麼閱讀Ext項目的原始碼是必要的，該原始碼非常值的學習，一些 js 技巧，以及應該要避免的 js 陷阱都有考慮到，透過閱讀原始碼可以更加深刻的了解 javascript 的程式開發，其包含了很多精巧的 js 開發與設計模式。在使用Ext的過程中，需要 extend extjs 的元件作為自定義的元件時，如何實作有時就要從原始碼找答案。</p>

<p>當然 Ext 的原始碼是很龐大的，並不需要從頭開始看，建議可以從元件 Component.js、容器 Container.js 以及 Panel.js；而核心中的 Element.js 以及 Ext.js 等也是蠻重要的。</p>
]]></content>
  </entry>
  
</feed>
