<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-08-06T10:19:19+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs-5-30 事件宣告的建議]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-5-30/"/>
    <updated>2013-08-05T23:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-5-30</id>
    <content type="html"><![CDATA[<p>在使用 extjs 時，我們有幾個地方可以宣告事件的處理：</p>

<ol>
<li>在 controller 下宣告</li>
<li>在 component 下宣告</li>
</ol>


<p>一般剛開始使用 extjs 會搞不清楚什麼時候該使用 mvc 中的 controller 來定義，又或者直接宣告在 component 上，特別是 extjs 4 一大特性 mvc，會讓使用者覺得宣告在 controller 是第一選擇，這樣架構上比較符合官方建議，其實不然，既然 extjs 也支援在 component 上宣告事件，自然有其意義。</p>

<p>既然兩個方式都可以宣告事件，我們該如何區別事件的歸屬呢？筆者認為可以從事件發生關係到的元件或者元件特性（特定功能或是共用元件）來做區別，在明確的說，假設事件所操作的對象所涵蓋的範圍只有該元件以及元件 item 屬性底下所掛載的其他元件，那就應該定義在元件上，若是事件處理涵蓋多個元件的組合互動，那就應該要使用 controller 來定義。</p>

<p>另一個角度，如果該功能屬於共用元件，那事件應該定義在元件底下，屬於特定的功能事件，那應該使用 controller 來處理。</p>

<p>如此一來，如果是定義在元件上的事件，只要某功能有引入該元件，就不需要重覆定義，該元件就有基本的事件互動，一旦需要調整，也不需要一一去改有用到的元件，只要修改宣告事件的元件即可，這樣的情形就像通用元件的狀況，相反地，定義在 controller 的事件就是個別功能的特性了。</p>

<p>舉例來說，如筆者上一篇 <a href="http://smlsun.com/blog/2013/08/05/extjs-4-30/">精簡程式碼案例分享</a> 中的範例是一個標準的功能工具列，事件的定義就是宣告在元件定義上，之後只要有引入使用該標準工具列，就不需要在定義相關的事件。</p>

<p>最後根據上述的內容，整理出建議的事件定義對象</p>

<ol>
<li>如果事件的處理需要整合多個元件那應該定義在 controller 底下</li>
<li>如果該元件屬於特定功能才有的元件就算事件範圍只在某元件底下，事件還是要要定義在 controller 底下。</li>
<li>如果事件處理範圍只屬於某個元件底下並且屬於公用元件，那事件應該定義在元件</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs-4-30 精簡程式碼案例分享]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-4-30/"/>
    <updated>2013-08-05T19:54:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-4-30</id>
    <content type="html"><![CDATA[<p>程式的寫法百百種，要能夠完成一個特定功能沒有標準答案，但要寫的精簡需要經驗的累積，甚至需要對語言特性要有一定的了解，剛好筆者最近 review 了一段 extjs 程式碼，可以與大家分享。</p>

<p>在開始之前，必須先提到一個觀念，extjs 雖然是 RIA，並且有自己的類別化系統，不過他的類別或物件脫離不了 javascript，因此 javascript 中的<a href="http://www.josephjiang.com/presentation/OOJS/object-basic.html">物件</a>、<a href="http://blog.joomla.org.tw/javascript/54-general/81-javascript-functon-basic.html">函數</a>、<a href="http://smlsun.com/blog/2013/01/31/javascript-what-is-this/">this</a> 的特性他也都有。</p>

<p>接著我們來看一段 extjs 類別的程式碼，如下：</p>

<p>這樣的結構可以參考 extjs 官方對於 <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext-method-define">Ext.define</a> 的說明，其中函數所包含的參數 <code>define( className, data, createdFn )</code> data 的形態就是 Object，所以在下列程式第二個參數所傳入的就是標準的 javascript Object，只是裡面所定義的屬性 extjs 有自己的特定的命名以便辨別作為處理，但不代表你不可以把它當作一般的 Object 來操做，在使用 extjs 時很容易讓使用的人誤解認為他是個特別的存在，其實他也只是 javascript。</p>

<p>有了這樣的認知，我們看看下面的程式碼，裡面有很多段重覆的程式碼，參考註解。</p>

<p>``` javascript
Ext.define('foodprint.view. ', {</p>

<pre><code>extend: 'Ext.toolbar.Toolbar',
alias: 'widget.stdeditortoolbar',

requires: [
    'foodprint.view.CreateBtn',
    'foodprint.view.DeleteBtn',
    'foodprint.view.SaveBtn',
    'foodprint.view.ReadBtn',
    'foodprint.view.UpdateBtn'
],

itemId: 'stdEditorToolbar',

initComponent: function() {
    var me = this;

    Ext.applyIf(me, {
        items: [
            {
                xtype: 'createbtn',
                listeners: {
                    click: {
                        fn: me.onCreateBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'deletebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onDeleteBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'savebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onSaveBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'readbtn'
            },
            {
                xtype: 'updatebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onUpdateBtnClick,
                        scope: me
                    }
                }
            }
        ]
    });

    me.callParent(arguments);
},

onCreateBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=btn;
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    delbtn.setDisabled(true);
    savbtn.setDisabled(false);
    updbtn.setDisabled(true);
    redbtn.setDisabled(true);
},

onDeleteBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button;
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    delbtn.setDisabled(true);
},

onSaveBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button;
    var updbtn=button.ownerCt.down('button[itemId=updateBtn]');
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    savbtn.setDisabled(true);
},

onUpdateBtnClick: function(button, e, eOpts) {
        //重覆
    var crebtn=button.ownerCt.down('button[itemId=createBtn]');
    var delbtn=button.ownerCt.down('button[itemId=deleteBtn]');
    var savbtn=button.ownerCt.down('button[itemId=saveBtn]');
    var updbtn=button;
    var redbtn=button.ownerCt.down('button[itemId=readBtn]');

    updbtn.setDisabled(true);
}
</code></pre>

<p>});
```</p>

<p>上面的每一個函式都重覆宣告了 5 個 btn，這樣在維護上是沒有效率的，假設我們需要在加一個按鈕，我們就必須每個函式在加一個宣告，其實還有更好的方式，假設你了解了物件、函式、還有 this 的特性，我們可以將這五個按鈕的參照存在第二個參數 data 下，透過例如：<code>this.updateBtn=component.down('button[itemId=createBtn]');</code> 如下面程式碼中 <code>onStdEditorToolbarRender</code>，用到的事件 binding 是 extjs Component <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Component-event-render">render 事件</a> 元件實體化後觸動該事件進行處理，只要找到一個這樣只執行一次的進入點，將需要用到的元件存入 this 這個物件，之後我們就不需要重覆 query 物件的參照，也更加快處理速度，雖然這樣的調整可能效果不明顯，但累積起還是很可觀的，特別當你感覺到慢的時候，可能已經遍佈程式碼中，<strong>好習慣要從日常養成</strong>。</p>

<p>``` javascript
Ext.define('foodprint.view.StdEditorToolbar', {</p>

<pre><code>extend: 'Ext.toolbar.Toolbar',
alias: 'widget.stdeditortoolbar',

requires: [
    'foodprint.view.CreateBtn',
    'foodprint.view.DeleteBtn',
    'foodprint.view.SaveBtn',
    'foodprint.view.ReadBtn',
    'foodprint.view.UpdateBtn'
],

itemId: 'stdEditorToolbar',

initComponent: function() {
    var me = this;

    Ext.applyIf(me, {
        items: [
            {
                xtype: 'createbtn',
                listeners: {
                    click: {
                        fn: me.onCreateBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'deletebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onDeleteBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'savebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onSaveBtnClick,
                        scope: me
                    }
                }
            },
            {
                xtype: 'readbtn'
            },
            {
                xtype: 'updatebtn',
                disabled: true,
                listeners: {
                    click: {
                        fn: me.onUpdateBtnClick,
                        scope: me
                    }
                }
            }
        ],
        listeners: {
            render: {
                fn: me.onStdEditorToolbarRender,
                scope: me
            }
        }
    });

    me.callParent(arguments);
},

onCreateBtnClick: function(button, e, eOpts) {
    this.delbtn.setDisabled(true);
    this.savbtn.setDisabled(false);
    this.updbtn.setDisabled(true);
    this.redbtn.setDisabled(true);
},

onDeleteBtnClick: function(button, e, eOpts) {
    this.delbtn.setDisabled(true);
},

onSaveBtnClick: function(button, e, eOpts) {
    this.savbtn.setDisabled(true);
},

onUpdateBtnClick: function(button, e, eOpts) {
    this.updbtn.setDisabled(true);
},

onStdEditorToolbarRender: function(component, eOpts) {
    this.crebtn=component.down('button[itemId=createBtn]');
    this.delbtn=component.down('button[itemId=deleteBtn]');
    this.savbtn=component.down('button[itemId=saveBtn]');
    this.updbtn=component.down('button[itemId=updateBtn]');
    this.redbtn=component.down('button[itemId=readBtn]');

}
</code></pre>

<p>});</p>

<p>```</p>

<p>優化過的程式碼，可以看到物件的 query 只有一次，之後都可以透過 this 來存取，每個函式所執行的都是關鍵的程式碼，沒有多餘的宣告，雖然是很簡單的觀念與應用，如果知道將會受用無窮，不只在 extjs 在一般的 javascript 開發也可以應用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs-3-30 mixins(混和) 特性說明]]></title>
    <link href="http://smlsun.com/blog/2013/08/05/extjs-3-30/"/>
    <updated>2013-08-05T11:56:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/05/extjs-3-30</id>
    <content type="html"><![CDATA[<p>extjs4 中的 mixsins 是 extjs4 的新特性，在筆者之前寫過的文章中<a href="http://ithelp.ithome.com.tw/question/10120091">extjs 4 系列 1/5：新特性與基本概念</a> mixins (混合複數classes) 章節，有做過簡單介紹，讀者可以參考相關說明，了解 mixsins 的特性，官方 API 可參考連結：<a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Class-cfg-mixins">mixins API</a>，在 extjs 中屬於 Ext.Class 的函式，也就等於所有不管 mvc 或是元件，都可以使用 mixins 的特性。</p>

<p>接著，想要知道 mixins 在不同狀況下的處理方式可參考 <a href="http://www.cnblogs.com/fsjohnhuang/archive/2013/01/29/2880705.html#o1.3.3.">Ext JS 4 First Look 中文翻譯</a> mixins 章節，在使用上就必須要注意什麼情況下函式或屬性在捨麼情況下會被保留，什麼會被覆蓋。</p>

<p>舉個例子，假設我們有兩個 controller 分別如下：</p>

<p>共用元件之 controller：</p>

<p>``` javascript
Ext.define('foodprint.controller.StdController', {</p>

<pre><code>extend: 'Ext.app.Controller',

views: [
    'StdEditorToolbar'
],

refs: [
    {
        ref: 'stdEditorToolbar',
        selector: 'stdeditortoolbar'
    }
],

initial: function(tbar) {
    ...
},

onCreateBtnClick: function(btn) {
 ... 
}
</code></pre>

<p>});</p>

<p>```</p>

<p>另一個別功能之 controller:</p>

<p>``` javascript
Ext.define('foodprint.controller.AController', {</p>

<pre><code>extend: 'Ext.app.Controller',

mixins: {
    StdEditorToolbarCtrl: 'foodprint.controller.StdController'
},

views: [
    'BatchEditor'
],

refs: [
    {
        ref: 'batchGrid',
        selector: 'batchgrid'
    }
],

init: function(application) {
    ...
},

readBatch: function(obj, record, item, index, e, eOpts) {
    ...
},
</code></pre>

<p>});
```</p>

<p>在上述的使用情境中，StdController 中的 refs 將會失效，保留 AController 中的 refs，因此在這樣狀況下，若要在 AController 也要能夠有 StdController 中 refs 定義的元件，勢必要在 AController 再次定義一次 StdController 的 refs。</p>

<p>另一種使用情境：假設被 mixins 的類別跟基礎類別有同名的函式，但是我們希望兩個個別實作同名函式<strong>都可以被執行</strong>可以參考 <a href="http://docs-origin.sencha.com/extjs/4.2.1/#!/api/Ext.Class-cfg-mixins">mixins API</a>的範例：</p>

<p>``` javascript</p>

<p>Ext.define('CanSing', {</p>

<pre><code> sing: function() {
     alert("I'm on the highway to hell...")
 }
</code></pre>

<p>});</p>

<p>Ext.define('Musician', {</p>

<pre><code> mixins: {
     canSing: 'CanSing'
 },

 sing: function() {
     // delegate singing operation to mixin
     this.mixins.canSing.sing.call(this);
 }
</code></pre>

<p>})
```</p>

<p>希望透過本篇可以讓讀者了解 mixins 的特性，進而有效的重覆利用函式，減少不必要的重覆程式碼。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs 2/30:使用 sencha architect 開發注意事項]]></title>
    <link href="http://smlsun.com/blog/2013/08/01/extjs-2-30/"/>
    <updated>2013-08-01T22:52:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/08/01/extjs-2-30</id>
    <content type="html"><![CDATA[<p>在使用 sencha architect 開發時，我們很難對 js 檔進行檔案修改，基本上所有的檔案調整，都是透過 architect 存檔時一並寫入對應的原始檔案，其中關於每個 js 的原始檔放於 <code>EXTJS_HOME/metadata</code>，但一旦你進入該資料夾檢視相關的檔案，可以發現他跟一般的 js 有出入，所以你也不要想再裡面進行編輯，有可能會造成整個專案運作異常。</p>

<p>除此之外在專案裡面，有兩個設定檔為 architect 所產生分別是 <code>.architect</code> 以及 <code>projectName.xds</code>，其中 <code>.architect</code> 會自動產生，但 xds 就不好搞了，如果你是一個人開發，還不致於發生問題，但若是多人開發，再加上有使用版本控管，問題就來了；xds 檔所記錄的似乎是在 architect 建立 extjs 元件之間的關聯，因此若是多人開發不同的功能，並且在版本控管的情況下，該檔案很容易有衝突；而在編修衝突時，很多時候會不知道該如何下手，因為代表元件的相關檔案識別皆已編碼，只有 IDE 才看的懂對應的關係，如果 xds 的內容無關緊要或是會重新產生那就算了，偏偏 xds 檔在 architect 是主要專案的進入點，因此如果處理的不好，很容易造成專案運作異常。</p>

<p>就筆者的經驗，一般 extjs 元件的建立或修改基本上都比較不會有問題，最容易產生異常的通常是在 application.js 這個檔案，在 extjs 的世界裡，該檔案定義了一個應用程式在運行時，需要載入 extjs 中 mvc 各個物件，為什麼他很容易出現問題呢？主要因為在使用 architect 時，當你新增元件時，IDE 將會自動將你新增的元件載入到 application.js 中，多人開發情形下，Application.js 就會是所有人的交集，不然照理分別開發新功能所新增的元件皆不同不應該會頻繁造成衝突，而因為 application.js 的多人異動，造成再 xds 中對 application.js 的檔案識別常常會有不同的代表造成衝突，一旦 xds 衝突一發生，編修時一不小心讓 IDE 不認得 Application.js，就會造成 Application.js 無法被識別，導致 IDE 認為沒有建立 Application.js，則以最原始的狀態 Application.js 作為預設，也就是沒有任何元件載入，導致於系統運作異常。</p>

<p>知道問題發生的原因，那上述問題怎麼解？其實只要改變我們建立物件的習慣即可，在說明作法前，需要先讓大家了解一下 extjs 如何載入相關 js 檔的，在 extjs 中，不管你是宣告 mvc 其中的任一類型的元件，或是繼承 extjs 原生的類別，很多時候我們會使用 require 這個宣告，來告訴 extjs 該元件要運作需要哪些類別配合，一旦你有定義 require，當元件運行時，extjs 就會自動將相關 require 的類別進行載入，這是個很方便的特性，幫助我們省去在 html 中載入所需 js 的麻煩，進一步的減少元件忘記或是載入錯誤。</p>

<p>前面有提到 application.js 是多人開發時的交集，一個方法是減少交集的產生，而我們該如何減少交集呢？可以用到 extjs 自動載入元件的特性，將我們需要用到的元件皆定義在 controller 底下，而在 application.js 只載入 controller 相關元件，如此就可以減少 application.js 變動，即使真的不幸還是造成 application.js 異常，我們知道只要將所有 controller 載入即可恢復，除了避免多人開發時造成程式碼衝突，將需要的物件定義在 controller 裡面也才是較正確的方式，完善的定義該功能再運行時所需的元件，可以帶來更易於維護的優點，另外在使用 architect 時，一旦你將相關物件加入 controller 時，IDE 也會問你要不要將設定在 application 載入的元件移除，如此一來元件所責任的功能也會更加清楚。</p>

<p>上述的解法，是筆者根據經驗認為比較優的解法，如果讀者有更好的想法也歡迎分享，希望可以讓有同樣困擾的人節省一點時間。</p>

<p>最後綜合上述的內容，整理出使用 architect 開發需要注意的重點如下：</p>

<ol>
<li>.sencha 檔案可以不用加入版本控管，一旦你使用 architect 進行存檔時，該檔案都會重新產生，衝突情形也可以直接覆蓋最新版本</li>
<li>xds 檔，很多時候都會有衝突，更新程式碼有衝突時，編修完成後記得開啟 architect 確認 application.js 中掛載的元件是否還好好的在那邊。</li>
<li>因為 architect 在編輯過程中不會動態載入你的元件，因此一旦你在 IDE 開啟中的狀態要進行程式碼更新，建議先對專案進行存檔，並且程式碼一旦更新為最新的，記得將 IDE 重啟以便重新載入所有更新過程式碼。</li>
<li>建立 extjs 元件時，不要懶惰讓 IDE 自行將元件加入到 application.js 可以的話建立該功能所需要的 controller 將其歸屬進去，整個功能架構也會更加清楚。</li>
<li>在 application 中，原則上只管理需要載入的 controller 即可，一旦編修衝突不順利，可以很快的進行復原。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企業級開發框架：extjs 與 grails 的完美組合]]></title>
    <link href="http://smlsun.com/blog/2013/05/09/extjs-with-grails/"/>
    <updated>2013-05-09T21:44:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/05/09/extjs-with-grails</id>
    <content type="html"><![CDATA[<p>本篇的重點在於說明 extjs 作為 web 應用程式前端的 framework，如何與目前常用的 full stack framework 進行整合，在此將以 grails 為例，當然不只可以跟 grails 整合，其他像 RoR 或者 .net，甚至是 node.js 都可以作為 extjs 的後端服務提供者。</p>

<p>透過 grails 這樣的整合範例，希望可以讓讀者體會不只能夠快速開發，一旦應用程式大到一定程度，也可以很方便的維護，並且在開發流程中的循環都可以順暢的不停轉動。</p>

<hr />

<h2>前後端分工</h2>

<p>開發大型軟體，或是時程上較趕的時候最怕等來等去，在開發應用程式時，最需要確認的是資料庫的設計，一旦定義好之後，如何快速完成 model 並且將測試資料建立完成，以便進行測試，透過 grails 與 extjs 剛好可以完美的解決此問題，前幾篇介紹到的關於 extjs model 類別的使用，其概念與 grails 剛好一拍即合，同樣以之前 <a href="http://ithelp.ithome.com.tw/question/10120206">extjs mvc 為例</a> 裡面用到的 Item，batch，以及 itemImage，在 grails 中宣告如下：</p>

<p>``` groovy
package finder
class Item {</p>

<pre><code>    String name
    String title=""
    String description=""
    static hasMany=[itemImages:ItemImage]
</code></pre>

<p>}</p>

<p>package finder
class Batch {</p>

<pre><code>    String name
    static belongsTo =[item:Item]
</code></pre>

<p>}</p>

<p>package finder
class ItemImage {</p>

<pre><code>Item item
String name
</code></pre>

<p>}
```</p>

<p>grails 可以把它看做 java 中的 RoR，因此也有「約定優於配置」的特性，以往在傳統 java 對於 O/R mapping 這樣的技術，往往需要大量的 xml 定義，在 grails 只要將寫好的 model 放在 grails 下的 model 資料夾，而三個資料表定義就像上面的程式碼一樣，輕鬆簡單！不需要在對資料庫進行 table create，一旦 grails 啟動就會檢查資料庫是否有對應的資料表，判斷若是 develop mode 將會使用虛擬資料庫，在記憶體中就會建立好三個 table，不需要有實體就可以開始對你的應用程式開始進行測試，一旦開發完成，只要進行設定轉換為實體資料庫即可，接著在 grails 中有個類別 BootStrap 在這裡可以定義你要測試的初始資料，以便進行相關應用開發，如下：</p>

<p>``` groovy
import finder.*</p>

<p>class BootStrap {</p>

<p>  def init = { servletContext -></p>

<pre><code>    environments {
        development {
            def item1 = new Item(name:"item1").save(failOnError: true, flush: true)
            def batch1 = new Batch(name:"batch1",item:item1).save(failOnError: true, flush: true)
            def itemImage1 = new ItemImage(name:"itemImage1.jpg",item:item1).save(failOnError: true, flush: true)
        }
    }
</code></pre>

<p>  }
  def destroy = {
  }
}
```</p>

<p>一旦伺服器啟動就會執行在 BootStrap 中的程式碼，如果我們在此區塊撰寫新增資料的程式，每次啟動 grails 都會有新的資料可以進行測試，反覆測試的過程中將免去每次都要建立測試資料的麻煩，並且有預設的設定值也可以在此定義，資料準備好了，前後端就可以分開進行，接著來看如何快速定義好 extjs 與 grails 的溝通橋樑。</p>

<h2>以 RESTful 進行前後端溝通</h2>

<p>extjs 4 有個新的 proxy type：rest，一但定義為 rest proxy，在資料操作上將會根據你對前端資料的更新動作給予不同的 http method，如下：</p>

<ul>
<li>新增：POST</li>
<li>修改：UPDATE</li>
<li>刪除：DELETE</li>
<li>查詢：GET</li>
</ul>


<p>我們會用到另一個敏捷開發特性：Don’t Repeat Yourself(DRY)，在 Grails 有另一個設定檔 URLMappings 可以讓我們設定根據前端 request 的 http method 導入至特定後端 controller method，該檔案設定如下：</p>

<p>``` groovy
class UrlMappings {</p>

<pre><code>static mappings = {
    "/$controller/$action?/$id?"{
        constraints {
        }
    }
    "/rest/$controller/$id"{
        action = [GET: "show", PUT:"update", DELETE:"delete"]
        constraints {
        }
    }
    "/rest/$controller"{
        action = [GET:"listAll", POST: "create"]
        constraints {
        }
    }
    "/"(view:"/home/index")
    "500"(view:'/error')
}
</code></pre>

<p>}
```</p>

<p>可以看到在 URLMappings 的設定中：</p>

<p>``` groovy
"/rest/$controller/$id"{</p>

<pre><code>action = [GET: "show", PUT:"update", DELETE:"delete"]
constraints {
}
</code></pre>

<p>}</p>

<p>"/rest/$controller"{</p>

<pre><code>action = [GET:"listAll", POST: "create"]
constraints {
}
</code></pre>

<p>}
```</p>

<p>代表如果有傳入 id 則是上述的第一種 mapping 方式，根據 http method 的不同對應到不同的 controller 的 method；若沒有 id 則是第二種，實際代表的網址可能為 <code>http://localhost/rest/item/1</code> 或者 <code>http://localhost/rest/batch/</code>，就會根據 UrlMappings 的定義觸動在 controller 中的 method，範例如下：</p>

<p>``` groovy
package finder
import grails.converters.JSON
class ItemController {</p>

<pre><code>def listAll = {
    def items=Item.list()
    render (contentType: 'text/json') {
  [
            items: items,
            total: items.size()
        ]
    }
}

def show = { Long id -&gt;
    def item=Item.findById(id)
    render (contentType: 'text/json') {
  [
            item: item
        ]
    }

}

def create = {
    ...
}
def update = {
    ...
}
def delete={
    ...
}
</code></pre>

<p>}
```</p>

<p>剛剛提到對應的 controller method 就如同上面程式碼中的 listAll，show 等等，到這邊，後端的 server 算是已經準備好，可以開始進行測試，是否發現跟一般 java 比，簡潔很多，寫起來還有點像 javascript？實際上 Grails 骨子裡還是 java，執行時會編譯為 class，因為搭配了 java 中的動態語言 groovy 才有這樣的效果，且並沒有捨棄 java 多年累積廣大的第三方套件，當你需要時皆可以引入，不需重新造輪。</p>

<h2>extjs：store.sync() - 簡化更新</h2>

<p>後端 server 快速準備好後，在 extjs 更加簡化呼叫更新資料請求的程序，在 store 的類別提供一個 method 為 sync()，作用在於一旦 store 載入後，只要對 store 執行 insert，remove，insert 確定更新完成後，一旦執行就會對後端 server 發出 http request，所以，你不用勞你費心，extjs 已幫你完成相關程序，範例 controller 如下：</p>

<p>``` javascript
Ext.define('Frontend.controller.common.Standard', {</p>

<pre><code>extend: 'Ext.app.Controller',

doRead: function() {
    this.store.load();
},
doCreate: function() {
    this.store.insert(0, this.model);
},
doDelete:function(){
    var selection = this.grid.getSelectionModel().getSelection()[0];
    if (selection) {
        this.store.remove(selection);
    }
},
doUpdate: function() {
        //更新對 store 的異動
    this.store.sync({
        success : function(){
            console.log("success");
            Ext.Msg.alert('Status', '更新成功');
        },
        failure : function(response, options){
            console.log("failure");
            Ext.Msg.alert('Status', '更新失敗');
        }  
    });
}
</code></pre>

<p>});
```</p>

<h2>快速前端元件建立</h2>

<p>即使用像 grails 這樣的 full stack framework 對於前端介面還是需要自己重頭刻起，若是搭配 sencha architect 將可以補齊這方面的不足：快速建立前端介面，並且為了敏捷快速的開發，一旦介面拉好，就可以儘快確認需求與操作介面，所完成的介面就可以開始著手開發，介面的變動也可以在 architect 中完成，還記得之前有介紹過在 extjs 中的每個小元件都可以作為類別存在，並且 controller 若以每個元件為目標設計，透過混和（mixins）的特性組合 controller 就可以快速調整介面的呈現與互動。</p>

<h2>extjs develop mode &amp; test</h2>

<p>一個好的框架，必須還要能夠方便測試，在 extjs 中可以很方便的指定某個類別作為初始的 view，可以參考上一篇 <a href="http://ithelp.ithome.com.tw/question/10120289">Sencha Architect 快速開發 extjs</a>中「方便進行測試與開發」的介紹，即使你沒有用 Architect，也可以自行定義，別忘了利用這樣的特性對開發中的介面進行測試。</p>

<h2>extjs production mode</h2>

<p>應用程式開發到一個階段，就會從 develop 進階到所謂的 production mode，其目的就是要盡量加速資源的載入，在前端的世界就是要將所有的 js 檔最小化，並且合為一個 js 檔，雖然 extjs 有動態載入，實際在 production 模式這樣是很耗效能的，如果我們要自行利用 minify 工具進行壓縮，在 extjs 中各類別的相依性就無法顧慮到，並且可能因為組成檔案順序不正確造成衝突，所幸，extjs 也注意到這樣的問題，提供 Sencha cmd 來處理 minify js 的程序，並且可以搭配 Architect 使用，步驟如下：</p>

<ol>
<li><p>利用 sencha cmd 產生 extjs 專案</p>

<pre><code> sencha -sdk {extjs_home} generate app {projectName} {projectLocation}
</code></pre></li>
<li><p>修改 sencha 設定檔：修改 {projectLocation}/.sencha/app/sencha.cfg，加入下面兩行 ：</p>

<pre><code> app.dir={projectLocation}
 app.classpath=${app.dir}/app.js,${app.dir}/app
</code></pre></li>
<li><p>進到 {projectLocation} 執行 production 編譯</p>

<pre><code> sencha app build production
</code></pre></li>
</ol>


<p>如此一來就會將執行完的結果產出在 {projectLocation}/build 底下，就是這們簡單！</p>

<h2>resource 控管</h2>

<p>extjs 所完成的介面在 grails 中將作為 resource 存在，且對 grails 而言屬於靜態檔案，因此可以進行快取來加速資源載入，而在 grails 有一設定檔 ApplicationResources 專門在定義要載入的 resource，在設定時必須考慮 develop 與 production 的不同，設定方式如下:</p>

<p>``` groovy
import org.codehaus.groovy.grails.web.context.ServletContextHolder as SCH
modules = {</p>

<pre><code>// develop mode 使用
extjs4_dev {
    defaultBundle 'finder_dev'

    resource url: 'extjs4_dev/resources/ext-theme-neptune/ext-theme-neptune-all.css'        
    resource url: 'ext/ext-all.js'
    resource url: 'ext/ext-theme-neptune.js'
    resource url: 'app.js'

    getFilesForPath('app').each {
        resource url: it
    }
}   
// production mode 使用
</code></pre>

<p>  extjs4 {</p>

<pre><code>    defaultBundle 'finder'
    resource url: 'extjs4/resources/finder_extjs-all.css'
    resource url: 'extjs4/all-classes.js'
}   
</code></pre>

<p>}</p>

<p>// 載入 path 參數底下所有的檔案作為 resource
def getFilesForPath(path) {</p>

<pre><code>def webFileCachePaths = []
def servletContext = SCH.getServletContext()

if(!servletContext) return webFileCachePaths
def realPath = servletContext.getRealPath('/')
def appDir = new File("$realPath/$path")
appDir.eachFileRecurse {File file -&gt;
    if (file.isDirectory() || file.isHidden()) return
    webFileCachePaths &lt;&lt; file.path.replace(realPath, '')
}
webFileCachePaths
</code></pre>

<p>}
```
經由這樣的設定，grails 會自動將 block 中所定義的 js 檔自動合為單一 js 檔，接著我們只要在 grails 中特有的 gsp 加入下列判斷：</p>

<p>```
&lt;g:if env='development'></p>

<pre><code>&lt;r:require modules="extjs4_dev"/&gt;
</code></pre>

<p>&lt;/g:if>
&lt;g:else></p>

<pre><code>&lt;r:require modules="extjs4"/&gt;
</code></pre>

<p>&lt;/g:else>
```
就會根據不同的開發模式載入不同的 resource 組合。</p>

<h2>打完收工，期待下次在相會！</h2>

<p>這是個想法，目前我們也正在投入這樣的應用，預期可以帶來不一樣的開發方式，軟體開發方式不停的在進步，也許還有很多團隊還在使用老舊的方法，這樣的組合，除了可以敏捷快速的開發，利用 extjs 所提供的方便性，相信可以帶來效率的提升，特別是前端的物件建立與操作，表單式的應用程式非常適合，筆者也曾在企業進行 extjs 的教育訓練，歡迎有興趣的讀者可以互相切磋。</p>

<p>系列文章到此告一段落，期待下次在與大家分享！</p>
]]></content>
  </entry>
  
</feed>
