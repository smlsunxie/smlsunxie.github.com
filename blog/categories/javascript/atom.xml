<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-04-30T15:46:02+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs4: mvc 使用簡介與範例介紹]]></title>
    <link href="http://smlsun.com/blog/2013/03/21/extjs4-mvc/"/>
    <updated>2013-03-21T08:42:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/03/21/extjs4-mvc</id>
    <content type="html"><![CDATA[<p><a href="http://www.showframework.com/2012/07/extjs-mvc-architecture/">ExtJS 4 MVC架構講解</a></p>

<p>引用上述文章的開頭：</p>

<blockquote><p>大規模客戶端應用通常不好實現不好組織也不好維護，因為功能和人力的不斷增加，這些應用的規模很快就會超出掌控能力，ExtJS 4帶來了一個新的應用架構，不但可以組織代碼，還可以減少實現的內容 新的應用架構遵照一個類MVC的模式，模型（Models）和控制器（Controllers）首次被引入。業界有很 ​​多種MVC架構，基本大同小異，ExtJS 4的定義如下：</p>

<ul>
<li>Model: 資料的集合，例如 User 帶有 username 和 password 的資料，model 知道如何持久化自己的數據，並且可以和其他 model 關聯，model 跟 ExtJS 3中 的 Record 有點像（區別是，Record 只是單純的扁平結構，而 Model 可以 nest ），通常都用在 Store 中去展示 grid 和其他組件的資料</li>
<li>View: 用於界面展示– grid, tree, panel都是view</li>
<li>Controllers: 安放所有使你的 app 正確工作的代碼的位置，具體一點應該是所有動作，例如如何渲染 view，如何初始化 model，和 app 的其他邏輯</li>
</ul>
</blockquote>

<p>對於 extjs 4 的 mvc 有點概念後，我們可以實際來看例子進一步了解運作的方式。</p>

<h2>Application</h2>

<p>每個ExtJS 4的應用都從一個 Application 開始，這個實例包含應用的全域配置（例如應用的名字），這個實例也負責維護對全部模型、視圖、控制器的引用的維護，還有一個 <code>launch</code> 函數，會在所有加載項加載完成之後呼叫。首先需要選擇一個全域命名空間，所有 ExtJS4 應用都需要有一個全域命名空間，以讓所有應用中的 class 安放到其中</p>

<p>```javascript</p>

<pre><code>Ext.Loader.setConfig({
    enabled: true,
    //disableCaching: true //強制關閉 cache
});

Ext.application({
    name: 'Frontend',   //app folder 別名為 Frontend
    appFolder: 'app',   //檔案 root 存放位置
    controllers: [

    'SYS.SYS001',   //使用者登入
    'SYS.SYS002',   //主畫面
    'MN.MNM001',     //群組權限維護
    'US.USM002'    //使用者群組維護
    ],
    launch: function() {
        Ext.create('Ext.container.Viewport', {
            id: 'mainVP',
            layout: 'fit',
            items: [{
                xtype: 'sys001loginform',
                url: 'http://localhost:8080/agricloud/user/login.json'
            }]
        });
    }
});
</code></pre>

<p>```</p>

<h2>Model</h2>

<p>定義來源資料的 mapping 以及資料型態</p>

<p>```javascript</p>

<pre><code>// app/model/MN/MNM001/MenuGroup.js
Ext.define('Frontend.model.MN.MNM001.MenuGroup', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'menuId', type: 'string'},
        {name: 'menuDes',  type: 'string'},
        {name: 'userGroupId',  type: 'string'},
        {name: 'userGroupDes',  type: 'string'}
    ]
});
</code></pre>

<p>```</p>

<h2>Store</h2>

<p>設定資料獲取的來源，以及取得資料的方式，載入上一節的 model <code>Frontend.model.MN.MNM001.MenuGroup</code>。一旦資料讀取成功，將會依據 model 進行資料 mapping 作為 view 層的資料呈現來源。</p>

<p>```javascript</p>

<pre><code>// app.store.MN.MNM001.Store.js
Ext.define('Frontend.store.MN.MNM001.Store' ,{
    model:'Frontend.model.MN.MNM001.MenuGroup', 
    extend: 'Ext.data.Store',
    alias : 'widget.mnm001store',
    autoLoad: true,
    proxy: {
        type: 'rest',   // 使用 rest 來與後端 server 溝通
        url: 'http://localhost:8080/agricloud/rest/menuGroup/',
        reader: {
            type: 'json',
            root: 'items'
        },
        writer: {
            type: 'json'
        },
        afterRequest:function(request,success){
            var operation = request.operation;
            var response = operation.response; 
            if(success){
            }else{}
        }
    },
    listeners: {
        // 讀取完資料後，進行 load 
        write: function(store, operation) {
            store.load();
        }
    }
});
</code></pre>

<p>```</p>

<h2>Controller</h2>

<p>用於整合 model 的資料讓 view 可以使用，並且定義 view 各個事件要執行的內容，如此一來 view 將可以被獨立設計，一旦 view 被使用於別的功能也不會有衝突的事件定義。在使用上 Controller 也可以進行繼承，下面的 parent Controller 範例實作一些常用的事件，因為對於 controller 而言，所載入的各個 store 都視為 controller 的屬性，故只要繼承至 parent Controller 都有給定要求的變數內容，所定義的事件將會運作正常</p>

<h3>parent Controller</h3>

<p>```javascript</p>

<pre><code>/**
 * std Controller
 */
Ext.define('Frontend.controller.common.Standard', {
    extend: 'Ext.app.Controller',
    execute: function(params) {
        var tab = Ext.getCmp('mainTab');
        tab.add({
            id: params.id,
            title: params.title,
            closable: true,
            layout:'fit',
            items: {
                xtype: params.tabXtype
            }
        });
    },
    doRead: function() {
        console.log("doRead")
        this.store.load();
    },
    doCreate: function() {
        this.store.insert(0, this.model);
    },
    doDelete:function(){
        var selection = this.grid.getSelectionModel().getSelection()[0];
        if (selection) {
            this.store.remove(selection);
        }
    },
    doUpdate: function() {
        this.store.sync({
            success : function(){
                console.log("success");
                Ext.Msg.alert('Status', '更新成功');
            },
            failure : function(response, options){
                console.log("failure");
                Ext.Msg.alert('Status', '更新失敗');
            }  
        });
    },
    onGridSelection:function(selModel, selections,eOpts){
        this.selections=selections;
        this.selModel=selModel;

        //必須利用refs 取得實體介面已 render的物件
        this.deleteButton.setDisabled(selections.length === 0);

    },
    onPanelRendered: function() {
        //將載入的 view 指定為此 controller 的屬性
        this.grid=this.getGridPanel();
        this.deleteButton=this.getDeleteButton();
    }
});
</code></pre>

<p>```</p>

<h3>main controller</h3>

<p>繼承於上一節的 parent Controller，在主要使用的 controller 需透過 <code>views</code>、<code>stores</code>、<code>models</code> 將對應的 mvc 載入，以及透過 refs 將需要控制的 Component 找出來並且給予別名，如此一來，我們在之後 <code>init</code> 事件定義元件的動作時可以方便的參照相關的元件。</p>

<p>```javascript</p>

<pre><code>// app.controller.MN.MNM001.js
/**
 * 功能群組維護
 */
Ext.define('Frontend.controller.MN.MNM001', {
    extend: 'Frontend.controller.common.Standard',
    views: [
        'MN.MNM001.Panel'
    ], 

    refs: [{
        ref: 'deleteButton',
        selector: 'mnm001panel commonbuttondelete'
    },{
        ref: 'gridPanel',
        selector: 'mnm001panel'
    },{
        ref: 'combobox',
        selector: 'mnm001combobox'
    }],
    init: function() {

        定義各個元件所要執行的事件以及相關的函數
        this.control({
            'mnm001panel commonbuttoncreate': {
                click: this.doCreate
            },
            'mnm001panel commonbuttondelete': {
                click: this.doDelete
            },
            'mnm001panel commonbuttonupdate': {
                click: this.doUpdate
            },
            'mnm001panel commonbuttonread': {
                click: this.doRead
            },
            'mnm001combobox': {
                select:this.comboboxSelect
            },
            'mnm001panel': {
                selectionchange: this.onGridSelection,
                render: this.onPanelRendered
            }
        })
        //ref 的使用對象為 Conpoment
        //store 的取得直接用 this 
        //在 view 所組成的 compoment 中有使用到的 store 皆可以在 controllr 中存取

        this.store=this.getStore("MN.MNM001.Store");

    },
    execute: function(params) {
        //定義此 contoller 所使用之屬性，controller 一旦被執行此事件將會最先被執行
        params.tabXtype='mnm001panel';
       //結果將透過下列程式呼叫繼承來的 controller 之 execute
        this.callParent(arguments);
    },
    comboboxSelect: function( combo, records, eOpts ) {
        this.selections[0].set('userGroupDes',records[0].get('description') );
    }
});
</code></pre>

<p>```</p>

<h2>View</h2>

<p>view 的使用依賴於 controller 有載入的內容，在這邊只作為介面的呈現，不進行事件的定義，除非該事件為通用的事件。</p>

<h3>Combobox</h3>

<p>使用的第一個 store <code>US.USM002.Store</code></p>

<p>```javascript</p>

<pre><code>Ext.define('Frontend.view.MN.MNM001.Combobox', {
    extend: 'Ext.form.ComboBox',
    alias : 'widget.mnm001combobox',
    id:'mnm001combobox',
    itemId:'mnm001combobox',
    store: 'US.USM002.Store',
    queryMode: 'local',
    displayField: 'userGroupId',
    valueField: 'userGroupId'
});
</code></pre>

<p>```</p>

<h3>Panel</h3>

<p>使用的第二個 store <code>MN.MNM001.Store</code>，其中 <code>Frontend.view.common.gridpanel.standard</code> 是自定義通用的 gridpanel，假設你有第二個類似的功能就可以繼承他，只要修改 columns 的定義即可，並且載入額外套件。</p>

<p>```javascript</p>

<pre><code>Ext.define('Frontend.view.MN.MNM001.Panel' ,{
    extend: 'Frontend.view.common.gridpanel.standard',
    alias : 'widget.mnm001panel',
    requires:['Frontend.view.MN.MNM001.Combobox'],
    columns: [
        { 
            header: 'menuId',  
            dataIndex: 'menuId', 
            flex: 1,
            field: {
                xtype: 'textfield'
            }
        },
        { 
            header: 'menuDes', 
            dataIndex: 'menuDes'
        },
        { 
            header: 'userGroupId', 
            dataIndex: 'userGroupId',
            field: {
                xtype: 'mnm001combobox'
            }
        },
        { 
            header: 'userGroupDes', 
            dataIndex: 'userGroupDes' 
        }
    ],
    plugins: [{
            ptype:'rowediting'
    }],
    store:'MN.MNM001.Store'
});
</code></pre>

<p>```</p>

<h2>執行結果</h2>

<h3>功能一</h3>

<p><img src="https://lh5.googleusercontent.com/-lx8V6k3xoO8/UUp-XqNiMnI/AAAAAAAALmk/19RA9GS5zrE/s615/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-03-21+%E4%B8%8A%E5%8D%8811.25.17.jpg" alt="image" /></p>

<h3>功能二</h3>

<p><img src="https://lh4.googleusercontent.com/-HjzcF7nh4y0/UUp-YUkVjUI/AAAAAAAALms/sls8kHck6LI/s614/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-03-21+%E4%B8%8A%E5%8D%8811.25.28.jpg" alt="image" /></p>

<p>可以看到兩個功能外框是類似的，差別在欄位的不同，其中共用的部分：</p>

<ul>
<li>功能二的 grid 與功能一的 userGroupId 的 combobox store 為同一個 <code>US.USM002.Store</code></li>
<li>兩個功能之 panal 皆繼承於 <code>Frontend.view.common.gridpanel.standard</code></li>
<li>controller 也繼承於 <code>Frontend.controller.common.Standard</code></li>
</ul>


<p>透過 extjs 的模組化功能，我們可以很輕易的將重覆的程式碼進行利用，在 mvc 三個維度也可以很方便進行分工，只要各個元件的 id 索引定義清楚，幾乎可以獨立開發，剩下的就是最後的整合運作需要一起 debug，extjs 在前端 mvc 的架構卻實作的蠻漂亮的，有興趣可以參考一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: 流程控制 - 並發(類多執行續)與等待(類循序程序)]]></title>
    <link href="http://smlsun.com/blog/2013/02/23/javascript-sync/"/>
    <updated>2013-02-23T13:50:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/23/javascript-sync</id>
    <content type="html"><![CDATA[<p>在開發網站應用程式時，假設有用到與後端的 server 透過 ajax 互動交換資料，為了確保當 ajax 執行完成後，能夠循序的執行之後的資料呈現，一般來說我們會使用 callback 來確保順序是正確的，不過 callback 一多程式是比較多層一點，對與我以往的經驗有是用過 DWR 提供的 setAsync(false) 來達到同樣的效果，不過該作法有個缺點，如果某個函數執行時間過長，會感覺好像整個瀏覽器都當掉一樣，因此我們需要更好的作法。</p>

<p>在找相關資料時，剛好有的不錯的參考介紹給大家：<a href="http://book.nodejs.tw/zh-tw/node_javascript.html#id1">JavaScript 與 NodeJS - 流程控制</a>，雖然該篇文章是以 NodeJS 為主，但實際上NodeJS 就是利用 javascript 來進行程式撰寫，所以概念上相當類似，其中關於流程控制章節，就是我們要參考的內容。</p>

<h2>並發與等待</h2>

<p>所謂的併發就是有點像多執行續，而等待就是等所有執行續都完成後在執行指定的函式，簡單來說假設你有 a, b, c 三個函式，其中你必須等待 a, b 兩個函式都執行完成後在執行 c 這個函式，最直覺的作法就是使用 callback 一個一個執行，但實際上如果一多的話程式會變得很難閱讀，所以換個方式來處理這樣的問題，我們來看一下下面的範例：</p>

<p>``` javascript</p>

<pre><code>var wait = function(callbacks, done) {
    console.log('wait start');
    var counter = callbacks.length;
    var results = [];

    var next = function(result) {//接收函數執行結果，並判斷是否結束執行
        //closure 
        results.push(result);
        if(--counter == 0) {
            done(results);//如果結束執行，就把所有執行結果傳給指定的callback處理
        }
    };

    for(var i = 0; i &lt; callbacks.length; i++) {//依次呼叫所有要執行的函數
        //每個 callback 皆呼叫 next 函式，一旦 counter 歸 0 則執行 done 函式。
        callbacks[i](next);
    }
    console.log('wait end');
}
</code></pre>

<p>```</p>

<p>上面的 wait 函式實作了多函數 callbacks 執行完後在執行 done 的函式，透過每個函數執行完後就將 counter 減一，檢查 counter 是否歸 0，而下面就是實際應用的範例：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            setTimeout(function(){
                // callback 呼叫 next 函數
                console.log('done a');
                var result = 500;
                next(result)
            },500);
        },
        function(next){
            setTimeout(function(){
                console.log('done b');
                var result = 1000;
                next(result)
            },1000);
        },
        function(next){
            setTimeout(function(){
                console.log('done c');
                var result = 1500;
                next(1500)
            },1500);
        }   
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        var ret = 0, i=0;
        for(; i&lt;results.length; i++) {
            ret += results[i];
        }
        console.log('done all. result: '+ret);
    }
);
</code></pre>

<p>```</p>

<p>如上面的例子，我們就可以很簡單的處理需要同步執行的狀況啦！</p>

<p>在舉個例子假設我們要使用 extjs 的 msg box 一旦確定完成後才執行後續程式，我們可以改寫成：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        },
        function(next){
            next(" hello!")
        }  
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        Ext.MessageBox.alert('Status', 'results id '+ results[0]+' and '+ results[1]);
    }
);
</code></pre>

<p>```</p>

<p>就是這麼簡單！而在進階一點如果我們需要連續兩次 confirm 該怎麼做？直覺上，如果應該會如此處理：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        },
        function(next){
             Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        }  
    ],

    // 一旦上述函數皆執行完成，傳入每個函數執行完成的 results 進行處理
    function(results){
        Ext.MessageBox.alert('Status', 'results id '+ results[0]+' and '+ results[1]);
    }
);
</code></pre>

<p>```</p>

<p>但是！實際上只會有一個 confirm 跳出來，因為是同時執行對於 ext 而言 Ext.MessageBox 是同一個物件，所以最後一個執行的會把前述的 confirm 蓋掉，因此就只會有一個 confirm，正確來說我們可以在  done 在執行一個 wait，如下：</p>

<p>``` javascript</p>

<pre><code>wait(
    [
        function(next){
            Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
        }
    ],

    function(resultsA){
        wait(
            [
                function(next){
                    Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', next);
                }
            ],

            function(resultsB){
                Ext.MessageBox.alert('Status', 'results id '+ resultsA[0]+' and '+ resultsB[0]);
            }
        );
    }
);
</code></pre>

<p>```</p>

<p>如此一來，就可以正確擷取到兩次 confirm 的內容，基本上上述的函式在使用上必須注意，所謂的併發就是個函數之間不能有先後關係，只能與等待的函數有先後關係，透過上述的例子要操作相關的函數執行流程就不是問題了。</p>

<p>另外一個流程控制的議題，假設你有個連續的 ajax 請求需求，且必須照順序執行可參考下列文章：<a href="http://blog.darkthread.net/post-2012-09-05-sequential-ajax-with-jquery.aspx">以jQuery循序執行AJAX呼叫，並依結果決定是否繼續</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: tree 的建立與使用]]></title>
    <link href="http://smlsun.com/blog/2013/02/19/extjs-tree/"/>
    <updated>2013-02-19T18:40:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/19/extjs-tree</id>
    <content type="html"><![CDATA[<p>資料來源：</p>

<ul>
<li><a href="http://blog.yslifes.com/archives/738">範例Tree元件的使用Ext.tree.TreePanel</a></li>
<li><a href="http://nano-chicken.blogspot.tw/2009/08/extjs-exttreetreepanel_2847.html">extjs - Ext.tree.TreePanel 簡介</a></li>
</ul>


<p>ExtJS的TreePanel樹是繼承Ext.Panel，所以它可以算是一個Container，不過它也是算是一個ExtJS的Component，給於TreeNode來完成樹狀結果，可以應用在選單或是分類等地方。</p>

<p>這裡將介紹兩種 tree 的建立方式：</p>

<h1>利用物件來產生 tree</h1>

<pre><code>Ext.onReady( function() {

    var root = new Ext.tree.TreeNode( {
        text : '根'
    });

    var node1Child1 = new Ext.tree.TreeNode( {
        text : '個人資料維護',
        leaf : 'true'// 是否為末結果,樹葉
    });
    var node1Child2 = new Ext.tree.TreeNode( {
        text : '密碼變更',
        leaf : 'true'// 是否為末結果,樹葉
    });

    var node1 = new Ext.tree.TreeNode( {
        text : '個人資料'
    });
    node1.appendChild(node1Child1);
    node1.appendChild(node1Child2);

    root.appendChild(node1);

    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : root

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>利用 script 來產生 tree 透過 AsyncTreeNode</h2>

<p>若是用此方法需要使用 <code>AsyncTreeNode</code>，此外你的 children 也可以掛載 json Object 需要注意的是組成 tree 所需要的 config 都需要有才能正確產生，以及 <code>AsyncTreeNode</code> 的特性，如果節點一次都沒有打開過，若想要經由 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild</a>來取得參照是沒辦法的，因為是 Async (非同步)，所以未開啟其節點尚未實體化。</p>

<pre><code>Ext.onReady( function() {
    var viewport = new Ext.tree.TreePanel( {

        title : "系統相關",
        width : 200,

        height : 500,
        rootVisible : true,//root結點顯不顯示
        root : new Ext.tree.AsyncTreeNode( {
            text : '根',

            children : [ {
                text : '個人資料',
                children : [ {
                    text : '個人資料維護',
                    leaf : true
                }, {
                    text : '密碼變更',
                    leaf : true
                } ]
            }, {
                text : '客戶資料',
                children : [ {
                    text : '客戶基本資料查詢維護',
                    leaf : true
                }, {
                    text : '客戶基本資料列印',
                    leaf : true
                } ]
            }]
        })

    });

    viewport.render('toolbar');
    viewport.doLayout();

});
</code></pre>

<h2>讀取 json 資料來源產生 tree</h2>

<p>假設遠端的 json 資料來源：</p>

<pre><code>[{
    id: 1,
    text: 'A leaf Node',
    leaf: true
},{
    id: 2,
    text: 'A folder Node',
    children: [{
        id: 3,
        text: 'A child Node',
        leaf: true
    }]
}]
</code></pre>

<p>leaf 屬性會在 load 的時候，判斷是否要在遞迴產生子節點。而原本的 Ext.tree.TreeNode 並不支援 Ajax，所以也要改成 Ext.tree.AsyncTreeNode，程式碼如下：</p>

<pre><code>Ext.onReady(function() {
    var root = new Ext.tree.AsyncTreeNode({text: 'root'});
    var tree = new Ext.tree.TreePanel({
        el: 't',
        width: 150,
        autoHeight: true,
        root: root,
        loader: new Ext.tree.TreeLoader({dataUrl: 'tree.json'})
    });
    tree.render();
});
</code></pre>

<p>與上面的例子差別在多了使用了 Ext.tree.TreeLoader。</p>

<h2>讀取 xml 資料來源產生 tree</h2>

<p>除了 json 結構讀取外，在 extjs 的 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-loader.html">官方 sample</a> 有資料來源為 xml 的範例。</p>

<p>其中使用 extjs 延伸套件 <a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/ux/XmlTreeLoader.js">Ext.ux.tree.XmlTreeLoader</a>，使用上必須先自行定義 component extend Ext.ux.tree.XmlTreeLoader 並且實作 processAttributes，使用上無法定義 maping 的方式，他會把所有的 xml tag 跑過一變，必須在 tag 中的 Attribute 能有識別的方式，其中若是 tag 裡的內容預設會塞入 innerText 參數。</p>

<ul>
<li><a href="http://dev.sencha.com/deploy/ext-3.4.0/examples/tree/xml-tree-data.xml">xml 資料來源</a></li>
</ul>


<h2>tree 的操作與參照</h2>

<p>上面介紹了各種產生 tree 的方式，這邊要介紹一下如何透過 extjs 提供的函數來操作相關的節點，幾個重要的函數：</p>

<ul>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.tree.TreePanel-method-expandPath">expandPath( path, [attr], [callback] )</a></p>

<p>  預設的 path 是根據 id 來作為目錄結構的敘述，[attr] 可以改變目錄索引的屬性。</p></li>
<li><p>selectPath( path, [attr], [callback] )</p>

<p>  使用方式同上，不同的是會執行 expandPath 在做 selectPath</p></li>
<li><p><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.data.Node-method-findChild">findChild( attribute, value, [deep] )</a></p>

<p>  用來查詢特定的節點，其中若未設置 deep ＝ tree 將只搜尋使用此函數之物件的下一層，另外在上面有提到，如果是使用 AsyncTreeNode 尚未開啟節點前是找不到的。</p></li>
</ul>


<p>其他請參照 API，以下有實際使用飯例：</p>

<pre><code>Ext.onReady( function() {
  var viewport = new Ext.tree.TreePanel( {
    title : "系統相關",
    width : 200,
    height : 500,
    rootVisible : true,//root結點顯不顯示
    root : new Ext.tree.AsyncTreeNode( {
      text : '根',
      id:'r',

      children : [ {
        text : '個人資料',
        id:'c1',
        children : [ {
            text : '個人資料維護',
            id:'c1c1',
            leaf : true

        }, {
            text : '密碼變更',
            myid:'c1c2',
            leaf : true
        } ]
      }, {
        text : '客戶資料',
        id:'c2',
        children : [ {
            text : '客戶基本資料查詢維護',
            leaf : true,
            id:'c2c1'
        }, {
            text : '客戶基本資料列印',
            leaf : true,
            id:'c2c2'
        } ]
      } ]
    })

  });

  viewport.render('toolbar');
  viewport.doLayout();

  var btn=new Ext.Button({
    renderTo:"btn",
    id:'test',
    text:'test',
    handler:function(){

        // selectPath 可以做到 expand 之後在進行 select
      viewport.selectPath('/r/c2/c2c1');

      // 選取另一個節點需注意的是若 c1c1 此節點未被開啟，結果會為 undifine
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 一旦開啟過節點，再次 findChild 就會取得實體。
      viewport.expandPath('/r/c1/c1c1');
      alert(viewport.root.findChild( 'id', 'c1c1', true ));

      // 除了 id 之外，我們也可以用別的屬性來做搜尋
      viewport.root.findChild( 'myid', 'c1c2', true ).select();
    }
  });

});
</code></pre>

<p>說明都在程式註解中，這邊就不再多做說明，以下是實際範例運行的結果：</p>

<iframe style="width: 100%; height: 600px" src="http://jsfiddle.net/smlsun/xyvJX/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: component 的使用，找尋 parent & child，以及區別 id、itemid 以及 ref 的不同]]></title>
    <link href="http://smlsun.com/blog/2013/02/19/extjs-component/"/>
    <updated>2013-02-19T14:47:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/19/extjs-component</id>
    <content type="html"><![CDATA[<p>了解 component 的運作將有助於在操作 extjs 時，能夠更靈活操作在一個頁面中各個元件的運作，有了 component 查詢父類以及子類的方法可以更方便存取各階層的元件，特別在 single page 的頁面設計下更顯重要，並且在前端程式架構與分工上我們將可以很輕易的將 view 與事件獨立開來，避免重覆設計元件，造成維護上的困擾。</p>

<p>下面將說明查詢父類以及子類的方式</p>

<h2><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component">component</a> hierarchy (階層)</h2>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.BoxComponent">Ext.BoxComponent</a></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Container">Ext.Container</a></li>
</ul>
</li>
</ul>


<h2>取得特定 component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext-method-getCmp">getCmp</a></li>
</ul>


<h2>取得 parent component</h2>

<p>因為 extjs 所有的元件皆繼承於 component，且 Ext.Container 擁有 component，故通常透過下列方式取得的 parent Component 都屬於 Ext.Container，雖然如此，parent 物件還是擁有當初創建 Component 的屬性或方法。</p>

<ul>
<li><p><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-ownerCt">Component.ownerCt</a></p>

<p>  ownerCt 為 Component 的 properties，因此可直接取得，詳細可查找 extjs api</p></li>
</ul>


<p><code>javascript
parent = child.ownerCt;
</code></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentBy">findParentBy</a></li>
</ul>


<p>``` javascript   <br/>
var form=this.findParentBy(function(p) {
  //定義你要索引的 parent 的條件式，若回傳為 true 將會回傳該 container parent</p>

<pre><code>return p.getForm;
</code></pre>

<p>});
```</p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentByType">findParentByType</a> (  String/Class xtype ) : Container</li>
</ul>


<p>主要透過 findParentBy 實作，找出最接近且符合傳入 xtype</p>

<p>``` javascript</p>

<p>function (xtype) {
  return Ext.isFunction(xtype) ?</p>

<pre><code>this.findParentBy(function(p){
    return p.constructor === xtype;
}) :
this.findParentBy(function(p){
    return p.constructor.xtype === xtype;
});
</code></pre>

<p>}
```</p>

<h2>取得 child component</h2>

<ul>
<li>getComponent</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').getComponent('childPanel09');
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>find</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').find('id', 'childPanel09')[0]; // [0] because find returns array
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li><p>findBy</p>

<p>  使用方式同 findParentBy</p></li>
<li><p>findByType</p>

<p>  使用方式同 findParentByType</p></li>
</ul>


<h2>id 與 itemid 的不同</h2>

<p>從官方的 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-id">Ext.Component-cfg-id</a> 以及 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-itemId">Ext.Component-cfg-itemId</a> 的說明可以看到文件內容記載，為了避免翻譯上的落差，使用中英文對照：</p>

<h3>id</h3>

<p>節錄比較重要的部分，全文請參考官方 API</p>

<p>id 是作為 component 的 唯一識別，如果沒有設置 id 將會自動產生 id。</p>

<blockquote><p>The unique id of this component (defaults to an auto-assigned id).</p></blockquote>

<p>必須注意的是 id 會作為 html 中 element 的 id，一旦該物件已經被 rendered。</p>

<blockquote><p>Note that this id will also be used as the element id for the containing HTML element that is rendered to the page for this component.</p></blockquote>

<p>如果你有需要改變 component 的 css 就可以透過 id 來進行操作，如果也需要改變 component 底下的 子元件也必須使用 id 來操作。</p>

<blockquote><p>This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to select sub-elements using this component's id as the parent.</p></blockquote>

<p>官方文件說明的很清楚，我就不再補述了。接著我們在來看 itemid 的說明。</p>

<h3>itemid</h3>

<p>itemid 可以作為參照 component 的替代方案</p>

<blockquote><p>An itemId can be used as an alternative way to get a reference to a component when no object reference is available.</p></blockquote>

<p>其中：</p>

<ul>
<li>id 可用於 Ext.getCmp</li>
<li>itemid 用於 Ext.Container.getComponent</li>
</ul>


<p>區別兩者不同，並且善用能夠取得設定該 config 相關的元件</p>

<blockquote><p>Instead of using an id with Ext.getCmp, use itemId with Ext.Container.getComponent which will retrieve itemId's or id's.</p></blockquote>

<p>一旦 itemid 設置於 container 底下的任何物件 (MixedCollection)，則 itemId 他的範圍 (Scope) 將只限於 container 並且是區域性的。</p>

<blockquote><p>Since itemId's are an index to the container's internal MixedCollection, the itemId is scoped locally to the container</p></blockquote>

<p>最後為了避免淺在衝突，若是使用 Ext.ComponentMgr 必須要有唯一的 id 可進行識別</p>

<blockquote><p>avoiding potential conflicts with Ext.ComponentMgr which requires a unique id.</p></blockquote>

<p>從上面的敘述中可以看出一些使用上需注意的地方</p>

<ol>
<li>若你要取得相關的 Component 若是屬於 container 請設置 id</li>
<li>若是只屬於某個 container 底下的元件，請設置 itemId；某些情況下當然你也可以連同 id 一起設置，比如需要改變 css style，除此之外 itmeid 還是優先的選擇</li>
<li>getCmp 以及 getComponent 是不一樣的，使用上必須注意，必須搭配 id 以及 itemid 使用</li>
</ol>


<p>如此一來 id 與 itemid 就會有從屬關係，非必要不需定義 id，也不會造成在定義 id 時需要編碼避免重覆，而因為 itemid 是屬於某個 id 底下的，所以即使 itemid 重覆，也可以利用唯一的 id 利用 Ext.getCmp 取得參照後，在接著使用 getComponent 取得所屬 itemId 的參照。</p>

<p>實際的使用參考官方範例：</p>

<pre><code>var c = new Ext.Panel({ //
    height: 300,
    renderTo: document.body,
    layout: 'auto',
    items: [
        {
            itemId: 'p1',
            title: 'Panel 1',
            height: 150
        },
       {
        itemId: 'p2',
            title: 'Panel 2',
            height: 150
        }
    ]
})
p1 = c.getComponent('p1'); // not the same as Ext.getCmp()
p2 = p1.ownerCt.getComponent('p2'); // reference via a sibling
</code></pre>

<p>除了上述 id 以及 itemid 可用於索引元件取得參照之外，我們還可以使用以下方法</p>

<h2>ref</h2>

<p>使用 ref 可以更加方便得取得 container 底下的 Component，連 getComponent 都可以免了。</p>

<p>參考官方文件 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component-cfg-ref">Ext.Component-cfg-ref</a></p>

<p>ref 是使用路徑的語法，該路徑相關於 Component 的 ownerCt，ownerCt 所參照的是該物件的所屬的 Container 也就是他的上層父元件</p>

<blockquote><p>A path specification, relative to the Component's ownerCt specifying into which ancestor Container to place a named reference to this Component.</p></blockquote>

<p>從上面的敘述有個概念後，來看實例會更清楚 ref 的作用，如下：</p>

<p>``` javascript</p>

<pre><code>// 自定義數一個元件，繼承於 Ext.form.FormPanel
MyComponent = Ext.extend(Ext.form.FormPanel, {
    frame: true,

    initComponent: function() {

        // 這個元件擁有兩個欄位，以及兩個 button
        var config = {
            items: [{
                        xtype: 'textfield',
                        fieldLabel: 'Name'
                    }, {
                        xtype: 'textfield',
                        fieldLabel: 'Address'
                    }],
            /* 
            * 對於 bbar 裡的 button 使用 ref
            * 在這層結構上為 panel &gt; toolbar &gt; button
            * 為了改變為 panel &gt; button
            * 所以以 button 的 ownerCt 為 root 也就是 toolbar 的情況下
            * 在往上一層就如同上述的結構透過 ../ 將層級提昇
            */
            bbar: ['-&gt;', {
                        text: 'Cancel',
                        minWidth: 100,
                        ref: '../cancelButton' 
                    }, {
                        text: 'Save',
                        minWidth: 100,
                        ref: '../saveButton' 
                    }]
        };

        //將 initComponent 裡設置好的初始 config 與 initialConfig 合併作為初始的元件
        Ext.apply(this, Ext.apply(this.initialConfig, config));

        //執行 superclass.initComponent 並且指定自定義好的元件作為 this 
        MyComponent.superclass.initComponent.apply(this, arguments);

    }
});

//對新元件註冊 xtype 透過 Ext.reg
Ext.reg('my_component_xtype', MyComponent);


// Create a display a window with the panel in it...

var w = new Ext.Window({
            modal: true,
            items: {
                // 一旦 my_component_xtype 也就是 MyComponent
                // 被實體化後就會有兩個欄位與兩個 button
                xtype: 'my_component_xtype',
                title: 'Panel 1',
                // 在這邊的階層為 window &gt; panel
                ref: 'theFormPanel'
            }
        });
w.show();


// See how we can use the references...
// 因為在 MyComponent 改變了 ref 往上一層跳過 toolbar
// 所以我們就可以如以下操作該物件

w.theFormPanel.saveButton.on('click', function() {
            console.log('Save was clicked');
        }, this);
</code></pre>

<p>```</p>

<p>詳細註解與說明都在上面程式的註解裡，這邊就不多做說明，可以看到透過 ref 的使用，我們可以更加方變得操作 extjs 裡的元件。除了 id 以及 itemid 之外也多了一個可以更方便敘述物件關係的方式。</p>

<p>在這篇文章寫好之前，上面的差異我從來都不知道，也這樣用了好幾年… 說來慚愧，使用一個新的語言或框架基礎還是很重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: grid 中的欄位使用 templete 並且能夠呼叫 rowIndex 以及 colIndex 屬性]]></title>
    <link href="http://smlsun.com/blog/2013/02/18/extjs-grid-column-use-templete-get-rowindex-and-colindex/"/>
    <updated>2013-02-18T19:12:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/18/extjs-grid-column-use-templete-get-rowindex-and-colindex</id>
    <content type="html"><![CDATA[<p>在 grid 中的 column 使用 templete 除了顯示自定的欄位內容外，有些時候我們希望可以存取資料行的索引，如此一來才可以對資料內容進行相對定的事件處理並且能夠正確操作相關的物件。</p>

<p>但是原生的 templete 並沒有對應的 rowIndex 或者事件定義可以讓我們存取，所以我們必須轉個彎來達到這目的，有兩個方式 ...</p>

<h2>透過對 Ext.grid.TemplateColumn 進行繼承改寫</h2>

<p>開始說明作法之前需先了解在 extjs 中 Ext.grid.TemplateColumn 的運作方式，原始碼如下：</p>

<pre><code>Ext.grid.TemplateColumn = Ext.extend(Ext.grid.Column, {

    constructor: function(cfg){
        Ext.grid.TemplateColumn.superclass.constructor.call(this, cfg);
        var tpl = (!Ext.isPrimitive(this.tpl) &amp;&amp; this.tpl.compile) ? this.tpl : new Ext.XTemplate(this.tpl);
        this.renderer = function(value, p, r){
            return tpl.apply(r.data);
        };
        this.tpl = tpl;
    }
});
</code></pre>

<p>其中</p>

<pre><code>this.renderer = function(value, p, r){
    return tpl.apply(r.data);
};
</code></pre>

<p>可以看到其實他的實作方式就是利用 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.grid.Column">Ext.grid.Column 中的 renderer</a> config 來自動呼叫 tpl.apply，其實在官方文件中 renderer 還有後面的參數可以使用，分別是 rowIndex，colIndex，store，完整可以參考 API。</p>

<p>既然原生的 renderer 就有 rowIndex，colIndex 我們只要 extent Ext.grid.TemplateColumn 並且改寫 renderer 令 templete 新增參數即可，所以我們可以這樣做：</p>

<pre><code>Ext.grid.CusTemplateColumn = Ext.extend(Ext.grid.TemplateColumn, {
constructor: function(cfg){
    Ext.grid.TemplateColumn.superclass.constructor.call(this, cfg);
        var tpl = (!Ext.isPrimitive(this.tpl) &amp;&amp; this.tpl.compile) ? this.tpl : new Ext.XTemplate(this.tpl);    

    this.renderer = function(value, p, r, rowIndex, colIndex){

            //第一種方法 
            var newData=Ext.apply({rowIndex: rowIndex, colIndex: colIndex}, r.data);
            return tpl.apply(newData);

            //第二種方法
            //r.data.rowIndex = rowIndex;
            //r.data.colIndex = colIndex;
            //return tpl.apply(r.data);

            //未修改前
            //return tpl.apply(r.data);
        };

        this.tpl = tpl;
}
});
</code></pre>

<p>在上面程式碼中， Ext.apply 所做的就是將目前的物件與傳進來的物件屬性進行合併，如 API 中的敘述</p>

<blockquote><p>Copies all the properties of config to obj. apply</p></blockquote>

<p>其中，tpl 所使用的 tpl.apply 與 Ext.apply 是不一樣的，他是 applyTemplate 的別名</p>

<blockquote><p>Alias for applyTemplate Returns an HTML fragment of this template with the specified values applied.</p></blockquote>

<p>最主要的概念就是針對 tpl.apply 參數所需傳入的物件加上 rowIndex，colIndex 就可以令 temlete 中 html可以存取該屬性，如此一來一旦 grid 有分頁的狀況或者改變排序，在 templete 中的 rowindex 也會隨著改變。</p>

<p>實際上範例的運作如下：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/smlsun/TfnRS/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>接著我們就可以將其應用於 grid 的欄位建立：</p>

<pre><code>var template = new Ext.XTemplate('&lt;input type="checkbox" name="check{rowIndex}" id="checkbox" value="{title}"/&gt;');

var myColumn==new Ext.grid.CusTemplateColumn({ 
    ...
tpl:template     
});

var grid = new Ext.grid.GridPanel({
    ...
columns: [
    { id: 'title-col', header: "Title", width: 225, dataIndex: 'title' },
    myColumn     
],
});
</code></pre>

<p>一旦 grid render 時就會觸動在剛剛所實作的 renderer，在 templete 中的 {rowIndex} 也會正確取得對應的值。</p>

<p>有了上面的概念，其實換個方法可以不用 extent TemplateColumn 也可以做到相同效果 ...</p>

<h2>透過 grid 欄位之 renderer</h2>

<p>我們可以在 renderer 中直接使用定義好的 template 如下面程式碼：</p>

<pre><code>var myColumn={ 
    ...
    renderer : function(value, p, r, rowIndex, colIndex){
        r.data.rowIndex = rowIndex;
        r.data.colIndex = colIndex;
        return template.apply(r.data);
    }
}

var grid = new Ext.grid.GridPanel({
    ...
columns: [
    { id: 'title-col', header: "Title", width: 225, dataIndex: 'title' },
    myColumn     
],
});
</code></pre>

<p>效果是一樣的，可以更直接做到相同的效果，實際上範例的運作如下：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/smlsun/A2eUb/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h2>實際在使用上該選擇哪種方式？</h2>

<p>方法有很多種，只要能夠達到目的都是可用的方法，但總是有較適合的，一個簡單的判斷方式：如果有很多地方需要用到 extend 的 template 那建議用第一個方法，只要寫一次任何時候需要用到只要引入該客製元件即可，一旦往後有需要在對該元件進行修改調整，只要修正一個地方即可；但如果只有一處用會用到那就用第二種方法，避免過度設計，對於資源載入更加精簡。</p>
]]></content>
  </entry>
  
</feed>
