<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-05T10:23:53+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs: events]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-events/"/>
    <updated>2013-02-05T10:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-events</id>
    <content type="html"><![CDATA[<p>資料來源: 次世代 Ajax 解決方案 EXTjs 開發實戰</p>

<p>作者:徐會生、何啟偉、康愛媛</p>

<h2>Ext之事件模型</h2>

<p>所有繼承自 Ext.util.observable 類別的控制項皆可以支援事件。因此可對這些繼承自 Ext.util.observable 的物件定義事件，並為這些事件配置監聽器。當某個事件被觸發，Ext會自動呼叫對應的監聽器，此即為Ext之事件模型。</p>

<p>下面是個簡單的例子</p>

<h3>定義Person類別</h3>

<ul>
<li>此例定義了一個Person物件，擁有一個屬性 name。</li>
<li>使用 this.addEvent() 函式定義了 walk、eat與sleep三個自訂事件。</li>
<li>使用 Ext.extend() 讓Person物件繼承Ext.util.observable所有屬性。</li>
<li>並擴充一個新函數 info()，並設計info() 函式可傳回Person的資訊。</li>
</ul>


<p>``` javascript
Person = function(name){
  this.name = name;
  this.addEvents(“walk”,”eat”,”sleep”);
}</p>

<p>Ext.extend(Person, Ext.util.observable, {
  info: function(event) {</p>

<pre><code>return this.name + ‘is’ + event + ‘ing.’;
</code></pre>

<p>  }
});
```</p>

<h3>建立Person實體物件(instance)，並為其事件配置監聽器(listener)</h3>

<ul>
<li>on 為 addListener() 的簡寫型式。</li>
<li>on 函式第一個函數為事件名稱，第二個參數為事件發生時所執行的函數。</li>
</ul>


<p>``` javascript
var person = new Person(‘Lingo’);
person.on(‘walk’ , function() {</p>

<pre><code>Ext.Msg.alert(‘event’ , person.name + “is walking…”);
</code></pre>

<p>});
person.on(‘eat’, function(breakfast, lunch, supper){</p>

<pre><code>Ext.Msg.alert(‘event’, person.name + “want to eat” + breakfast + “and ”+ lunch + “and ” + supper + “.”);
</code></pre>

<p>});
person.on(‘sleep’, function(time) {</p>

<pre><code>Ext.Msg.alert(‘event’,person.name + “從” + time.format(“H”) + “點開始睡覺。”); 
</code></pre>

<p>})
```</p>

<h3>觸發事件</h3>

<ul>
<li>呼叫fireEvent() 即觸發函式，傳入一個事件名稱，其對應之監聽函式即會執行。</li>
<li>與 on() 相反，un() 為 removeListener() 函式的簡寫，用途為刪除某事件之對應函數。</li>
<li>另有一 purgeListeners() 函數，可將所有監聽器刪除。</li>
</ul>


<p>``` javascript
Ext.get(‘walk’).on(‘click’ , function{
  person.fireEvent(‘walk’);
});</p>

<p>Ext.get(‘eat’).on(‘click’, function(){
  person.fireEvent(‘eat’, ‘早餐’, ‘午餐’, ‘晚餐’);
});</p>

<p>Ext.get(‘sleep’).on(‘click’,function(){
  person.fireEvent(‘sleep’, new Date());
});
```</p>

<h2>瀏覽器事件</h2>

<ul>
<li>主要使用 Ext.EventManager, Ext.EventObject 與 Ext.lib.Event 對原生瀏覽器事件進行包裝。</li>
<li>HTML 瀏覽器事件屬於單一綁定，Ext框架則是對於同一個事件可以綁定至多個事件處理控制碼上。</li>
</ul>


<h3>原生 HTML</h3>

<p><code>javascript
var e=document.getElementById(“test”);
e.onclick=function(){alert(“handle1”)};
e.onclick=function(){alert(“hangle2”)};
</code></p>

<blockquote><p>按下 test後，只會顯示 handle2 提示框。</p></blockquote>

<h3>extjs</h3>

<p>``` javascript
Ext.onReady( function(){
  var test = Ext.get(‘test’);
  test.on(‘click’, function() {</p>

<pre><code>alert(“handle1”); 
</code></pre>

<p>  });</p>

<p>  test.on(‘click’, function(){</p>

<pre><code>alert(“handle2”);
</code></pre>

<p>  });
});
```</p>

<blockquote><p>按下 test 後，handle1 與 handle2 提示框皆會依序顯示。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: callback]]></title>
    <link href="http://smlsun.com/blog/2013/02/04/javascript-callback/"/>
    <updated>2013-02-04T22:27:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/04/javascript-callback</id>
    <content type="html"><![CDATA[<h4>資料來源</h4>

<p><a href="http://mao.li/javascript/javascript-callback-function/">JavaScript callback function 理解</a></p>

<h2>定義</h2>

<ul>
<li><p>維基的Callback_(computer_programming):</p>

<blockquote><p>In computer programming, a callback is a reference to a piece of executable code that is passed as an argument to other code.</p></blockquote></li>
<li><p>jQuery文檔How jQuery Works#Callback_and_Functio…：</p>

<blockquote><p>A callback is a function that is passed as an argument to another function and is <strong>executed after its parent function has completed</strong>. The special thing about a callback is that functions that appear after the "parent" can execute before the callback executes. Another important thing to know is how to properly pass the callback. This is where I have often forgotten the proper syntax.</p></blockquote></li>
<li><p>百科： callback 函數</p>

<blockquote><p>callback 函數就是一個通過函數指針調用的函數。如果你把函數的指針（地址）作為參數傳遞給另一個函數，當這個指針被用為調用它所指向的函數時，我們就說這是 callback 函數。</p>

<p>callback 函數不是由該函數的實現方直接調用，而是在特定的事件或條件發生時由另外的一方調用的，用於對該事件或條件進行響應。</p></blockquote></li>
</ul>


<p>因此， callback 本質上是一種設計模式，並且jQuery(包括其他框架)的設計原則遵循了這個模式。</p>

<p>在JavaScript中，callback 函數具體的定義為：函數A作為參數(函數引用)傳遞到另一個函數B中，並且這個函數B執行函數A。我們就說函數A叫做 callback 函數。如果沒有名稱(函數表達式)，就叫做匿名 callback 函數。</p>

<p>因此 callback 不一定用於非同步的狀況，一般同步(blocking)的場景下也經常用到 callback ，比如要求執行某些操作後執行 callback 函數。</p>

<h2>範例</h2>

<p>一個同步(blocking)中使用 callback 的例子，目的是在func1代碼執行完成後執行func2。</p>

<pre><code>var func1=function(callback){
    //do something.
    (callback &amp;&amp; typeof(callback) === "function") &amp;&amp; callback();
}

func1(func2);

var func2=function(){
    alert("func2 run!");
}
</code></pre>

<p>非同步 callback 的例子：</p>

<pre><code>$(document).ready(callback);

$.ajax({
  url: "test.html",
  context: document.body
})
.done(function() { 
  $(this).addClass("done");
})
.fail(function() { alert("error");
})
.always(function() { alert("complete"); 
});
</code></pre>

<p>上述例子為非同步 ajax 請求，當request 有 response 時,如果先前已定義 callback ,將會觸動相關的函數進行執行。</p>

<h2>callback 什麼時候執行</h2>

<p> callback 函數，一般在同步情境下是最後執行的，而在非同步情境下有可能不執行，因為事件沒有被觸發或者條件不滿足。</p>

<h2>callback 函數的使用場合</h2>

<ul>
<li>函數需要同步處理時</li>
<li>setTimeout的延遲時間為0，這經常被用到，settimeout 呼叫的函數其實就是一個callback 的實作，類似範例可參考我的另一篇文章：<a href="http://smlsun.com/blog/2013/02/01/javascript-settimeout/">Javascript: setTimeout</a></li>
<li>method chain：可參考：<a href="http://ithelp.ithome.com.tw/question/10090856">jQuery method chain review</a></li>
</ul>


<p>另外，最好保證 callback 存在且必須是函數引用或者函數表達式：
(callback &amp;&amp; typeof(callback) === "function") &amp;&amp; callback();</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 存取 google spreadsheets 試算表]]></title>
    <link href="http://smlsun.com/blog/2013/02/04/google-spreadsheets-connect/"/>
    <updated>2013-02-04T16:34:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/04/google-spreadsheets-connect</id>
    <content type="html"><![CDATA[<p>google spreadsheets，也就是 google doc 裡面的 excel，對於 excel 的操作相信大家一定不陌生，如果有寫過一些程式，或許有寫過將 excel 當做 database 進行增修改查的動作。</p>

<p>這篇所要介紹的也就是如何存取 google spreadsheets 進行資料的操作，如果你需要一個快速且容易維護的資料庫，那 google spreadsheets 非常適合，將透過 google 所提供的 Visualization API 進行，下面將對幾個重點部分進行介紹</p>

<h2>query Language</h2>

<ul>
<li><p><a href="https://developers.google.com/chart/interactive/docs/querylanguage?hl=zh-TW#Setting_the_Query_in_the_Data_Source_URL">Query Language Reference</a></p>

<p>  google 官方 query api 裡面有關於查詢語法的說明，基本上就像在下查詢 sql 一樣，如果有操作過 sql 語法，非常好理解。</p></li>
</ul>


<h2>publish spreadsheets</h2>

<ul>
<li><p><a href="http://blog.ericsk.org/archives/1417">JavaScript 存取 Google 試算表的資料</a></p>

<p>  這篇有介紹存取方式，以及如何將你的 spreadsheets Publish 以便讓 Visualization API 能夠存取</p></li>
</ul>


<h2>新增 spreadsheets Records</h2>

<p>google Visualization API 無法讓你進行 <strong>新增</strong> 所以如果你需要新增資料，建議使用:</p>

<p><a href="http://support.google.com/drive/bin/answer.py?hl=zh-Hant&amp;answer=87809">Google 表單
</a></p>

<h2>查詢 spreadsheets</h2>

<p>查詢的部份就是重頭戲啦，從範例來看會比較快一點理解：</p>

<p>sample data:</p>

<p><img src="https://lh3.googleusercontent.com/-v-fjMIfNUpU/UQ8hUW60DcI/AAAAAAAALhQ/TjlxGqTLGt0/s604/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-02-04+%E4%B8%8A%E5%8D%8810.46.55.jpg" alt="image" /></p>

<p>範例程式：</p>

<p>``` javascript
// 讀取店家資訊以及地理位置，並且透過 createMarker 將位址加入到 map 裡</p>

<p>// 載入 Visualization API
var query =null;
$(function(){</p>

<p>// key 是假的，請使用你的 key</p>

<pre><code>var URL = 'http://spreadsheets.google.com/tq?key=0AsXj_vRMyOYyk5OXdKRlJXdGZ1FZU3FXRjl6E#gid=0';
  google.load('visualization', '1',
      {'packages': ['table']});
query = new google.visualization.Query(URL);
</code></pre>

<p>});</p>

<p>function queryData(queryStr,createMarker){</p>

<pre><code>query.setQuery("select B,C,D,E,F where H='Y' "+queryStr);

query.send(function(resp){
  if (!resp.isError()) {
    var dataTable = resp.getDataTable();
    var jsonData = JSON.parse(dataTable.toJSON());
    var len = jsonData.rows.length;

        for (var i = 0; i &lt; len; ++i) {
          var row = jsonData.rows[i];

            var markConfig=new Object();
            markConfig.latitude=row.c[3].v;
            markConfig.longitude=row.c[4].v;
            markConfig.address=row.c[2].v;
            markConfig.name=row.c[0].v;
            markConfig.description=row.c[1].v;

            createMarker(markConfig);
        }
    }
});
</code></pre>

<p>}
```
非常簡單，應該也淺顯易懂，幾個重點：</p>

<ol>
<li>在 query 部分，沒辦法使用 column Name，只能使用如 samle 圖片中的 A、B、C…</li>
<li>相同查詢條件下，無法連續查詢，甚至也不會 response records，舉例來說，<code>select B,C,D,E,F where H='Y'</code> 這查詢下第一次 ok，但第二次就會沒有反應，所以在處理上，需檢查查詢條件是否與上次相同，如相同則不需再查，當然也許是可行的，但以我目前測試的結果是這樣</li>
</ol>


<p>如果你要做一個簡單問卷，或是購買清單之類的應用，相信 google spreadsheets 是個不錯的選擇，夠簡單，且輔助 google 表單，可以很快速的完成資料輸入的頁面，查詢上也不複雜，就是幾個實用上要注意的額外處裡一下，希望可以幫有需要的人解省一些時間囉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: setTimeout]]></title>
    <link href="http://smlsun.com/blog/2013/02/01/javascript-settimeout/"/>
    <updated>2013-02-01T21:09:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/01/javascript-settimeout</id>
    <content type="html"><![CDATA[<p>在使用 setTimeout 時，假設要執行 4 次就如同下面的例子：</p>

<p>```javascript
  for (var i = 0; i &lt; 4; i++)
  {</p>

<pre><code>  console.log("A="+i);
  function A(){
      console.log("B="+i);
  }
  window.setTimeout(A, 0);
</code></pre>

<p>  }
```</p>

<p>一般常理判斷結果應該是：</p>

<pre><code>A=0
B=0
A=1
B=1
A=2
B=2
A=3
B=3
</code></pre>

<p>實際結果如下：</p>

<pre><code>A=0
A=1
A=2
A=3
B=4
B=4
B=4
B=4 
</code></pre>

<p>有沒有覺得很奇怪?</p>

<p>這是因為 javascript 屬於單執行序，看起來 <code>window.setTimeout(A, 0);</code> 似乎是馬上執行，但是實際上， for 迴圈裡的 setTimeout 會先放在代執行的堆疊裡，直到 for 迴圈結束，但如此一來到結束時，i 即為 4，所以結果就是堆疊裡的每個待執行任務中的 i 都為 4。</p>

<p>所以比較好的寫法應該是：</p>

<p>```javascript
  var i = 0;
  function doAppend()
  {</p>

<pre><code>  if (i++ &gt;= 1000){
      return;
  }
  console.log("B="+i);
  setTimeout(doAppend, 0);
</code></pre>

<p>  }
  setTimeout(doAppend, 0);
```</p>

<p>跟上面的例子有什麼不同？上面的 setTimeout 每個是獨立的，這個例子的 setTimeout 將 一環接著一環，如此一來，每個 setTimeout 都會有正確的 i 了</p>

<p>關於 javascript 事件驅動以及運作方式想更進一步了解，可參考以下文章</p>

<p><a href="http://www.phpv.net/html/1700.html">JavaScript可否多線程? 深入理解JavaScript定時機制</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: closure]]></title>
    <link href="http://smlsun.com/blog/2013/02/01/javascript-closure/"/>
    <updated>2013-02-01T14:46:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/01/javascript-closure</id>
    <content type="html"><![CDATA[<h4>資料來源</h4>

<ul>
<li><a href="http://caterpillar.onlyfun.net/Gossip/JavaScript/Closure.html">Gossip@caterpillar</a></li>
<li><a href="http://hi.baidu.com/jz1108/item/e549ca105c4c6bf89c778ab6">一句話說 JavaScript 中的 Closure</a></li>
<li><a href="http://blog.ithome.com.tw/index.php?op=ViewArticle&amp;articleId=19392&amp;blogId=257">搞清楚lexical scope與closure</a></li>
</ul>


<h2>什麼是 closure</h2>

<p>JavaScript 中的 closure 是初學者比較難理解的觀念，下面是幾個來源關於 closure 的解釋：</p>

<ul>
<li>A <code>closure</code> is created when a function <code>keeps a link to its parent's scope</code> even after the parent has returned.

<blockquote><p>Object-Oriented JavaScript</p></blockquote></li>
<li>A closure is a protected variable space, created by using nested functions.

<blockquote><p>Pro JavaScript Design Patterns</p></blockquote></li>
<li>A closure is a way to access and manipulate(操作) external variables from within a function.

<blockquote><p>Secrets of the JavaScript Ninja</p></blockquote></li>
<li>Closures are means through which inner functions can refer to the variables present in their outer enclosing function after their parent functions have already terminated.

<blockquote><p>Pro JavaScript Techniques</p></blockquote></li>
<li>A closure is a special kind of object that combines two things: a function, and the environment in which that function was created.

<blockquote><p>MDC</p></blockquote></li>
<li>A closure is a way to access and manipulate(操作) external variables from within a function.

<blockquote><p>Secrets of the JavaScript Ninja</p></blockquote></li>
<li>A "closure" is an expression (typically a function) that can have free variables together with an environment that binds those variables (that "closes" the expression).

<blockquote><p>jibbering.com</p></blockquote></li>
</ul>


<p>本來想將上面的解釋翻譯成中文，發現中文對特定名詞無法很精準的表達，只好讓大家練練英文，有時間在慢慢品嚐，在這直接舉一個實際的例子來看會更容易理解</p>

<p>``` javascript
  function doSome() {</p>

<pre><code>var x = 10;
function f(y) {
  return x + y;
}
return f;
</code></pre>

<p>  }</p>

<p>  var foo = doSome();</p>

<p>  foo(20); //輸出結果為 30
  foo(30); //輸出結果為 40
```</p>

<p>上面 doSome 的例子中，f 建立了一個 closure，如果你單看：</p>

<p>``` javascript
  function f(y) {</p>

<pre><code>  return x + y;
</code></pre>

<p>  }
```</p>

<p>看來起 x 似乎沒有定義。實際上，x 是從外部函式捕捉而來。closure 是個捕捉了外部函式變數（或使之繼續存活）的函式。在上例中，函式 f 建立了 closure，因為它將變數x關入（close）自己的範圍。如果形式 closure 的函式物件持續存活，被關閉的變數 x 也會繼續存活。就像是延續了變數x的生命週期。</p>

<p>由於 doSome 傳回了函式物件並指定給 foo，就 doSome 而言已經執行完畢。單看 x 的話，理應 x 已結束其生命週期，但由於 doSome 中建立了closure並傳回，x 被關閉在 closure 中，所以 x 的生命週期就與 closure 的生命週期相同了。如上例所示， 呼叫 foo(20) 結果就是 10+20（因為被閉關的 x 值是 10 ），呼叫 foo(30) 結果就是 10+30。</p>

<p>更精簡的說明 Closure 就是擁有閒置變數（Free variable）的運算式，上面提到的例子中 x 就是所謂的 Free variable，什麼是 Free variable ？</p>

<p>參考這篇：<a href="http://stackoverflow.com/questions/12934929/what-are-free-variables"></a></p>

<blockquote><p>Free variables are simply the variables that are neither locally declared nor passed as parameter.</p></blockquote>

<p>聽起來很玄，翻譯起來就是 Free variable 代表不是 function 的參數，x 之所以稱為 Free variable 也就是因為在 f 這個 function 外面被宣告，也沒有透過 function 的參數傳入，但是在 f 裡面卻可以存取。</p>

<p>另外 Closure 有 lexical scope 的特性，所謂的 lexical scope 就是讓我們可以用區域變數的方式，把變數當作一個 function 物件的 private member，但是又可以用一個 function 當作 getter/setter 來存取他，如同：</p>

<p>``` javascript
  function Bean() {</p>

<pre><code>var X;
var Y;
this.setX = function(x) {
  X=x;
}
this.getX = function() {
  return X;
}
this.setY = function(y) {
  Y = y;
}
this.getY = function() {
  return Y;
}
</code></pre>

<p>  }</p>

<p>  var a = new Bean();
  a.setX(3);
  a.setY(3);
  alert(a.getX()+""+a.getY());
```</p>

<h2>closure 關閉的對象</h2>

<p>closure 關閉(包起來)的是變數，而不是變數所參考的值。下面這個範例可以證明：</p>

<p>``` javascript
  function doOther() {</p>

<pre><code>var x = 10;
function f(y) {
  return x + y;
}
x = 100;
return f;
</code></pre>

<p>  }</p>

<p>  var foo = doOther();
  foo(20); //結果為 120
  foo(30); //結果為 130
```</p>

<p>直覺來看應該是 10+20，以及 10+30，實際上卻不是，因為在 建立closure時綁定的是 x 變數，而不是數值 10（x變數的值），也因此 doOther 之後改變了 x 變數的值，因此此時 x 的值已變為 100，而後執行 foo 就是用 x=100 在做運算，範例顯示的結果分別是 100+20 與 100+30。</p>

<p>並且由於 closure 綁定的是變數，所以你也可以在 closure 中改變變數的值：</p>

<p>``` javascript
  var sum = 0;
  [1, 2, 3, 4, 5].forEach(function(element) {</p>

<pre><code>   sum += element;
</code></pre>

<p>   });</p>

<p>  sum; //變數內容為 15
```</p>

<p>如果closure關閉了某個變數，使得該變數的生命週期得以延長，那麼這個會怎麼樣？</p>

<p>``` javascript
  function doOther() {</p>

<pre><code>var x = 10;
function f() {
  x--;
  return x;
}
return f;
</code></pre>

<p>  }</p>

<p>  var f1 = doOther();
  var f2 = doOther();</p>

<p>  f1();// 結果是 9
  f2();// 結果還是 9
```</p>

<p>在這個範例中，doOther被呼叫了兩次（或更多次），doOther中的closure關閉了x，並對其執行了遞減。呼叫了f1時，x會被遞減1，所以顯示9，這沒有問題，那麼呼叫f2()後，結果是9？</p>

<p>像這類的例子，其實結果是一致的，關閉的是建立closure時外部範圍下的變數。以上例來說，第一次呼叫doOther時，建立了x變數(新的記憶體位置)，指定值給x變數，而後建立closure將之關閉。第二次呼叫doOther時，建立了x變數(新的記憶體位置)，指定值給x變數，而後建立closure將之關閉。所以f1與f2關閉的根本是不同作用範圍的 x 變數（也就是該次呼叫 doOther 時所建立的 x 變數）。所以上例中，呼叫f2之後顯示的值仍是9。</p>

<h2>Closure 使用上需注意</h2>

<ul>
<li>Closure 有可能會造成記憶體洩漏，主要是因為被參考的變數無法被垃圾收集機制處理，造成佔用的資源無法釋放，所以使用上必須考慮清楚，不要造成意外的記憶體洩漏。（在上面的例子中，如果 f1 一直未執行，使用到的記憶體 x 就不會被釋放）</li>
<li>跟透過函數的參數把變數傳給函數比較起來，Javascript Engine 會比較難對 Closure 進行最佳化。如果有效能上的考量，這一點也需要注意。</li>
</ul>

]]></content>
  </entry>
  
</feed>
