<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-05T14:54:44+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[extjs: component 的使用，找尋 parent & child]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-component/"/>
    <updated>2013-02-05T14:47:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-component</id>
    <content type="html"><![CDATA[<p>了解 component 的運作將有助於在操作 extjs 時，能夠更靈活操作在一個頁面中各個元件的運作，有了 component 查詢父類以及子類的方法可以更方便存取各階層的元件，特別在 single page 的頁面設計下更顯重要，並且在前端程式架構與分工上我們將可以很輕易的將 view 與事件獨立開來，避免重覆設計元件，造成維護上的困擾。</p>

<p>下面將說明查詢父類以及子類的方式</p>

<h2><a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.Component">component</a></h2>

<ul>
<li>subclass :Ext.BoxComponent</li>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.BoxComponent">Ext.BoxComponent</a> subclass: Ext.Container</li>
</ul>


<h2>取得特定 component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext-method-getCmp">getCmp</a></li>
</ul>


<h2>取得 parent component</h2>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-property-ownerCt">Component.ownerCt</a></li>
</ul>


<p><code>javascript
parent = child.ownerCt;
</code></p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentBy">findParentBy</a></li>
</ul>


<p>``` javascript   <br/>
var form=this.findParentBy(function(p) {
  //定義你要索引的 parent 的條件式，若回傳為 true 將會回傳該 container parent</p>

<pre><code>return p.getForm;
</code></pre>

<p>});
```</p>

<ul>
<li><a href="http://docs-devel.sencha.com/ext-js/3-4/#!/api/Ext.Component-method-findParentByType">findParentByType</a> (  String/Class xtype ) : Container</li>
</ul>


<p>``` javascript <br/>
主要透過 findParentBy 實作</p>

<p>function (xtype) {
  return Ext.isFunction(xtype) ?</p>

<pre><code>this.findParentBy(function(p){
    return p.constructor === xtype;
}) :
this.findParentBy(function(p){
    return p.constructor.xtype === xtype;
});
</code></pre>

<p>}
```</p>

<h2>取得 child component</h2>

<ul>
<li>getComponent</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').getComponent('childPanel09');
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>find</li>
</ul>


<p><code>javascript
var childPanel = Ext.getCmp('parentPanel').find('id', 'childPanel09')[0]; // [0] because find returns array
if (childPanel) {
  alert('yes. child exists');
}
</code></p>

<ul>
<li>findBy</li>
<li>findByType</li>
</ul>


<p>父子都搞定了，再來就看你自己了～XD</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[extjs: events]]></title>
    <link href="http://smlsun.com/blog/2013/02/05/extjs-events/"/>
    <updated>2013-02-05T10:18:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/05/extjs-events</id>
    <content type="html"><![CDATA[<p>資料來源: 次世代 Ajax 解決方案 EXTjs 開發實戰</p>

<p>作者:徐會生、何啟偉、康愛媛</p>

<h2>Extjs 事件</h2>

<p>ExtJs對事件的管理非常強大，主要定義在Ext.EventManager對象(單例模式)中。先看註冊事件監聽方式，ExtJs提供了幾種方式來註冊元素監聽函數</p>

<ul>
<li>透過 <code>Ext.EventManager.addListener/on</code> 函數來為指定元素的某種事件註冊監聽函數。例如：<code>Ext.EventManager.on('test1','click',clickMe,this);</code></li>
<li>透過ExtJs元素的on函數來為自身註冊某種事件的監聽處理函數。例如：
<code>Ext.get('test1').on('click', clickMe,this,{preventDefault:true});</code></li>
</ul>


<p>其中 options參數是事件配置項，各項說明如下：</p>

<ul>
<li>scope ：可指定執行上下文</li>
<li>delegate ：事件代理</li>
<li>stopEvent ：阻止冒泡和默認行為</li>
<li>preventDefault ：阻止默認行為</li>
<li>stopPropagation ：停止事件冒泡</li>
<li>normalized ：僅傳原生事件對象</li>
<li>delay ：延遲執行</li>
<li>single :僅執行一次</li>
<li>buffer ：延遲執行，多次時最後一次覆蓋前一次</li>
<li>target :指定在父元素上執行</li>
</ul>


<p>舉例來說，假如我要進行事件延遲處理，就可以使用 delay</p>

<p>``` javascript
Ext.onReady( function (){</p>

<pre><code>Ext.get( "btnAlert" ).on( "click" ,a, this ,{delay:2000});   
</code></pre>

<p>});
```</p>

<p>要知道更詳細的解說可以查看 extjs api: <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.EventManager-method-addListener">Ext.EventManager-method-addListener</a></p>

<h2>Extjs 之事件模型</h2>

<p>所有繼承自 <a href="http://docs.sencha.com/ext-js/3-4/#!/api/Ext.util.Observable">Ext.util.observable</a> 類別的控制項皆可以支援事件。因此可對這些繼承自 Ext.util.observable 的物件定義事件，並為這些事件配置監聽器。當某個事件被觸發，Ext會自動呼叫對應的監聽器，此即為Ext之事件模型。</p>

<p>下面是個簡單的例子</p>

<h3>定義Person類別</h3>

<ul>
<li>此例定義了一個Person物件，擁有一個屬性 name。</li>
<li>使用 this.addEvent() 函式定義了 walk、eat與sleep三個自訂事件。</li>
<li>使用 Ext.extend() 讓Person物件繼承Ext.util.observable所有屬性。</li>
<li>並擴充一個新函數 info()，並設計info() 函式可傳回Person的資訊。</li>
</ul>


<p>``` javascript
Person = function(name){
  this.name = name;
  this.addEvents(“walk”,”eat”,”sleep”);
}</p>

<p>Ext.extend(Person, Ext.util.observable, {
  info: function(event) {</p>

<pre><code>return this.name + ‘is’ + event + ‘ing.’;
</code></pre>

<p>  }
});
```</p>

<h3>建立Person實體物件(instance)，並為其事件配置監聽器(listener)</h3>

<ul>
<li>on 為 addListener() 的簡寫型式。</li>
<li>on 函式第一個函數為事件名稱，第二個參數為事件發生時所執行的函數。</li>
</ul>


<p>``` javascript
var person = new Person(‘Lingo’);
person.on(‘walk’ , function() {</p>

<pre><code>Ext.Msg.alert(‘event’ , person.name + “is walking…”);
</code></pre>

<p>});
person.on(‘eat’, function(breakfast, lunch, supper){</p>

<pre><code>Ext.Msg.alert(‘event’, person.name + “want to eat” + breakfast + “and ”+ lunch + “and ” + supper + “.”);
</code></pre>

<p>});
person.on(‘sleep’, function(time) {</p>

<pre><code>Ext.Msg.alert(‘event’,person.name + “從” + time.format(“H”) + “點開始睡覺。”); 
</code></pre>

<p>})
```</p>

<h3>觸發事件</h3>

<ul>
<li>呼叫fireEvent() 即觸發函式，傳入一個事件名稱，其對應之監聽函式即會執行。</li>
<li>與 on() 相反，un() 為 removeListener() 函式的簡寫，用途為刪除某事件之對應函數。</li>
<li>另有一 purgeListeners() 函數，可將所有監聽器刪除。</li>
</ul>


<p>``` javascript
Ext.get(‘walk’).on(‘click’ , function{
  person.fireEvent(‘walk’);
});</p>

<p>Ext.get(‘eat’).on(‘click’, function(){
  person.fireEvent(‘eat’, ‘早餐’, ‘午餐’, ‘晚餐’);
});</p>

<p>Ext.get(‘sleep’).on(‘click’,function(){
  person.fireEvent(‘sleep’, new Date());
});
```</p>

<h2>瀏覽器事件</h2>

<ul>
<li>主要使用 Ext.EventManager, Ext.EventObject 與 Ext.lib.Event 對原生瀏覽器事件進行包裝。</li>
<li>HTML 瀏覽器事件屬於單一綁定，Ext框架則是對於同一個事件可以綁定至多個事件處理控制碼上。</li>
</ul>


<h3>原生 HTML</h3>

<p><code>javascript
var e=document.getElementById(“test”);
e.onclick=function(){alert(“handle1”)};
e.onclick=function(){alert(“hangle2”)};
</code></p>

<blockquote><p>按下 test後，只會顯示 handle2 提示框。</p></blockquote>

<h3>extjs</h3>

<p>``` javascript
Ext.onReady( function(){
  var test = Ext.get(‘test’);
  test.on(‘click’, function() {</p>

<pre><code>alert(“handle1”); 
</code></pre>

<p>  });</p>

<p>  test.on(‘click’, function(){</p>

<pre><code>alert(“handle2”);
</code></pre>

<p>  });
});
```</p>

<blockquote><p>按下 test 後，handle1 與 handle2 提示框皆會依序顯示。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: callback]]></title>
    <link href="http://smlsun.com/blog/2013/02/04/javascript-callback/"/>
    <updated>2013-02-04T22:27:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/04/javascript-callback</id>
    <content type="html"><![CDATA[<h4>資料來源</h4>

<p><a href="http://mao.li/javascript/javascript-callback-function/">JavaScript callback function 理解</a></p>

<h2>定義</h2>

<ul>
<li><p>維基的Callback_(computer_programming):</p>

<blockquote><p>In computer programming, a callback is a reference to a piece of executable code that is passed as an argument to other code.</p></blockquote></li>
<li><p>jQuery文檔How jQuery Works#Callback_and_Functio…：</p>

<blockquote><p>A callback is a function that is passed as an argument to another function and is <strong>executed after its parent function has completed</strong>. The special thing about a callback is that functions that appear after the "parent" can execute before the callback executes. Another important thing to know is how to properly pass the callback. This is where I have often forgotten the proper syntax.</p></blockquote></li>
<li><p>百科： callback 函數</p>

<blockquote><p>callback 函數就是一個通過函數指針調用的函數。如果你把函數的指針（地址）作為參數傳遞給另一個函數，當這個指針被用為調用它所指向的函數時，我們就說這是 callback 函數。</p>

<p>callback 函數不是由該函數的實現方直接調用，而是在特定的事件或條件發生時由另外的一方調用的，用於對該事件或條件進行響應。</p></blockquote></li>
</ul>


<p>因此， callback 本質上是一種設計模式，並且jQuery(包括其他框架)的設計原則遵循了這個模式。</p>

<p>在JavaScript中，callback 函數具體的定義為：函數A作為參數(函數引用)傳遞到另一個函數B中，並且這個函數B執行函數A。我們就說函數A叫做 callback 函數。如果沒有名稱(函數表達式)，就叫做匿名 callback 函數。</p>

<p>因此 callback 不一定用於非同步的狀況，一般同步(blocking)的場景下也經常用到 callback ，比如要求執行某些操作後執行 callback 函數。</p>

<h2>範例</h2>

<p>一個同步(blocking)中使用 callback 的例子，目的是在func1代碼執行完成後執行func2。</p>

<p>``` javascript</p>

<pre><code>var func1=function(callback){
    //do something.
    (callback &amp;&amp; typeof(callback) === "function") &amp;&amp; callback();
}

func1(func2);

var func2=function(){
    alert("func2 run!");
}
</code></pre>

<p>```</p>

<p>非同步 callback 的例子：</p>

<p>``` javascript</p>

<pre><code>$(document).ready(callback);

$.ajax({
  url: "test.html",
  context: document.body
})
.done(function() { 
  $(this).addClass("done");
})
.fail(function() { alert("error");
})
.always(function() { alert("complete"); 
});
</code></pre>

<p>```</p>

<p>上述例子為非同步 ajax 請求，當request 有 response 時,如果先前已定義 callback ,將會觸動相關的函數進行執行。</p>

<h2>callback 什麼時候執行</h2>

<p> callback 函數，一般在同步情境下是最後執行的，而在非同步情境下有可能不執行，因為事件沒有被觸發或者條件不滿足。</p>

<h2>callback 函數的使用場合</h2>

<ul>
<li>函數需要同步處理時</li>
<li>setTimeout的延遲時間為0，這經常被用到，settimeout 呼叫的函數其實就是一個callback 的實作，類似範例可參考我的另一篇文章：<a href="http://smlsun.com/blog/2013/02/01/javascript-settimeout/">Javascript: setTimeout</a></li>
<li>method chain：可參考：<a href="http://ithelp.ithome.com.tw/question/10090856">jQuery method chain review</a></li>
</ul>


<p>另外，最好保證 callback 存在且必須是函數引用或者函數表達式：
(callback &amp;&amp; typeof(callback) === "function") &amp;&amp; callback();</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 存取 google spreadsheets 試算表]]></title>
    <link href="http://smlsun.com/blog/2013/02/04/google-spreadsheets-connect/"/>
    <updated>2013-02-04T16:34:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/04/google-spreadsheets-connect</id>
    <content type="html"><![CDATA[<p>google spreadsheets，也就是 google doc 裡面的 excel，對於 excel 的操作相信大家一定不陌生，如果有寫過一些程式，或許有寫過將 excel 當做 database 進行增修改查的動作。</p>

<p>這篇所要介紹的也就是如何存取 google spreadsheets 進行資料的操作，如果你需要一個快速且容易維護的資料庫，那 google spreadsheets 非常適合，將透過 google 所提供的 Visualization API 進行，下面將對幾個重點部分進行介紹</p>

<h2>query Language</h2>

<ul>
<li><p><a href="https://developers.google.com/chart/interactive/docs/querylanguage?hl=zh-TW#Setting_the_Query_in_the_Data_Source_URL">Query Language Reference</a></p>

<p>  google 官方 query api 裡面有關於查詢語法的說明，基本上就像在下查詢 sql 一樣，如果有操作過 sql 語法，非常好理解。</p></li>
</ul>


<h2>publish spreadsheets</h2>

<ul>
<li><p><a href="http://blog.ericsk.org/archives/1417">JavaScript 存取 Google 試算表的資料</a></p>

<p>  這篇有介紹存取方式，以及如何將你的 spreadsheets Publish 以便讓 Visualization API 能夠存取</p></li>
</ul>


<h2>新增 spreadsheets Records</h2>

<p>google Visualization API 無法讓你進行 <strong>新增</strong> 所以如果你需要新增資料，建議使用:</p>

<p><a href="http://support.google.com/drive/bin/answer.py?hl=zh-Hant&amp;answer=87809">Google 表單
</a></p>

<h2>查詢 spreadsheets</h2>

<p>查詢的部份就是重頭戲啦，從範例來看會比較快一點理解：</p>

<p>sample data:</p>

<p><img src="https://lh3.googleusercontent.com/-v-fjMIfNUpU/UQ8hUW60DcI/AAAAAAAALhQ/TjlxGqTLGt0/s604/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7+2013-02-04+%E4%B8%8A%E5%8D%8810.46.55.jpg" alt="image" /></p>

<p>範例程式：</p>

<p>``` javascript
// 讀取店家資訊以及地理位置，並且透過 createMarker 將位址加入到 map 裡</p>

<p>// 載入 Visualization API
var query =null;
$(function(){</p>

<p>// key 是假的，請使用你的 key</p>

<pre><code>var URL = 'http://spreadsheets.google.com/tq?key=0AsXj_vRMyOYyk5OXdKRlJXdGZ1FZU3FXRjl6E#gid=0';
  google.load('visualization', '1',
      {'packages': ['table']});
query = new google.visualization.Query(URL);
</code></pre>

<p>});</p>

<p>function queryData(queryStr,createMarker){</p>

<pre><code>query.setQuery("select B,C,D,E,F where H='Y' "+queryStr);

query.send(function(resp){
  if (!resp.isError()) {
    var dataTable = resp.getDataTable();
    var jsonData = JSON.parse(dataTable.toJSON());
    var len = jsonData.rows.length;

        for (var i = 0; i &lt; len; ++i) {
          var row = jsonData.rows[i];

            var markConfig=new Object();
            markConfig.latitude=row.c[3].v;
            markConfig.longitude=row.c[4].v;
            markConfig.address=row.c[2].v;
            markConfig.name=row.c[0].v;
            markConfig.description=row.c[1].v;

            createMarker(markConfig);
        }
    }
});
</code></pre>

<p>}
```
非常簡單，應該也淺顯易懂，幾個重點：</p>

<ol>
<li>在 query 部分，沒辦法使用 column Name，只能使用如 samle 圖片中的 A、B、C…</li>
<li>相同查詢條件下，無法連續查詢，甚至也不會 response records，舉例來說，<code>select B,C,D,E,F where H='Y'</code> 這查詢下第一次 ok，但第二次就會沒有反應，所以在處理上，需檢查查詢條件是否與上次相同，如相同則不需再查，當然也許是可行的，但以我目前測試的結果是這樣</li>
</ol>


<p>如果你要做一個簡單問卷，或是購買清單之類的應用，相信 google spreadsheets 是個不錯的選擇，夠簡單，且輔助 google 表單，可以很快速的完成資料輸入的頁面，查詢上也不複雜，就是幾個實用上要注意的額外處裡一下，希望可以幫有需要的人解省一些時間囉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: setTimeout]]></title>
    <link href="http://smlsun.com/blog/2013/02/01/javascript-settimeout/"/>
    <updated>2013-02-01T21:09:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/01/javascript-settimeout</id>
    <content type="html"><![CDATA[<p>在使用 setTimeout 時，假設要執行 4 次就如同下面的例子：</p>

<p>```javascript
  for (var i = 0; i &lt; 4; i++)
  {</p>

<pre><code>  console.log("A="+i);
  function A(){
      console.log("B="+i);
  }
  window.setTimeout(A, 0);
</code></pre>

<p>  }
```</p>

<p>一般常理判斷結果應該是：</p>

<pre><code>A=0
B=0
A=1
B=1
A=2
B=2
A=3
B=3
</code></pre>

<p>實際結果如下：</p>

<pre><code>A=0
A=1
A=2
A=3
B=4
B=4
B=4
B=4 
</code></pre>

<p>有沒有覺得很奇怪?</p>

<p>這是因為 javascript 屬於單執行序，看起來 <code>window.setTimeout(A, 0);</code> 似乎是馬上執行，但是實際上， for 迴圈裡的 setTimeout 會先放在代執行的堆疊裡，直到 for 迴圈結束，但如此一來到結束時，i 即為 4，所以結果就是堆疊裡的每個待執行任務中的 i 都為 4。</p>

<p>所以比較好的寫法應該是：</p>

<p>```javascript
  var i = 0;
  function doAppend()
  {</p>

<pre><code>  if (i++ &gt;= 1000){
      return;
  }
  console.log("B="+i);
  setTimeout(doAppend, 0);
</code></pre>

<p>  }
  setTimeout(doAppend, 0);
```</p>

<p>跟上面的例子有什麼不同？上面的 setTimeout 每個是獨立的，這個例子的 setTimeout 將 一環接著一環，如此一來，每個 setTimeout 都會有正確的 i 了</p>

<p>關於 javascript 事件驅動以及運作方式想更進一步了解，可參考以下文章</p>

<p><a href="http://www.phpv.net/html/1700.html">JavaScript可否多線程? 深入理解JavaScript定時機制</a></p>
]]></content>
  </entry>
  
</feed>
