<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | 蹤影]]></title>
  <link href="http://smlsun.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://smlsun.com/"/>
  <updated>2013-02-01T13:55:56+08:00</updated>
  <id>http://smlsun.com/</id>
  <author>
    <name><![CDATA[smlsun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[javascript: about scope]]></title>
    <link href="http://smlsun.com/blog/2013/02/01/javascript-about-scope/"/>
    <updated>2013-02-01T12:07:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/01/javascript-about-scope</id>
    <content type="html"><![CDATA[<h4>參考來源</h4>

<ul>
<li><a href="http://www.icoding.co/2012/07/javascript-html-2">提升 JavaScript 效能的技巧</a></li>
<li><a href="http://www.icoding.co/2012/09/javascript2-html">給非 JavaScript 專家的小技巧</a></li>
</ul>


<p>這篇文章是根據上面文章，整理與 scope 相關的資料彙總而成。</p>

<p>scope 的產生與函式息息相關，首先必須先了解函式的運作</p>

<h2>函式是如何被初始化</h2>

<ol>
<li>先宣告函式參數，並設定參數的值</li>
<li>所有函式內部的函式被宣告</li>
<li>所有在這函式 scope 中有宣告的變數被生成 (所以即使變數被宣告在最後一行，但卻可已在函式中的任何地方被存取)</li>
<li>賦予變數值</li>
</ol>


<p>接著來看 scope</p>

<h2>了解變數 scope 以及初始化</h2>

<ol>
<li>唯一的變數 scope 就是你所在的函式。</li>
<li>還有全域的 scope，但並沒有區塊的 scope。</li>
<li>每一個函式都有一個 scope chain，而這個 chain 中會指向上一層函式的 scope。</li>
<li>如果一個變數或是函式被存取但是在當下的 scope 中找不到，這時候就會嘗試往上一層的 scope 去找一直到有一個對應個宣告被找到為止。</li>
<li>如果是嘗試賦予一個變數的值，但往上找卻找不到對應宣告的時候，那麼就會直接在全域 scope 設定一個這個變數名字的屬性。</li>
</ol>


<h2>scope 的運作原理</h2>

<p>當你定義一個全域函式的時候，那根據 ECMAScript 規格，它就會有一個 [[Scope]]屬性，而這個 [[Scope]] 會指到一個 Scope Chain Table，這個 table 裡面存放一個指到 global variables 的 table。</p>

<p><img src="http://2.bp.blogspot.com/-gugDSqh-lUg/T_XMYmUT5fI/AAAAAAAAXUE/WqDmooAtSwM/s1600/scope.jpeg" alt="img" /></p>

<p>之後，當一個函式被執行的時候，對應的 execution context 會被生成，而這個 execution context 會有一個屬於自己的 scope chain，這個 scope chain 會被用來作變數解析。</p>

<p>這個 execution context 一開始先把函式的 [[scope]] 複製一份，之後再產生一個 activation object 裡面指到所有的 local variables table，並把這個 activation object 放在 scope chain 的一開始，所以當 setup 被執行的時候 scope chain 應該是長這樣：</p>

<p><img src="http://1.bp.blogspot.com/-3MdmGetL9rE/T_XMhQIwBhI/AAAAAAAAXUY/6I2Ota50G6o/s1600/scope2.jpeg" alt="img" /></p>

<p>當在 function scope 裡面做任何變數的存取的時候，第一步就是先從位於 0 的 scope chain 開始找，如果沒找到就會再往下一個位置去找。</p>

<p>這也是一般大家理解的會先取用 local 的，之後再往上一層，最後一直都找不到的話，就會產生錯誤。</p>

<p>這邊的重點就是 global 的變數永遠都會在 scope chain 的最後面那一層，所以盡可能地使用 local variables，因為這總是比 global variables快，也就是 jQuery 原始碼裡面將 window 轉換成 local 所提到的效能問題是一樣的。</p>

<p>接著必須了解scope management的知識，對於效能改善是很重要的。</p>

<h2>scope management</h2>

<p>關於 scope management，還有一點很重要的，常聽到人家說不要用 with，而 scope 是其中的一個原因。當你用了 with 的時候其實是在 scope chain 裡面硬加了一個暫時的 scope 在最前面的地方，當離開 with scope 的時候，這個 with scope 物件就消失。</p>

<p>所以在 with 的範圍內，所有原本的 local variables 的存取都變慢了。另外，try/catch 也一樣有這個問題。</p>

<p>在 closure 的部分，可以想像的是至少會有三個 scope chain，一個是 global，一個是 containing function 的 activation context，還有一個是最前面的 local。可以想見 closure 的使用也會影響資料存取的效能，因為存取階層變多的關係。</p>

<h2>效能改善相關</h2>

<ol>
<li>對那些常常會存取的變數，盡量把它放在 local</li>
<li>避免使用 with</li>
<li>小心使用 try / catch</li>
<li>沒有必要的話不要用 closure</li>
<li>不要忘記在宣告變數時要加上 var，不然你會不小心宣告太多全域變數</li>
</ol>


<p>根據以上原則，範例函式如下，使用全域函式 setup，也就是 <code>document</code>。：</p>

<p>``` javascript
  function setup(items)
  {</p>

<pre><code>  var divs = document.getElementsByTagName("div");
  var images = document.getElementsByTagName("image");
  var button = document.getElementsById("save-btn");

  for (var i = 0; i &lt; items.length; i++) {
      process(items[i], div[i]);
  }

  button.addEventListener("click", function(event) {
      alert("Saved");
  }, false);
</code></pre>

<p>  }
```</p>

<p>應該要先將 <code>document</code> 指定給區域變數，修正如下：</p>

<p>``` javascript</p>

<p>  function setup(items)
  {</p>

<pre><code>  var doc = document; // 原本沒有這行

  // document 全部替換為 doc，也就是改為區域變數
  var divs = doc.getElementsByTagName("div");
  var images = doc.getElementsByTagName("image");
  var button = doc.getElementsById("save-btn");

  for (var i = 0; i &lt; items.length; i++) {
      process(items[i], div[i]);
  }

  button.addEventListener("click", function(event) {
      alert("Saved");
  }, false);
</code></pre>

<p>  }
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: performance]]></title>
    <link href="http://smlsun.com/blog/2013/02/01/javascript-performance/"/>
    <updated>2013-02-01T11:56:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/02/01/javascript-performance</id>
    <content type="html"><![CDATA[<p>介紹幾篇關於效能的文章：</p>

<ul>
<li><a href="http://www.icoding.co/2012/07/javascript-html-2">提升 JavaScript 效能的技巧</a></li>
<li><a href="http://www.icoding.co/2012/09/javascript2-html">給非 JavaScript 專家的小技巧</a></li>
</ul>


<p>節錄幾個重要的觀念：</p>

<ol>
<li><p>了解變數 scope 以及初始化</p>

<p> 可參考我的另外一篇文章：<a href="http://smlsun.com/blog/2013/02/01/javascript-about-scope/">javascript: about scope</a></p></li>
<li><p>避免寫與 HTML 混在一起(inline)的 JavaScript</p>

<ul>
<li><p>錯誤示範：</p>

<pre><code>  &lt;button id="my_btn" onclick="doThis();"&gt;Submit&lt;/button&gt;
</code></pre>

<p>  把 JavaScript 跟 HTML 混在一起這樣寫會導致 JavaScript 異常的難以維護。一個新的開發者或需要更長的時間來找出散亂在 HTML 中的 script 並且很難將整個功能的情境拼湊出來。</p></li>
<li><p>正確：</p>

<pre><code>  &lt;button id="my_btn" type="button"&gt;Submit&lt;/button&gt;

  &lt;!-- These scripts go before the &lt;/body&gt; tag. --&gt;&lt;script type="text/javascript" src="http://smlsun.com/s/init.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;// &lt;![CDATA[
  initializePage();
      // pretend that these functions are in /s/init.js
      function initializePage() {
          document.getElementById("my_btn")
              .addEventListener("click", doThis);
      }
      function doThis(e) {
          // do cool stuff here
      }
  // ]]&gt;&lt;/script&gt;
</code></pre></li>
</ul>


<p> 另外關於這兩個寫法更進一步的差異可參考我另外一篇文章：<a href="http://smlsun.com/blog/2013/01/31/javascript-what-is-this/">Javascript: What Is This?</a>，裡面有對類似的範例解釋對 this 的不同。</p></li>
<li><p>找到對的 Event 去做 binding</p>

<p> 比如說表單的提送按鈕上 bind “click" 事件處理實際上不是真的要處理 click ，而是要處理表單送出的事件。那麼這時候你應該 bind 的應該是表單的 “submit"，因為 enter 也會引發表單送出。</p></li>
<li><p>使用快速的 selectors</p>

<p> 如果你只是處理很小部份的 DOM elements，那麼用什麼方法其實沒有那麼重要，隨便你要使用 querySelector 或是 querySelectorAll。但如果你要處理的 DOM element 個數很大的話，記得使用比較快的方式（通常是最老的那個方法）。建議使用 getElementById，所有的瀏覽器都支援而且是目前最快的方式。</p>

<p> 如果你用 jQuery 的話，最好還是使用 IDs 或是 classes 可以得到比較好的效能。</p></li>
<li><p>非必要的時候不要去動 document</p>

<p> 這應該是關於最佳化 JavaScript 效能最重要的技巧：沒事不要去動 document ，除非你百分之百確定你必須這麼做。這通常是大量使用 JavaScript 的網站的瓶頸。</p>

<p> 盡量嘗試把 elements 的 reference 記下來，避免下次還要重新 query document 一次。</p>

<p> 如同一開始提到的 <a href="http://smlsun.com/blog/2013/02/01/javascript-about-scope/">javascript: about scope</a> 文章中有介紹到的範例。</p></li>
<li><p>等值檢查與真值</p>

<p> JavaScript 除了有一般的等值運算元 (==, !=)之外還有必較嚴格的等值運算元 (===, !==)。 差異如下：</p>

<ul>
<li>“5″ == 5 but “5″ !== 5</li>
<li>0 == false but 0 !== false</li>
<li>null == undefined but null !== undefined</li>
</ul>


<p> 換句話說，=== 與 != 在比較的時候不會作自動的真值推導以及型別轉換，必須在兩邊的原始型別相同並且值也相同的情況下才為真。</p></li>
<li><p>資料存取方式</p>

<p> 有四種存取資料的方式分別是：</p>

<ul>
<li>數值或字串  (literal value)</li>
<li>變數</li>
<li>物件屬性</li>
<li>陣列</li>
</ul>


<p> 在這四種方式裡面，literal 與區域變數的存取效率都很好，兩者不相上下。而物件跟陣列的存取相對於前者，效能就差很多。</p>

<p> 物件屬性的深度也會對效能有影響。深度越深的話就自然得會越滿慢。所以在資料結構的設計上要小心。</p>

<p> 在資料存取的建議是：</p>

<ul>
<li>如果有一個物件屬性或陣列元素會被用到超過一次，就用區域變數取代它。</li>
<li>盡量減低物件或是陣列存取的深度。</li>
</ul>
</li>
<li><p>迴圈</p>

<p> 不要使用 for … in 跟 for each。各個 JS framework 提供的 each 也要少用。尤其是每一次 iteration 都要執行一次函式的方式盡量少用。</p></li>
<li><p>DOM</p>

<p> 在第 4. 使用快速的 selectors 有提到過，類似觀念如下：</p>

<p> 透過 document.getElementsByTagName之類的函式取得的 HTMLCollection 的存取都很慢。因為每一次的存取都會重新做一次 DOM query。所以要盡量避免在迴圈中存取 HTMLCollection。但這畢竟是不可能的，建議將 HTMLCollection 轉成陣列後再做處理。不過如果你用 jQuery 的話大概不用擔心這個問題。因為 jQuery  會把 selector query 出來的 collection 轉成陣列，因此大概不會有這個問題。</p>

<p> 關於 DOM 的效能問題，還有一個是 ReFlow，幾乎所有跟 DOM 物件的操作都會引發 ReFlow，新增或是移除 DOM 物件，或是改變 CSS 屬性，甚至是讀取 DOM 物件屬性，都有可能引發 ReFlow。要解決這個問題，必須利用 DocumentFragment，這是一個類似 document 的物件，但是並不在實際的 DOM Tree 裡面，因此在這個 fragment 上做操作不會引發 ReFlow，之後只要將這個 fragment add 到 DOM，所有的 fragment children 都會被加入到實際的 DOM Tree 中。在你其實並不懂 JavaScript 一文中亦有提及一個好的 JavaScript 開發者必須瞭解如何透過 DocumentFragment 來有效率的新增或移除 DOM Nodes。</p>

<p> 關於 DocumentFragment 的使用可以參考這篇 <a href="http://fstoke.me/blog/?p=2487">使用DocumentFragment來加快DOM操作速度</a>，裡面有提到：</p>

<blockquote><p>用Firefox實測，使用第二種DocumentFragment寫法，速度快了將近一倍</p></blockquote></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript: what is this?]]></title>
    <link href="http://smlsun.com/blog/2013/01/31/javascript-what-is-this/"/>
    <updated>2013-01-31T13:12:00+08:00</updated>
    <id>http://smlsun.com/blog/2013/01/31/javascript-what-is-this</id>
    <content type="html"><![CDATA[<h2>到底 this 是誰？</h2>

<p>JavaScript 的 code 寫多了，你一定會碰到 this 這個關鍵字，是某個 object 下的 method 也好，或是 callback function 也好，關於 this 的用法常常會讓人搞混。</p>

<p>以一句簡單的話來說：在 function 裡，this 所代表的就是呼叫這個 function 的東西。</p>

<p>這樣講可能有點抽象，大家來看個實際的例子：</p>

<p>```javascript</p>

<pre><code>&lt;input type ="button"  id ="aButton"  value ="demo" onclick="" /&gt; 
&lt;script type ="text/javascript" &gt; 
    function  demo()  { 
        this .value  =  Math.random(); 
    }
&lt;/script&gt;
</code></pre>

<p>```</p>

<p>如果直接調用demo() 函數，tihs.value 將不存在，因為 demo 函數是在 window 對像中定義的，在簡單來說就是屬於全域，所以demo的擁有者（作用域）是 window(代表全域)，demo 裡的 this 也就是 window。 而 window 是沒有 value 屬性的。</p>

<p>更進一步的來看簡單的例子：</p>

<ul>
<li>button.onclick =  demo ：</li>
</ul>


<p>```javascript
<input type="button" id="aButton" value="demo" /></p>

<script  type="text/javascript"> 
    var button = document.getElementById("aButton"); 
    function demo()  {
      this.value = Math.random(); 
    }
    button.onclick =  demo; 
    alert(button.onclick);
</script>


<p>```</p>

<p>得到的輸出是：</p>

<p>```javascript
  function demo() {</p>

<pre><code>  this.value = Math.random(); 
</code></pre>

<p>  }
```</p>

<ul>
<li>onclick ="demo()"</li>
</ul>


<p>```javascript
<input type="button" id="aButton" value="demo" onclick="demo()" /></p>

<script type ="text/javascript" > 
    var button = document.getElementById("aButton"); 
    function demo ()  { 
        this.value = Math.random(); 
    }
    
    alert(button.onclick);
</script>


<p>```</p>

<p>得到的輸出是：</p>

<p>```javascript
function onclick() {</p>

<pre><code>demo(); 
</code></pre>

<p>}
```</p>

<p>onclick ="demo()" 引用的方式中，onclick 事件只是直接調用 demo() 函數，而 demo() 函數的作用域仍舊是 w​​indow 對象，所以 this 仍然指向 window。</p>

<p>至於一般的 function，「沒指定的話」都是 window，注意我這裡強調是「沒指定」，所以這也就代表了「可以指定」，就可以透過
call() 和 apply()。</p>

<h2>call() 和 apply()</h2>

<p>call() 和 apply() 的差別主要在於 call() 只接受一個參數，即 call(thisArg) ；而 apply() 接受兩個參數，即 apply(thisArg, argArray) 。透過 call() 和 apply() 調用函數的主要目的，在於改變函數內部的 this 名稱所指涉的對象。對一般函數而言，當 programmer 在函數內部使用 this 名稱時，指涉對象是 global object 。global object 是運行環境中最頂層的個體，在瀏覽器環境中，global object 就是 window 此一個體。但是 call() 和 apply() 可以改變 this 名稱所指涉的對象。</p>

<p>其中在 ECMAScript Language Specification - Standard ECMA-262 3rd Edition. 15.3.4.3 &amp; 15.3.4.4，有一段解釋：</p>

<blockquote><p>If thisArg is null or undefined, the called function is passed the global object as the this value. Otherwise, the called function is passed ToObject(thisArg) as the this value.</p></blockquote>

<p>接著我們分別透過 <code>call()</code> 和 <code>apply()</code> 來驗證一下</p>

<ul>
<li>call()</li>
</ul>


<p>```javascript
function myFunc() {</p>

<pre><code>window.alert(this.toString());
</code></pre>

<p>}</p>

<p>myFunc();</p>

<p>var hello = 'hello world';
myFunc.call(hello);
```</p>

<p><code>myFunc();</code>未指定的情狀下，this 輸出的是 window， <code>myFunc.call(hello);</code>則輸出 hello world</p>

<ul>
<li><p>apply()</p>

<p>  以下面這段程式碼為例：</p></li>
</ul>


<p>```javascript
var foo = function(x) {</p>

<pre><code>alert(x);
alert(this);
</code></pre>

<p>}
foo('abc');
```</p>

<p>你應該會看到訊息視窗先顯示 abc，接著就是顯示出 window。但若是變成下面這樣呢？</p>

<p>```javascript</p>

<p>var foo = function() {</p>

<pre><code>alert(arguments[0]);
alert(this.name);
</code></pre>

<p>}
var bar = { name: 'bar' };
foo.apply(bar, ['abc','def']);
```</p>

<p>在呼叫 foo 函式時使用 apply 方法，就可以更換 caller（正確地說是切換 context），而因為用了 apply 方法，函式的參數就要改以陣列傳入。當然，這時候的 this 就變成了 bar。</p>

<p> 結果證實規範內容所言無誤。因此，我們可以利用 call() 和 apply() 改變函數內部的 this 名稱所指涉的對象。</p>

<p>而call跟apply的差別，就在於apply的第二個參數是陣列，而call則是一個一個指定參數例如：</p>

<ul>
<li>call 呼叫的話會變成；<code>myFunc.call(hello,"abc","def");</code></li>
<li>apply 的好處是可以先把陣列準備好，如 <code>foo.apply(bar, ['abc','def']);</code>，然後重覆使用。</li>
</ul>


<p>資料來源：</p>

<ul>
<li><a href="http://blog.roodo.com/rocksaying/archives/2532303.html">石頭閒語</a></li>
<li><a href="http://www.cnblogs.com/ruxpinsp1/archive/2008/04/20/1162463.html">棕熊@Think Fast</a></li>
<li><a href="http://blog.ericsk.org/archives/1360">ericsk.net</a></li>
</ul>


<p>此篇文章是把上面三個來源的內容進行融合，挑選比較淺顯易懂得部分，希望可以幫助對於 this 不是很清楚的人。</p>
]]></content>
  </entry>
  
</feed>
